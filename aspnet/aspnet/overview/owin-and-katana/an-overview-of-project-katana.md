---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: "プロジェクトの Katana の概要 |Microsoft ドキュメント"
author: howarddierking
description: "ASP.NET フレームワークが経ちましたが 10 年以上にわたっており、プラットフォームには、無数の Web サイトとサービスの開発が有効にします。 Web アプリケーションとしています."
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/30/2013
ms.topic: article
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
ms.technology: 
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 8f28116f88f3cf5143d3d5c9821519d62c4e5452
ms.sourcegitcommit: 6541c8b11001dd617adf5eb04c814cda165070b9
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/07/2017
---
<a name="an-overview-of-project-katana"></a><span data-ttu-id="15cb4-104">プロジェクトの Katana の概要</span><span class="sxs-lookup"><span data-stu-id="15cb4-104">An Overview of Project Katana</span></span>
====================
<span data-ttu-id="15cb4-105">によって[Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="15cb4-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="15cb4-106">ASP.NET フレームワークが経ちましたが 10 年以上にわたっており、プラットフォームには、無数の Web サイトとサービスの開発が有効にします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="15cb4-107">Web アプリケーションの開発戦略がきたように、フレームワークが同じ ASP.NET MVC、ASP.NET Web API などの技術の手順で進化することができました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="15cb4-108">プロジェクトのように Web アプリケーションの開発では、クラウド コンピューティングの世界に次の革新的な手順を受け取り、 [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)柔軟性の高い、移植性をできるように、ASP.NET アプリケーション コンポーネントの基になるセットを提供します。軽量のパフォーマンスの向上: と言い換えると、プロジェクト[Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)クラウドは、ASP.NET アプリケーションを最適化します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>


## <a name="why-katana--why-now"></a><span data-ttu-id="15cb4-109">なぜ Katana – 理由ようになりましたか?</span><span class="sxs-lookup"><span data-stu-id="15cb4-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="15cb4-110">1 つが開発者のフレームワークまたはエンドユーザーの製品を説明するかどうかにかかわらず、することが重要を作成する基になる動機の製品とその一環製品用に作成されたユーザーを知ることが含まれています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="15cb4-111">ASP.NET は、2 人の顧客を念頭に最初に作成されました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="15cb4-112">**顧客の最初のグループには、従来の ASP 開発者がでした。**</span><span class="sxs-lookup"><span data-stu-id="15cb4-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="15cb4-113">時点では、ASP は interweaving マークアップとサーバー側スクリプトによって、データ ドリブン動的な Web サイトおよびアプリケーションを作成するための主要なテクノロジの 1 つでした。</span><span class="sxs-lookup"><span data-stu-id="15cb4-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="15cb4-114">ASP ランタイムでは、基になる HTTP プロトコルと Web サーバーの主要な要素を抽象化され、キャッシュなどの追加へのアクセス サービスのようなセッションおよびアプリケーションの状態管理を提供するオブジェクトのセットをサーバー側スクリプトを指定します。強力ですが、従来の ASP アプリケーションはサイズおよび複雑さするにつれて、管理が容易になりました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="15cb4-115">これは、主に構造ではスクリプト コード、およびマークアップのインターリーブされるコードの重複と組み合わせると環境での不足によるものでした。</span><span class="sxs-lookup"><span data-stu-id="15cb4-115">This was largely due to the lack of structure found in in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="15cb4-116">ASP.NET の課題の一部に対処しながら、classic ASP の長所を活用、するために、サーバー側のプログラミング モデルを維持しながら、.NET Framework のオブジェクト指向言語によって提供されるコードの組織の利点がかかりましたどの classic ASP を開発者が使い慣れたまで増加しました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="15cb4-117">**ASP.NET の対象顧客の 2 番目のグループには、Windows のビジネス アプリケーション開発者がでした。**</span><span class="sxs-lookup"><span data-stu-id="15cb4-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="15cb4-118">従来の ASP 開発者が HTML マークアップと複数の HTML マークアップを生成するコードを記述することに慣れて存在していたとは異なり WinForms 開発者 (前に VB6 開発者) のような日常的にデザイン時のエクスペリエンスのキャンバスと豊富なユーザーを含めることがインターフェイスを制御します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="15cb4-119">ASP.NET – の最初のバージョンとも呼ばれます"Web Forms"提供およびサーバー側のイベント モデルのユーザー インターフェイス コンポーネントと一連の (ViewState) などのインフラストラクチャ機能のようなデザイン時のエクスペリエンスをシームレスな開発者エクスペリエンスを作成するにはクライアントとサーバー側プログラミングします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="15cb4-120">Web フォームは、WinForms の開発者がステートフルなイベント モデルでは、Web のステートレスな性質を効果的に hid です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="15cb4-121">履歴モデルによって発生した問題</span><span class="sxs-lookup"><span data-stu-id="15cb4-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="15cb4-122">**最終的な結果は、完成度の高い、豊富な機能のランタイムと開発者のプログラミング モデルはでした。**</span><span class="sxs-lookup"><span data-stu-id="15cb4-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="15cb4-123">ただし、その機能豊富な機能がいくつかの重要な課題が付属しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="15cb4-124">まず、フレームワークが**モノリシック**System.Web.dll の同じアセンブリ (たとえば、Web フォームのフレームワークで HTTP 核となるオブジェクト) に密に結合されている機能の論理的に個別の単位にします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="15cb4-125">次に、ASP.NET がいることを意図した大規模な .NET Framework の一部として含まれている、**リリースまでの時間は、年およそです。**</span><span class="sxs-lookup"><span data-stu-id="15cb4-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="15cb4-126">これで、ASP.NET のすべての Web 開発を迅速に進化で行われている変更に対応するが困難です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="15cb4-127">最後に、System.Web.dll 自体が特定の Web ホスト オプションに、いくつかの異なる方法で結合された: インターネット インフォメーション サービス (IIS)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="15cb4-128">革新的な手順: ASP.NET MVC と ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="15cb4-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="15cb4-129">Web 開発で多数の変更が行われています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="15cb4-130">大規模なフレームワークではなく、コンポーネントが、一連の小さなに重点を置いて、web アプリケーションを開発中がますますです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="15cb4-131">これらは、リリースされた頻度だけでなく、コンポーネントの数は、これまでに早くに増加してされました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="15cb4-132">Web にペースのままの状態が必要になりますよりも大規模かつ複数の機能豊富ではなくしたがって小さく、分離されたより対象を絞ったを取得するフレームワークは明らかでした、 **ASP.NET チームかかりましたのファミリとして ASP.NET を有効にするいくつかの革新的な手順1 つのフレームワークではなく、プラグ可能な Web コンポーネント**です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="15cb4-133">レールをよく知られているモデル-ビュー-コント ローラー (MVC) デザイン パターン Ruby などの Web 開発フレームワーク感謝の人気の増加は初期の変更の 1 つでした。</span><span class="sxs-lookup"><span data-stu-id="15cb4-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="15cb4-134">このスタイルの Web アプリケーションを構築した開発者は、ASP.NET の初期 selling ポイントのいずれかのマークアップとビジネス ロジックの分離を維持したまま、アプリケーションのマークアップをより細かく制御できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="15cb4-135">このスタイルの Web アプリケーションの開発の需要を満たすためには、Microsoft かかりました自体を配置することによって、今後の改善**帯域外の ASP.NET MVC の開発**(および、.NET Framework に含まれません)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="15cb4-136">ASP.NET MVC は、個別のダウンロードとしてリリースされました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="15cb4-137">これは、エンジニア リング チームに、これまで可能だったされていたよりもより頻繁に更新プログラムを配信する柔軟性を付けました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="15cb4-138">Web アプリケーションの開発のもう 1 つの大きな変化が通信のクライアント側スクリプトから生成されたページのセクションでは動的に初期 static のマークアップをサーバーによって生成される動的な Web ページから、シフト**バックエンドの Web Api と使用AJAX 要求**です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="15cb4-139">このアーキテクチャのシフトに Web Api の増加と ASP.NET Web API フレームワークの開発を促進役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="15cb4-140">ASP.NET MVC の場合は、ASP.NET Web API のリリースには、ASP.NET をモジュール化フレームワークとさらに発展する別の営業案件が用意されています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="15cb4-141">営業案件のエンジニア リング チームが利用し、 **System.Web.dll 内で見つかった core framework 型のいずれかに依存関係があるないような ASP.NET Web API が組み込まれている**です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="15cb4-142">これには、次の 2 つが有効にします。 最初に、そのためのものを ASP.NET Web API は、完全に独立的に進化でした (およびその NuGet 経由で配信されるため、すばやく反復処理を継続してでした)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="15cb4-143">次が存在しなかったので、System.Web.dll に対する外部依存関係とそのため、IIS に依存関係のない、ASP.NET Web API 含まれているカスタムのホスト (たとえばのコンソール アプリケーション、Windows サービスなど) で実行する機能</span><span class="sxs-lookup"><span data-stu-id="15cb4-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="15cb4-144">今後: 機敏フレームワーク</span><span class="sxs-lookup"><span data-stu-id="15cb4-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="15cb4-145">フレームワークを今すぐでした framework コンポーネントを互いから分離することと、NuGet でリリースする、**とは別より迅速に反復処理する**です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="15cb4-146">機能と Web API の自己ホスト機能の柔軟性を抑えようとした開発者にとって非常に魅力的なさらに、証明、**小型、軽量のホスト**各自のサービスです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="15cb4-147">ように魅力的なことがわかりました、実際には、他のフレームワークもこの機能により、あると、新しいチャレンジを表面化これで、各フレームワークを独自のベース アドレスで、独自のホスト プロセスで実行された、(開始、停止するなど) を管理するために必要とは独立しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="15cb4-148">一般に、最新の Web アプリケーションは、静的ファイル サービング、動的なページの生成、Web API、およびより最近リアルタイム-回/プッシュ通知をサポートします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="15cb4-149">これらの各サービスを実行するは別に管理が必要でした単に現実的です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="15cb4-150">さまざまなコンポーネントと、フレームワークのさまざまなアプリケーションを作成する開発者を有効にし、サポートするホスト上でそのアプリケーションを実行する単一のホスティング抽象化が必要だったしました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="15cb4-151">For .NET (OWIN) 開いている Web インターフェイス</span><span class="sxs-lookup"><span data-stu-id="15cb4-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="15cb4-152">によって実現されるメリットにインスパイアされた[ラック](http://rack.github.io/)Ruby のコミュニティでいくつかのメンバー .NET コミュニティ設定 Web サーバーおよびフレームワーク コンポーネント間の抽象化を作成します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="15cb4-153">OWIN 抽象化のための 2 つの設計目標は、単純であったことと、他の framework 型の場合は、最小限の可能な依存関係にかかったでした。</span><span class="sxs-lookup"><span data-stu-id="15cb4-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="15cb4-154">これら 2 つの目標のヘルプを確認してください。</span><span class="sxs-lookup"><span data-stu-id="15cb4-154">These two goals help ensure:</span></span>

- <span data-ttu-id="15cb4-155">新しいコンポーネントをより簡単に開発され、利用可能性があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="15cb4-156">アプリケーションは、ホストと全体の可能性のあるプラットフォームまたはオペレーティング システム間でより簡単に移植する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="15cb4-157">結果の抽象型は、次の 2 つの主要な要素で構成されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="15cb4-158">最初は、環境のディクショナリです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-158">The first is the environment dictionary.</span></span> <span data-ttu-id="15cb4-159">このデータ構造体は、すべての HTTP 要求と応答、さらに、関連するサーバーの状態を処理するために必要な状態を格納します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="15cb4-160">環境のディクショナリの定義は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="15cb4-161">OWIN と互換性のある Web サーバーは、本文ストリームとの HTTP 要求と応答ヘッダーのコレクションなどのデータを使用して環境ディクショナリを作成します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="15cb4-162">アプリケーションまたはフレームワーク コンポーネントを作成または追加の値のディクショナリを更新し、応答のボディ ストリームへの書き込みの役割です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="15cb4-163">環境のディクショナリの種類を指定するだけでなく、OWIN 仕様はコア ディクショナリのキー値のペアのリストを定義します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="15cb4-164">たとえば、次の表は、HTTP 要求に対する必要なディクショナリのキーを示しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="15cb4-165">キー名</span><span class="sxs-lookup"><span data-stu-id="15cb4-165">Key Name</span></span> | <span data-ttu-id="15cb4-166">値の説明</span><span class="sxs-lookup"><span data-stu-id="15cb4-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="15cb4-167">存在する場合、要求本文のストリーム。</span><span class="sxs-lookup"><span data-stu-id="15cb4-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="15cb4-168">要求本文が存在しない場合、Stream.Null はプレース ホルダーとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="15cb4-169">参照してください[要求本文](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="15cb4-170">`IDictionary<string, string[]>`要求ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="15cb4-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="15cb4-171">参照してください[ヘッダー](http://owin.org/html/owin.html#3-3-headers)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="15cb4-172">A`string`要求の HTTP 要求メソッドを含む (例: `"GET"`、 `"POST"`)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="15cb4-173">A`string`要求パスを含むです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-173">A `string` containing the request path.</span></span> <span data-ttu-id="15cb4-174">アプリケーションのデリゲートの「ルート」からの相対パスでなければなりません参照してください[パス](http://owin.org/html/owin.html#5-3-paths)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="15cb4-175">A`string`を参照してください。 アプリケーション デリゲートの"root"に対応する要求パスの部分を含む[パス](http://owin.org/html/owin.html#5-3-paths)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="15cb4-176">A`string`プロトコル名とバージョンを含む (例:`"HTTP/1.0"`または`"HTTP/1.1"`)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="15cb4-177">A`string`クエリ文字列の部分を格納せず、先頭は、HTTP 要求の URI、"?"(例: `"foo=bar&baz=quux"`)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="15cb4-178">値は、空の文字列を指定できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="15cb4-179">A`string`要求で使用される URI スキームを格納している (たとえば、 `"http"`、 `"https"`); を参照してください[URI スキーム](http://owin.org/html/owin.html#5-1-uri-scheme)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="15cb4-180">OWIN の 2 番目のキー要素は、アプリケーション デリゲートです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="15cb4-181">これは、OWIN アプリケーションのすべてのコンポーネント間の基本インターフェイスとして機能する関数のシグネチャです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="15cb4-182">アプリケーションのデリゲートの定義は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="15cb4-183">アプリケーション デリゲートは、Func デリゲート型、関数が入力として環境ディクショナリを受け入れるし、タスクを返しますの実装だけです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="15cb4-184">この設計では、開発者にいくつかの影響があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="15cb4-185">OWIN コンポーネントを記述するために必要な種類の依存関係の数が非常に少ないがあります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="15cb4-186">開発者に OWIN のユーザー補助機能が大幅に増加します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="15cb4-187">非同期デザインでは、その処理がコンピューティング リソース、特に複数の I/O 処理を要する操作での効率的な抽象化を使用できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="15cb4-188">アプリケーションのデリゲートは、実行のアトミック単位、OWIN コンポーネントを簡単にチェーンできるため、デリゲートのパラメーターとして、環境のディクショナリが実行される、ため組み合わせて複雑な HTTP のパイプライン処理を作成します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="15cb4-189">実装の観点から、OWIN は仕様 ([http://owin.org/html/owin.html](http://owin.org/html/owin.html))。</span><span class="sxs-lookup"><span data-stu-id="15cb4-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="15cb4-190">その目的は次の Web フレームワークが Web フレームワークと Web サーバーの対話方法に関する仕様ではなくしないでください。</span><span class="sxs-lookup"><span data-stu-id="15cb4-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="15cb4-191">調査した場合[OWIN](http://owin.org/)または[Katana](https://github.com/aspnet/AspNetKatana/wiki)もお気付き、 [Owin NuGet パッケージ](http://nuget.org/packages/Owin)Owin.dll とします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="15cb4-192">このライブラリには、1 つのインターフェイスが含まれています。 [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)、形式化しで説明、スタートアップ シーケンスを体系を[セクション 4](http://owin.org/html/owin.html#4-application-startup) OWIN 仕様のです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="15cb4-193">OWIN サーバーを構築するためには必要ありません、 [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)インターフェイスは、具象参照ポイントを提供し、Katana プロジェクト コンポーネントによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="15cb4-194">プロジェクトの Katana</span><span class="sxs-lookup"><span data-stu-id="15cb4-194">Project Katana</span></span>

<span data-ttu-id="15cb4-195">一方両方、 [OWIN](http://owin.org/html/owin.html)仕様と*Owin.dll*が所有するコミュニティやコミュニティのオープン ソースの作業を実行、 [Katana](https://github.com/aspnet/AspNetKatana/wiki)プロジェクトは、OWIN のセットを表しますまだオープン ソースの中に構築され、マイクロソフトによってリリースされたコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="15cb4-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="15cb4-196">これらのコンポーネントなどの認証コンポーネントやフレームワークへのバインドなどの機能のコンポーネントだけでなく、ホストやサーバーなどのインフラストラクチャ コンポーネント[SignalR](../../../signalr/index.md)と[ASP.NET WebAPI](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="15cb4-197">プロジェクトには、次の 3 つの高レベル目標があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="15cb4-198">**ポータブル**– コンポーネントは、利用可能になる新しいコンポーネントを簡単に置換できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="15cb4-199">これには、すべての種類サーバーおよびホストするためにフレームワークからのコンポーネントにはが含まれます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="15cb4-200">この目標のつまり Microsoft フレームワークが実際にサード パーティ製のサーバーおよびホストで実行中に、サード パーティ製フレームワークがマイクロソフトのサーバーで実行シームレスにことです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="15cb4-201">**モジュール/柔軟な**–、無数の既定で有効にする機能を含む多くのフレームワークとは異なり、Katana プロジェクト コンポーネントを小規模でフォーカスのある、経由で制御を行うコンポーネントを決定するとき、アプリケーション開発者にする必要があります自分のアプリケーションで使用します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="15cb4-202">**ライトウェイト/パフォーマンスの高い/スケーラブルな**– フレームワークの従来の概念の小さなのセットに分割することによりフォーカスが明示的に追加、アプリケーション開発者によってより少ない計算結果として得られる Katana アプリケーションを使用するコンポーネントリソース、およびその結果、他の種類のサーバー、およびフレームワークのよりも多くの負荷を処理します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="15cb4-203">アプリケーションの要件は、基になるインフラストラクチャからより多くの機能を要求、ようものは、OWIN パイプラインに追加することができますが、アプリケーション開発者は、部分、明示的な意思決定をする必要があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="15cb4-204">さらに、下位レベルのコンポーネントの代替性は、利用可能になる、新しい高パフォーマンス サーバーにシームレスに導入できますそれらのアプリケーションを分断することがなく、OWIN アプリケーションのパフォーマンスを向上させるためを意味します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="15cb4-205">Katana コンポーネントの概要</span><span class="sxs-lookup"><span data-stu-id="15cb4-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="15cb4-206">初めて導入された、1 つの要素、 [Node.js](http://nodejs.org/)すぐにユーザーの関心が集まりましたフレームワークが使用する 1 つでしたを作成および実行 Web サーバー、わかりやすくするためです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="15cb4-207">Katana 目標が light のフレーム化される場合[Node.js](http://nodejs.org/)、いずれかの可能性がありますまとめたり Katana に多くのメリットがもたらされているを言うことにより[Node.js](http://nodejs.org/) (およびそのようなフレームワーク) スローする開発者を強制することがなくASP.NET Web アプリケーションの開発について知ってすべてのものです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="15cb4-208">このステートメントは true を保持するには、Katana プロジェクトの使用を開始する必要があります性質を持つ実に単純な[Node.js](http://nodejs.org/)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="15cb4-209">"Hello World!"を作成します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-209">Creating "Hello World!"</span></span>

<span data-ttu-id="15cb4-210">JavaScript および .NET の開発の大きな違いの 1 つは、(または存在しない) のコンパイラです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="15cb4-211">そのため、単純な Katana サーバーの開始点は、Visual Studio プロジェクトです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="15cb4-212">ただし、プロジェクトの種類の中で最も最小限に抑えて始めることができます: 空の ASP.NET Web アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="15cb4-213">次をインストール、 [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet パッケージをプロジェクトにします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="15cb4-214">このパッケージは、ASP.NET の要求パイプラインで実行する OWIN サーバーを提供します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="15cb4-215">[NuGet ギャラリー](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)し、次のコマンドを使用して、Visual Studio パッケージ マネージャー ダイアログまたはパッケージ マネージャー コンソールを使用してインストールすることができます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="15cb4-216">インストール、`Microsoft.Owin.Host.SystemWeb`パッケージの依存関係として、いくつかの他のパッケージでインストールされます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="15cb4-217">これらの依存関係の 1 つは`Microsoft.Owin`ライブラリがいくつかのヘルパー型と OWIN アプリケーションを開発するためのメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="15cb4-218">次の"hello world"サーバーを簡単に作成、それらの型を使用できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="15cb4-219">この非常に単純な Web サーバーは、Visual Studio を使用して実行するようになりましたことができます**f5 キーを押して**コマンドし、デバッグを完全にサポートが含まれています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="15cb4-220">ホストの切り替え</span><span class="sxs-lookup"><span data-stu-id="15cb4-220">Switching hosts</span></span>

<span data-ttu-id="15cb4-221">既定では、"hello world"の前の例は、IIS のコンテキストで System.Web を使用して ASP.NET 要求パイプラインで実行されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="15cb4-222">これを単独で追加できます膨大な価値に柔軟性と管理機能を OWIN パイプラインの構成可能性と IIS の成熟度の全体的なメリットを享受することができます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="15cb4-223">ただし、IIS が提供する利点は必要ありませんより小さくより軽量のホストは、ある場合があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="15cb4-224">必要な情報、その後、IIS、System.Web の外部で単純な Web サーバーを実行しますか。</span><span class="sxs-lookup"><span data-stu-id="15cb4-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="15cb4-225">移植性の目標を示すためには、Web サーバーのホストとコマンド ライン ホストから移動、単に新しいサーバーとホストの依存関係をプロジェクトの出力フォルダーに追加し、ホストを起動が必要です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="15cb4-226">この例ではという Katana ホストで、Web サーバーをホストお`OwinHost.exe`Katana HttpListener ベースのサーバーを使用しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="15cb4-227">同様に、他の Katana コンポーネントにこれらは獲得されます、次のコマンドを使用して NuGet から。</span><span class="sxs-lookup"><span data-stu-id="15cb4-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="15cb4-228">コマンドラインからプロジェクト ルート フォルダーに移動したりできます単に実行する、 `OwinHost.exe` (がインストールされている、それぞれの NuGet パッケージの [ツール] フォルダー内)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="15cb4-229">既定では、`OwinHost.exe`が HttpListener ベースのサーバーを探すように構成されているため、追加の構成は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="15cb4-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="15cb4-230">Web ブラウザー内を移動する`http://localhost:5000/`コンソールから実行されているアプリケーションを示しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="15cb4-231">Katana アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="15cb4-231">Katana Architecture</span></span>

 <span data-ttu-id="15cb4-232">Katana コンポーネントのアーキテクチャは、次のようにアプリケーションを次の 4 つの論理層を分割:*ホスト、サーバー、ミドルウェア、*と*アプリケーション*です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="15cb4-233">コンポーネントのアーキテクチャは、これらのレイヤーの実装に簡単にで置換できる、多くの場合、アプリケーションの再コンパイルせずこのような方法で考慮されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="15cb4-234">ホスト</span><span class="sxs-lookup"><span data-stu-id="15cb4-234">Host</span></span>

 <span data-ttu-id="15cb4-235">ホストが担当します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-235">The host is responsible for:</span></span>

- <span data-ttu-id="15cb4-236">基になるプロセスを管理します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-236">Managing the underlying process.</span></span>
- <span data-ttu-id="15cb4-237">サーバーの選択や、どの要求を OWIN パイプラインの構築するためのワークフローの調整が処理されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

 <span data-ttu-id="15cb4-238">現時点では、Katana ベース アプリケーション用の 3 つの主要なホスティング オプションがあります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="15cb4-239">**IIS/ASP.NET**: 標準の HttpModule と HttpHandler 型を使用して、OWIN パイプラインで実行できます IIS、ASP.NET 要求フローの一部として。</span><span class="sxs-lookup"><span data-stu-id="15cb4-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="15cb4-240">Web アプリケーション プロジェクトに Microsoft.AspNet.Host.SystemWeb NuGet パッケージをインストールすることで、ASP.NET ホストのサポートが有効です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="15cb4-241">さらに、IIS は、ホストとサーバーの両方として動作するため OWIN サーバー/ホスト上の違いは結び付いて SystemWeb ホストを使用する場合、開発者によって、代替サーバー実装置き換えることはできませんので、この NuGet パッケージにします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="15cb4-242">**カスタム ホスト**:「Katana コンポーネント スイートことができます開発者独自のカスタム プロセスでアプリケーションをホストするコンソール アプリケーション、Windows サービスなどであるどうか。この機能は、Web API によって提供される自己ホストの機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="15cb4-243">次の例は、Web API のコードのカスタム ホストを示しています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="15cb4-244">自己ホスト アプリケーションのセットアップを Katana は似ています。</span><span class="sxs-lookup"><span data-stu-id="15cb4-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="15cb4-245">Web API と Katana の自己ホスト例の 1 つの大きな違いは、Web API の構成コードが Katana 自己ホスト例から不足していることです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="15cb4-246">移植性と構成可能性の両方を有効にするためには、Katana は、要求処理パイプラインを構成するコードからサーバーを起動するコードを分離します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="15cb4-247">Web API を構成し、スタートアップ時に、また WebApplication.Start の型パラメーターとして指定されたクラスに含まれているコード。</span><span class="sxs-lookup"><span data-stu-id="15cb4-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="15cb4-248">スタートアップ クラスは、記事の後半で詳しく説明されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="15cb4-249">ただし、コードは、自己ホストのプロセスが ASP.NET Web API の自己ホスト アプリケーションで現在使用する場合のコードに非常に似て Katana を開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="15cb4-250">**OwinHost.exe**: Katana Web アプリケーションを実行するカスタム プロセスを記述する必要があるいくつかが、多くは方がより適して単にサーバーを起動し、そのアプリケーションを実行できる構成済みの実行可能ファイルを起動します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="15cb4-251">Katana コンポーネント スイートには、このシナリオでは、`OwinHost.exe`です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="15cb4-252">実行からプロジェクトのルート ディレクトリ内で、この実行可能ファイルは (サーバーを使用して、HttpListener 既定で) サーバーを起動し、規則を使用して検索して、ユーザーのスタートアップ クラスを実行します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="15cb4-253">詳細な制御、実行可能ファイルは、追加のコマンド ライン パラメーターの数を提供します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="15cb4-254">サーバー</span><span class="sxs-lookup"><span data-stu-id="15cb4-254">Server</span></span>

 <span data-ttu-id="15cb4-255">起動して、アプリケーションが実行される、サーバーの責任において、プロセスを維持するため、ホストは、中にネットワーク ソケットを開き、要求をリッスンし、OWIN コンポーネントのパイプラインを使用して送信するユーザーが指定して、(としてします。既にお気付き、このパイプラインは、アプリケーション開発者のスタートアップ クラスで指定)。</span><span class="sxs-lookup"><span data-stu-id="15cb4-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="15cb4-256">現在、Katana プロジェクトには、次の 2 つのサーバーの実装が含まれます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="15cb4-257">**Microsoft.Owin.Host.SystemWeb**: 既に触れましたが、IIS と ASP.NET パイプライン連携では、ホストと、サーバーの両方として機能します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="15cb4-258">そのため、選択するときにこのホスト オプション、IIS プロセスのアクティブ化などのホスト レベルの懸案事項の管理し、両方 HTTP 要求をリッスンします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="15cb4-259">ASP.NET Web アプリケーションの場合は、ASP.NET パイプラインに、要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="15cb4-260">Katana SystemWeb ホストは、HTTP パイプラインを通過し、ユーザー指定の OWIN パイプラインを使用して送信要求をインターセプトするには、ASP.NET HttpModule と HttpHandler を登録します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="15cb4-261">**Microsoft.Owin.Host.HttpListener**: この Katana サーバーで、.NET Framework の HttpListener クラスを使用して、ソケットを開くし、開発者が指定の OWIN パイプラインに要求を送信する名前が示すとおりです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="15cb4-262">これは、現在、Katana 自己ホスト API と OwinHost.exe の両方の既定のサーバーの選択です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="15cb4-263">ミドルウェア/フレームワーク</span><span class="sxs-lookup"><span data-stu-id="15cb4-263">Middleware/framework</span></span>

 <span data-ttu-id="15cb4-264">前述のように、サーバーが、クライアントからの要求を受け入れる場合は、開発者のスタートアップ コードで指定された OWIN コンポーネントのパイプラインを介して渡すことを担当します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="15cb4-265">これらのパイプライン コンポーネントは、ミドルウェアと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="15cb4-266">非常に基本的なレベルで OWIN ミドルウェア コンポーネントは呼び出しができるように、OWIN アプリケーションのデリゲートを実装するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="15cb4-267">ただし、開発とミドルウェア コンポーネントの構成を簡略化するために Katana、いくつかの規則とヘルパー型のサポート ミドルウェア コンポーネントします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="15cb4-268">これらの最も一般的な方法は、`OwinMiddleware`クラスです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="15cb4-269">このクラスを使用して構築されたカスタム ミドルウェア コンポーネントは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="15cb4-270">このクラスから派生`OwinMiddleware`、その引数の 1 つとして、パイプラインの次のミドルウェアのインスタンスを受け取り、基底コンス トラクターに渡しますをコンス トラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="15cb4-271">ミドルウェアの構成に使用する追加の引数は、次のミドルウェア パラメーターは、後もコンス トラクターのパラメーターとして宣言されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="15cb4-272">ミドルウェアが実行される、実行時に、オーバーライドされたを介して`Invoke`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="15cb4-273">このメソッドは、型の 1 つの引数を受け取ります`OwinContext`です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="15cb4-274">このコンテキスト オブジェクトは、によって提供される、 `Microsoft.Owin` NuGet パッケージの前に説明したし、いくつかの追加のヘルパー型と共に、要求、応答、および環境の辞書に厳密に型指定されたアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="15cb4-275">ミドルウェア クラスできます簡単にパイプラインに追加する、OWIN アプリケーションのスタートアップ コードで次のように。</span><span class="sxs-lookup"><span data-stu-id="15cb4-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="15cb4-276">ミドルウェア コンポーネントの単純なものからの複雑さの範囲は Katana インフラストラクチャは、単に OWIN ミドルウェア コンポーネントのパイプラインを構築し、単にコンポーネントをパイプラインに参加するアプリケーションのデリゲートをサポートする必要があるため、ASP.NET Web API などの全体のフレームワークにロガーまたは[SignalR](../../../signalr/index.md)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="15cb4-277">たとえば、前の OWIN パイプラインへの ASP.NET Web API の追加には、次のスタートアップ コードを追加することが必要です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="15cb4-278">Katana インフラストラクチャでは、構成方法の IAppBuilder オブジェクトに追加された順序に基づいてミドルウェア コンポーネントのパイプラインを構築します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="15cb4-279">例では、次に、LoggerMiddleware 扱える最終的にそれらの要求が処理される方法に関係なく、パイプラインを通過するすべての要求。</span><span class="sxs-lookup"><span data-stu-id="15cb4-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="15cb4-280">これは、ミドルウェア コンポーネント (例: 認証コンポーネント) が複数のコンポーネントとフレームワーク (ASP.NET Web API、SignalR、および静的なファイル サーバーなど) を含むパイプラインに対する要求を処理できる強力なシナリオを実現できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="15cb4-281">アプリケーション</span><span class="sxs-lookup"><span data-stu-id="15cb4-281">Applications</span></span>

<span data-ttu-id="15cb4-282">前の例で示すように OWIN と Katana プロジェクト見なす必要がありますいないのアプリケーション プログラミング モデルとサーバーとホスト インフラストラクチャからフレームワークを分離するための抽象化としてではなくが、新しいアプリケーション プログラミング モデルとして。</span><span class="sxs-lookup"><span data-stu-id="15cb4-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="15cb4-283">たとえば、Web API アプリケーションを構築するときに開発者 framework し続けます Katana プロジェクトからコンポーネントを使用する OWIN パイプラインでアプリケーションを実行するかどうかに関係なく、ASP.NET Web API フレームワークを使用します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="15cb4-284">OWIN に関連するコードがアプリケーション開発者に表示される 1 つの場所にアプリケーションのスタートアップ コードがなる場合は、開発者が、OWIN パイプラインを構成します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="15cb4-285">スタートアップ コードでは、開発者は、UseXx ステートメントは、受信要求を処理するミドルウェア コンポーネントごとに 1 つの系列を登録します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="15cb4-286">このエクスペリエンスは、現在の System.Web 世界で HTTP モジュールを登録すると同じ効果があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="15cb4-287">通常より大きな framework ミドルウェア、ASP.NET Web API などまたは[SignalR](../../../signalr/index.md)パイプラインの最後に登録されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="15cb4-288">認証またはキャッシュなどの広範囲にミドルウェア コンポーネントは通常、登録、パイプラインの先頭までの範囲のフレームワークと、パイプラインで後で登録されているコンポーネントのすべての要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="15cb4-289">この分離ミドルウェア コンポーネントの基になるインフラストラクチャ コンポーネントとの相互からは、全体的なシステムを使ったまま、安定したことを確保しながら、さまざまな速度で進化するコンポーネントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="15cb4-290">コンポーネント – NuGet パッケージの管理</span><span class="sxs-lookup"><span data-stu-id="15cb4-290">Components – NuGet Packages</span></span>

<span data-ttu-id="15cb4-291">現在のライブラリやフレームワークの多くのように Katana プロジェクト コンポーネントは、一連の NuGet パッケージとして配布されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="15cb4-292">今後のバージョン 2.0 の Katana パッケージの依存関係グラフ次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="15cb4-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="15cb4-293">(画像が拡大表示をクリックします。)</span><span class="sxs-lookup"><span data-stu-id="15cb4-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="15cb4-294">Katana プロジェクトのほぼすべてのパッケージによって異なります、直接または間接的に Owin パッケージ。</span><span class="sxs-lookup"><span data-stu-id="15cb4-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="15cb4-295">OWIN 仕様のセクション 4 で説明したアプリケーションの起動処理の具象実装を提供する IAppBuilder インターフェイスが含まれるパッケージは、このことに留意することがあります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="15cb4-296">さらに、パッケージの多くは、HTTP 要求と応答を操作するためのヘルパー型のセットを提供する Microsoft.Owin に依存します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="15cb4-297">パッケージの残りの部分は、ホスティング インフラストラクチャ パッケージ (サーバーまたはホスト) またはミドルウェアのいずれかとして分類されることができます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="15cb4-298">パッケージと Katana プロジェクト外部の依存関係がオレンジ色で表示されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="15cb4-299">Katana 2.0 のホスティング インフラストラクチャ、SystemWeb と HttpListener ベースのサーバー、OwinHost.exe を使用する OWIN アプリケーションを実行するため、OwinHost パッケージ、および自己ホスト型の OWIN アプリケーションの Microsoft.Owin.Hosting パッケージ、カスタム ホスト (例: コンソール アプリケーション、Windows サービスなど)</span><span class="sxs-lookup"><span data-stu-id="15cb4-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="15cb4-300">Katana 2.0 のミドルウェア コンポーネント、主に注目している異なる認証方法を提供することにします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="15cb4-301">開始し、エラー ページのサポートを有効な診断に 1 つの他のミドルウェア コンポーネントを説明します。</span><span class="sxs-lookup"><span data-stu-id="15cb4-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="15cb4-302">OWIN ホスティング事実上の抽象化に増大すると、Microsoft とサード パーティによって開発されたもの両方ミドルウェア コンポーネントのエコシステムも数に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="15cb4-303">まとめ</span><span class="sxs-lookup"><span data-stu-id="15cb4-303">Conclusion</span></span>

 <span data-ttu-id="15cb4-304">先頭から Katana プロジェクトの目標を作成し、それによってさらに別の Web フレームワークを学習する開発者を強制されていません。</span><span class="sxs-lookup"><span data-stu-id="15cb4-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="15cb4-305">代わりに、目標は、以前よりも考えられる複数の選択肢を .NET Web アプリケーションの開発者に提供する抽象化を行うされました。</span><span class="sxs-lookup"><span data-stu-id="15cb4-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="15cb4-306">通常 Web アプリケーションのスタックの置き換え可能コンポーネントのセットに論理層を分割は、Katana プロジェクトは、どのような比率にはそれらのコンポーネントが合理的に向上させるためにスタック全体でコンポーネントを使用できます。</span><span class="sxs-lookup"><span data-stu-id="15cb4-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="15cb4-307">単純な OWIN 抽象化の周りのすべてのコンポーネントを構築するには、Katana ことによって、フレームワーク上に構築されたアプリケーションをさまざまな別のサーバーとホスト間で移植可能にします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="15cb4-308">開発者は、スタックのコントロールに配置すること、Katana を行うことにより、開発者が軽量な方法に関する最終的な選択を行うことまたは機能が豊富でどのように自分の Web スタックがする必要があります。</span><span class="sxs-lookup"><span data-stu-id="15cb4-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  
  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="15cb4-309">Katana の詳細については</span><span class="sxs-lookup"><span data-stu-id="15cb4-309">For more information about Katana</span></span>

- <span data-ttu-id="15cb4-310">GitHub の Katana プロジェクト: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/)です。</span><span class="sxs-lookup"><span data-stu-id="15cb4-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="15cb4-311">ビデオ: [Katana プロジェクト - ASP.NET の OWIN](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)、Howard Dierking でします。</span><span class="sxs-lookup"><span data-stu-id="15cb4-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="15cb4-312">謝辞</span><span class="sxs-lookup"><span data-stu-id="15cb4-312">Acknowledgements</span></span>

- <span data-ttu-id="15cb4-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT) ) Rick は Microsoft Azure と MVC に焦点を当てたのスキルの限られたプログラミング ライター。</span><span class="sxs-lookup"><span data-stu-id="15cb4-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="15cb4-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [ @shanselman ](https://twitter.com/shanselman) )</span><span class="sxs-lookup"><span data-stu-id="15cb4-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="15cb4-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [ @jongalloway ](https://twitter.com/jongalloway) )</span><span class="sxs-lookup"><span data-stu-id="15cb4-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>
