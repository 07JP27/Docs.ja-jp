---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: 作成する単体テストのイテレーション 5 – (c#) |Microsoft ドキュメント
author: microsoft
description: 5 番目のイテレーションでおやすく、アプリケーションを維持し、単体テストを追加して変更できます。 データ モデル クラスを模擬表示し、o の単体テストをビルドしています.
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/20/2009
ms.topic: article
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 7a61b5791a40088df9d27f7b1bd37df1831ef22b
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2018
---
<a name="iteration-5--create-unit-tests-c"></a>イテレーション #5-単体テストを作成する (c#)
====================
によって[Microsoft](https://github.com/microsoft)

[コードをダウンロードします。](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> 5 番目のイテレーションでおやすく、アプリケーションを維持し、単体テストを追加して変更できます。 データ モデル クラスを模擬表示し、コント ローラーと検証ロジックの単体テストをビルドします。


## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>連絡先管理 ASP.NET MVC アプリケーション (c#) の構築

この一連のチュートリアルは、連絡先管理アプリケーション全体が開始されてから完了するを構築します。 お問い合わせのマネージャー アプリケーションでは、人のユーザーの一覧については使用すると、連絡先情報の名前、電話番号、電子メール アドレスを格納できます。

私たちは、複数のイテレーションにおける、アプリケーションを構築します。 各イテレーションで、アプリケーション、徐々 に向上します。 この複数のイテレーション アプローチの目的は、各変更の理由を理解するためです。

- イテレーション 1 には、アプリケーションを作成します。 最初のイテレーションでお連絡先のマネージャー最も簡単な方法で可能なを作成します。 基本的なデータベース操作のサポートを追加します: 作成、読み取り、更新、および削除 (CRUD)。

- イテレーション 2 では、素敵に見えるアプリケーションを作成します。 このイテレーションで、アプリケーションの外観を向上させる、既定の ASP.NET MVC ビュー マスター ページを変更し、カスケード スタイル シート。

- イテレーション 3 - フォーム検証を追加します。 3 番目のイテレーションは、基本フォーム検証を追加します。 おは人が必要なフォームのフィールドを完了しなくても、フォームを送信することを防ぐ。 私たちも電子メール アドレスと電話番号を検証します。

- 4: イテレーションは、疎結合アプリケーションを作成します。 この 3 番目のイテレーションで利用の保守し、連絡先のマネージャー アプリケーションの変更を容易にできるようにするソフトウェア設計パターンをいくつかのです。 たとえば、リポジトリ パターンと依存関係の挿入のパターンを使用するようにアプリケーションをリファクターします。

- イテレーション #5 - 単体テストを作成します。 5 番目のイテレーションでおやすく、アプリケーションを維持し、単体テストを追加して変更できます。 データ モデル クラスを模擬表示し、コント ローラーと検証ロジックの単体テストをビルドします。

- イテレーション 6 - テスト駆動開発を使用します。 この 6 番目のイテレーションでは、アプリケーションに新しい機能を追加おには、まず単体テストを記述し、単体テストに対してコードを記述します。 このイテレーションは、連絡先グループを追加します。

- イテレーション #7 - Ajax 機能を追加します。 7 番目のイテレーションでお、応答性およびパフォーマンスの向上、アプリケーションの Ajax のサポートを追加することで。


## <a name="this-iteration"></a>このイテレーション

連絡先のマネージャー アプリケーションの前回のイテレーションより緩やかに結合されアプリケーションにリファクタリングします。 ここには、個別のコント ローラー、サービス、およびリポジトリ レイヤーへのアプリケーションが区切られます。 各レイヤーは、インターフェイスを通じて下のレイヤーと通信します。

アプリケーションを容易に保守して変更するアプリケーションをリファクタリングします。 たとえば、新しいデータ アクセス テクノロジを使用する必要がある場合、は、リポジトリ層をコント ローラーまたはサービス層に触れることがなくに変更できます単におです。 疎結合、連絡先のマネージャーをすることによりアプリケーションを作成を変更する回復性が向上しています。

連絡先のマネージャー アプリケーションに新しい機能を追加するとどうなりますか。 または、バグ修正とどうなりますか。 コードの記述、残念ながら、実績のある情報源に新しいバグが生じるリスクを作成するコードをタッチするときに、です。

たとえば、問題の 1 日、上司可能性があります求められる Contact Manager に新しい機能を追加します。 連絡先グループのサポートを追加する必要があります。 友人やビジネスなどのグループに、連絡先を整理するユーザーを有効にする必要があります。

この新しい機能を実装するために、連絡先のマネージャー アプリケーションのすべての 3 つの層を変更する必要があります。 コント ローラー、サービス層、およびリポジトリに新しい機能を追加する必要があります。 コードの変更を開始するとすぐに、前に動作していた機能を損なう可能性があります。

良いことが前回のイテレーションで行ったように、アプリケーションを別のレイヤーをリファクタリングします。 これにより、アプリケーションの残りの部分に触れることがなく、レイヤー全体に変更を加えるため良いことでした。 ただし、レイヤー内のコードを容易に保守して変更する場合は、コードの単体テストを作成する必要があります。

使用する単位をテスト コードの個別の単位。 これらの単位のコードは、全体のアプリケーション層よりも小さいです。 通常、コード内の特定のメソッドが期待どおりに動作するかどうかを確認するのに単体テストを使用します。 たとえば、ContactManagerService クラスによって公開される CreateContact() メソッドの単体テストを作成します。

単なるアプリケーション作業に単体テストでは、安全策と同様にします。 アプリケーションのコードを変更するたびに、一連の変更が既存の機能を中断するかどうかを確認する単体テストを実行できます。 単体テスト、コードを容易に変更しても安全です。 単体テストのすべてのコード、アプリケーションで回復力を高めるを変更します。

このイテレーションでは、単体テストを追加お、連絡先のマネージャー アプリケーションにします。 こうすれば、次のイテレーションでお連絡先グループに追加できますアプリケーション既存の機能の重大な気にせずします。

> [!NOTE] 
> 
> さまざまな単体テスト フレームワーク NUnit、xUnit.net、MbUnit などがあります。 このチュートリアルでは、単体テスト フレームワークが Visual Studio に含まれているを使用します。 ただし、同じくらい簡単に使用できますのこれらの代替フレームワークのいずれか。


## <a name="what-gets-tested"></a>テストのものを取得

理想の世界では、すべてのコードは単体テストでカバーが。 理想の世界では、完全な安全策があります。 アプリケーションのコードの任意の行を変更し、把握、すぐに、単体テストを実行することによって、変更が既存の機能を中断するかどうかをすることができます。

ただし、完全な世界でライブ t をありません。 実際には、単体テストを記述する場合は、ビジネス ロジック (たとえば、検証ロジック) のテストの記述に集中します。 具体的には、する*しない*データの単体テストを記述ロジックや、ビュー ロジックにアクセスします。

便利ですが、非常に短時間単体テストで実行する必要があります。 アプリケーションの単体テストの数百台 (または何千も) を蓄積することが簡単にします。 単体テストを実行する時間がかかる場合は、それらの実行を回避します。 つまり、実行時間の長い単体テストは、毎日コーディング目的の役に立たなくです。

このため、通常書きデータベースとやり取りするコードの単体テストをします。 ライブ データベースに対して何百もの単体テストを実行しているに遅くなりすぎてできなくなります。 代わりに、データベースを模擬表示し、(触れ以下のデータベースをモック) モック データベースと対話するコードを記述します。

ような理由から、通常書きビューの単体テストをします。 ビューをテストするのには、web サーバーをスピンアップする必要があります。 Web サーバーをスピンアップは比較的低速なプロセスなので、ビューの単体テストの作成はお勧めできません。

ビューには、複雑なロジックが含まれている場合にヘルパー メソッドのロジックを移動を検討してください。 スピン、web サーバーを使用せずに実行するヘルパー メソッドの単体テストを記述することができます。

> [!NOTE] 
> 
> データ アクセス ロジックに対するテストを作成または表示ロジックがないことをお勧め単体テストを記述する場合、中には、関数型構築または統合テスト時にこれらのテストが非常に重要なできます。


> [!NOTE] 
> 
> ASP.NET MVC は、Web フォーム ビュー エンジンです。 Web フォーム ビュー エンジンは、web サーバーに依存するその他のビュー エンジンがあります。


## <a name="using-a-mock-object-framework"></a>モック オブジェクト フレームワークを使用します。

単体テストを作成するときにほとんどの場合、モック オブジェクト フレームワークを活用する必要があります。 モック オブジェクト フレームワークでは、アプリケーションでモックとスタブ クラスを作成することができます。

たとえば、モック オブジェクト フレームワークを使用すると、モック リポジトリ クラスのバージョンを生成します。 このように、単体テストで、実際のリポジトリ クラスの代わりにもモック リポジトリ クラスを使用できます。 モック リポジトリを使用するには、単体テストを実行するときにデータベース コードの実行を回避することができます。

Visual Studio では、モック オブジェクト フレームワークは含まれません。 ただし、いくつかの商用およびオープン ソース モック オブジェクト フレームワーク、.NET framework を使用できます。

1. Moq - このフレームワークはオープン ソース BSD ライセンスの下で使用できます。 Moq をダウンロードする[ https://code.google.com/p/moq/](https://code.google.com/p/moq/)です。
2. Rhino Mocks - このフレームワークは、オープン ソース BSD ライセンスで使用できます。 Rhino が Mocks からダウンロードできます[ http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)です。
3. Typemock Isolator - これは、商用のフレームワークです。 評価版をダウンロードする[ http://www.typemock.com/](http://www.typemock.com/)です。

このチュートリアルでは Moq を使用することにしました。 ただし、同じくらい簡単に使用する Rhino Mocks したり、連絡先のマネージャー アプリケーションのオブジェクトをモックを作成する Typemock Isolator です。

Moq を使用することができます、前に、次の手順を完了する必要があります。

1. である必要があります。
2. ダウンロードを解凍する前に、ファイルを右クリックしてボタンをクリックすることを確認してください**ブロックを解除する**(図 1 を参照してください)。
3. ダウンロードを解凍します。
4. ContactManager.Tests プロジェクトの [参照] フォルダーを右クリックして Moq アセンブリへの参照を追加**参照の追加**です。 参照 タブで、Moq を解凍したフォルダーに移動し、Moq.dll アセンブリを選択します。 クリックして、 **OK**ボタンをクリックします。
5. これらの手順を実行した後、[参照] フォルダーは図 2 のようになります。


[![ブロック解除 Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)

**図 01**: ブロック解除 Moq ([フルサイズのイメージを表示するをクリックして](iteration-5-create-unit-tests-cs/_static/image2.png))


[![Moq を追加した後の参照](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)

**図 02**: Moq を追加した後の参照 ([フルサイズのイメージを表示するをクリックして](iteration-5-create-unit-tests-cs/_static/image4.png))


## <a name="creating-unit-tests-for-the-service-layer"></a>サービス層の単体テストの作成

S、連絡先のマネージャー アプリケーションのサービス層の単体テストのセットを作成することで開始できるようにします。 これらのテストを使用して、検証ロジックを確認してください。

ContactManager.Tests プロジェクトでモデルをという名前の新しいフォルダーを作成します。 次に、Models フォルダーを右クリックし **追加、新しいテスト**です。 **新しいテストの追加**図 3 に示すダイアログが表示されます。 選択、**単体テスト**テンプレートし、新しいテスト ContactManagerServiceTest.cs の名前を付けます。 をクリックして、 **OK**テスト プロジェクトに新しいテストを追加するボタンです。

> [!NOTE] 
> 
> 一般に、ASP.NET MVC プロジェクトのフォルダー構造と一致するテスト プロジェクトのフォルダー構造をします。 たとえば、モデルのテスト、Models フォルダーに、コント ローラーのフォルダーにコント ローラーのテストを配置および表示します。


[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)

**図 03**: Models\ContactManagerServiceTest.cs ([フルサイズのイメージを表示するをクリックして](iteration-5-create-unit-tests-cs/_static/image6.png))


最初に、ContactManagerService クラスによって公開される CreateContact() メソッドをテストします。 次の 5 つのテストを作成します。

- CreateContact() - その CreateContact() のテストは、有効な連絡先がメソッドに渡されるときに値 true を返します。
- CreateContactRequiredFirstName() - テスト エラー メッセージが不足している名前との接続時に、モデルの状態に追加されたことは、CreateContact() メソッドに渡されます。
- CreateContactRequredLastName() - テスト エラー メッセージがモデル状態のときに不足している最後の名前の連絡先に追加されたことは、CreateContact() メソッドに渡されます。
- CreateContactInvalidPhone() - テスト エラー メッセージが無効な電話番号との接続時に、モデルの状態に追加されたことは、CreateContact() メソッドに渡されます。
- CreateContactInvalidEmail() - テスト エラー メッセージがモデル状態のときに無効な電子メール アドレスを持つ連絡先に追加されたことは、CreateContact() メソッドに渡されます.

最初のテストでは、有効な連絡先で検証エラーが発生しないことを確認します。 残りのテストは、それぞれの検証ルールを確認します。

これらのテストのコードは、1 のリストに含まれます。

**1 - Models\ContactManagerServiceTest.cs を一覧表示します。**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]


リスト 1 の連絡先クラスを使用して、ため、テスト プロジェクトに Microsoft Entity Framework への参照を追加する必要があります。 System.Data.Entity アセンブリへの参照を追加します。


1 を一覧表示するには、[TestInitialize] 属性で装飾された Initialize() という名前のメソッドが含まれます。 各単体テストの実行前に、このメソッドが自動的に呼び出されます (回呼び出された 5、単体テストの各直前)。 Initialize() メソッドでは、次のコード行をモック リポジトリを作成します。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

次のコード行では、Moq フレームワークを使用して、IContactManagerRepository インターフェイスからモック リポジトリを生成します。 実際の EntityContactManagerRepository 代わりには、モック リポジトリを使用して各単体テストを実行すると、データベースへのアクセスを回避します。 モック リポジトリが IContactManagerRepository インターフェイスのメソッドを実装しますが、メソッドは実際に何も実行します。

> [!NOTE] 
> 
> Moq フレームワークを使用する場合は、区別\_mockRepository と\_mockRepository.Object です。 前者を指すモック&lt;IContactManagerRepository&gt;モック リポジトリの動作を指定するためのメソッドを含むクラスです。 後者 IContactManagerRepository インターフェイスを実装する実際のモック リポジトリを参照します。


ContactManagerService クラスのインスタンスを作成するときに、モック リポジトリを Initialize() メソッドで使用されます。 すべての個々 の単体テストは、ContactManagerService クラスのこのインスタンスを使用します。

1 を一覧表示するには、単体テストのそれぞれに対応する 5 つのメソッドが含まれます。 これらの各メソッドは、[TestMethod] 属性で装飾します。 単体テストを実行すると、この属性を持つ任意のメソッドが呼び出されます。 つまり、[TestMethod] 属性で装飾されているメソッドは、単体テストです。

CreateContact()、という名前を最初の単体テストでは、こと CreateContact() を呼び出し、値は true を返します連絡先クラスの有効なインスタンスが、メソッドに渡されることを確認します。 テストは、連絡先クラスのインスタンスを作成するには、CreateContact() メソッドを呼び出しおよび CreateContact() を値 true を返すことを確認します。

残りのテストいることを確認無効な連絡先と CreateContact() メソッドが呼び出されたときに、メソッドが false を返します、予想される検証エラー メッセージがモデルの状態に追加します。 たとえば、CreateContactRequiredFirstName() テストは、その FirstName プロパティに空の文字列を連絡先クラスのインスタンスを作成します。 次に、無効な連絡先と CreateContact() メソッドが呼び出されます。 最後を検証 CreateContact() が false を返すことと、モデルの状態が含まれている予期された検証エラー メッセージには「名が必要」です。

メニュー オプションを選択してリスト 1 の単体テストを実行することができます**(CTRL + R、A) のソリューション内のすべてのテストを実行します。 テスト**です。 テスト結果 ウィンドウで、テストの結果が表示されます (図 4 を参照してください)。


[![テスト結果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)

**図 04**: テストの結果 ([フルサイズのイメージを表示するをクリックして](iteration-5-create-unit-tests-cs/_static/image8.png))


## <a name="creating-unit-tests-for-controllers"></a>コント ローラーの単体テストの作成

ASP.NETMVC アプリケーションは、ユーザーとの対話のフローを制御します。 コント ローラーが右のアクションの結果とビューのデータを返すかどうかをテストするコント ローラーをテストする場合。 コント ローラーが期待どおりのようにモデルのクラスと対話するかどうかをテストするも可能性があります。

たとえば、2 一覧表示するにはには、連絡先のコント ローラー Create() メソッドの 2 つの単体テストが含まれています。 最初の単体テストは、インデックスの操作に Create() メソッドをリダイレクトし、有効な連絡先が Create() メソッドに渡されることを確認します。 つまり、渡されると、有効な連絡先、Create() メソッドは、インデックスの操作を表す RedirectToRouteResult を返す必要があります。

コント ローラーのレイヤーをテストするときに、ContactManager サービス層をテストしたくありません。 そのため、初期化メソッドでは、次のコードにサービス層をモックします。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

CreateValidContact() 単体テストでは、サービス層の次のコード行を持つ CreateContact() メソッドを呼び出す動作模擬表示します。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

次のコード行は、その CreateContact() メソッドが呼び出されたときに、値 true を返しモック ContactManager サービスです。 サービス層をモック作成では、サービス層のすべてのコードを実行しなくても、コント ローラーの動作をテストおできます。

2 番目の単体テストでは、Create() アクションでは、無効な連絡先がメソッドに渡されるときに、ビューを作成するを返すことを確認します。 サービス層を次のコード行で値 false を返す CreateContact() メソッドが発生しました。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

場合は、サービス レイヤーは、値 false を返したときに、メソッドの動作は期待して Create() はビューを作成するを返す必要があります。 こうすれば、コント ローラーの検証エラー メッセージに表示ビューを作成するし、ユーザーをその無効な連絡先のプロパティを修正します。


コント ローラーの単体テストをビルドする予定の場合は、コント ローラーのアクションからの明示的なビュー名を返す必要があります。 たとえば、次のようにビューを返さない。

View(); を返す

代わりに、次のようにビューが返されます。

return View("Create");

いない場合は明示的なビューを返すときに、ViewResult.ViewName プロパティは、空の文字列を返します。


**2 - Controllers\ContactControllerTest.cs を一覧表示します。**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a>まとめ

このイテレーションでは、連絡先のマネージャー アプリケーションの単体テストを作成しました。 アプリケーションが予想される方法で引き続き動作を確認するのには、いつでもこれらの単体テストを実行できます。 単体テストは、安全に後でアプリケーションを変更することを有効にする、アプリケーションの安全策として機能します。

2 つのセットの単体テストを作成しました。 最初に、このサービス層の単体テストを作成することで、検証ロジックをテストしました。 次に、コント ローラー、レイヤーの単体テストを作成することで、フロー制御ロジックをテストしました。 サービス層をテストする際にお別に分離されたマイクロソフトによるテスト、サービス層のリポジトリの層から、リポジトリのレイヤーをモックします。 コント ローラーのレイヤーをテストする際にお別に分離されたマイクロソフトによるテスト コント ローラー、レイヤーのサービス層をモックします。

次のイテレーションで連絡先グループをサポートするように、連絡先のマネージャー アプリケーションを変更します。 この新しい機能をテスト駆動開発と呼ばれるソフトウェアのデザイン プロセスを使用して、アプリケーションに追加します。

> [!div class="step-by-step"]
> [前へ](iteration-4-make-the-application-loosely-coupled-cs.md)
> [次へ](iteration-6-use-test-driven-development-cs.md)
