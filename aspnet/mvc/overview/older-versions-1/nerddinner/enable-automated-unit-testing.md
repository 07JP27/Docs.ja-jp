---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: 自動化された単体テストを有効にする |Microsoft ドキュメント
author: microsoft
description: 手順 12 では、当社 NerdDinner 機能を確認して、これが得変更を加えるという自信を持って、自動化された単体テストのスイートを開発する方法を示します.
ms.author: aspnetcontent
manager: wpickett
ms.date: 07/27/2010
ms.topic: article
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: fede08be7e06327c6d04fa5d36f7dd818d79b380
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2018
---
<a name="enable-automated-unit-testing"></a><span data-ttu-id="8a79a-103">自動化された単体テストを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-103">Enable Automated Unit Testing</span></span>
====================
<span data-ttu-id="8a79a-104">によって[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="8a79a-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="8a79a-105">PDF をダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="8a79a-106">これは、無料の手順 12. ["NerdDinner"アプリケーションのチュートリアル](introducing-the-nerddinner-tutorial.md)をウォーク-にする方法を小規模の構築が完了すると、ASP.NET MVC 1 を使用して web アプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="8a79a-107">手順 12 では、自動化された単体テスト、NerdDinner 機能を確認して、これが得アプリケーションに将来の機能強化と変更を信頼度のスイートを開発する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="8a79a-108">ASP.NET MVC 3 を使用している場合ことをお勧めする、 [MVC 3 の開始と取得](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md)または[MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md)チュートリアルです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>


## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="8a79a-109">NerdDinner 手順 12: 単体テスト</span><span class="sxs-lookup"><span data-stu-id="8a79a-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="8a79a-110">自動化された単体テスト、NerdDinner 機能を確認して、これが得アプリケーションに将来の機能強化と変更を信頼度のスイートを開発してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="8a79a-111">なぜ単体テストのですか。</span><span class="sxs-lookup"><span data-stu-id="8a79a-111">Why Unit Test?</span></span>

<span data-ttu-id="8a79a-112">作業 1 つの朝にドライブ上で作業しているアプリケーションに関する発想の突然のフラッシュがある場合。</span><span class="sxs-lookup"><span data-stu-id="8a79a-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="8a79a-113">大幅に向上アプリケーションを構成することができますを実装する変更があるがわかっています。</span><span class="sxs-lookup"><span data-stu-id="8a79a-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="8a79a-114">リファクタリング コードをクリーンアップ、新機能を追加または、バグが修正される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="8a79a-115">お使いのコンピューターで受信したときにする、という疑問 –「安全な方法はこの機能強化を作成するか。」</span><span class="sxs-lookup"><span data-stu-id="8a79a-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="8a79a-116">場合、変更を行った副作用および中断ものか。</span><span class="sxs-lookup"><span data-stu-id="8a79a-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="8a79a-117">変更が単純なおよびのみを実装するには数分がかかる場合は、すべてのアプリケーション シナリオを手動でテストする時間がかかる可能性がありますか。</span><span class="sxs-lookup"><span data-stu-id="8a79a-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="8a79a-118">What-if シナリオをカバーするを忘れるし、壊れたアプリケーションは、運用環境に導入しますか。</span><span class="sxs-lookup"><span data-stu-id="8a79a-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="8a79a-119">すべての工数すべき本当にこの機能強化を行っているか。</span><span class="sxs-lookup"><span data-stu-id="8a79a-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="8a79a-120">自動化された単体テストでは、継続的に、アプリケーションを強化することができます安全策を提供できで作業しているコードを恐れてを回避することができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="8a79a-121">機能を使用すると、コードでは、信頼: とを支援する、それ以外の場合いないを感じる快適な改善点を迅速に検証するテストを自動化することを行っています。</span><span class="sxs-lookup"><span data-stu-id="8a79a-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="8a79a-122">これらより優れたソリューションを作成し、投資収益率を大幅に高くする潜在顧客のより長い有効期間にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="8a79a-123">ASP.NET MVC フレームワークを使用すると、簡単かつ自然単体テストのアプリケーション機能にします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="8a79a-124">テスト駆動開発 (TDD) ワークフローをベースのテスト ファースト開発を有効にすることもできます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="8a79a-125">NerdDinner.Tests Project</span><span class="sxs-lookup"><span data-stu-id="8a79a-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="8a79a-126">このチュートリアルの先頭に NerdDinner アプリケーションを作成した際おが表示されたか、アプリケーション プロジェクトと共に移動する単体テスト プロジェクトを作成する必要かどうかを確認するダイアログ ボックス。</span><span class="sxs-lookup"><span data-stu-id="8a79a-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="8a79a-127">私たちは保持「はい、単体テスト プロジェクトを作成する」ラジオ ボタンを選択: がソリューションに追加されている"NerdDinner.Tests"プロジェクトで発生したためです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="8a79a-128">NerdDinner.Tests プロジェクトでは、NerdDinner アプリケーション プロジェクトのアセンブリを参照され、アプリケーションの機能を確認して自動テストを簡単に追加することができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="8a79a-129">Dinner モデル クラスの単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="8a79a-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="8a79a-130">NerdDinner.Tests プロジェクト、モデルのレイヤーを作成したときに作成した Dinner クラスを検証するには、いくつかのテストを追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="8a79a-131">このモデルに関連するテストを配置おします"Models"と呼ばれる、テスト プロジェクト内に新しいフォルダーを作成することで始めます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="8a79a-132">フォルダーを右クリックし、選択、**追加 -&gt;新しいテスト**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="8a79a-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="8a79a-133">これは、「新しいテストの追加」ダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="8a79a-134">「単体テスト」を作成し、"DinnerTest.cs"という名前を選択します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="8a79a-135">"Ok"のボタンをクリックしたとき Visual Studio が追加 (され) DinnerTest.cs ファイルをプロジェクト。</span><span class="sxs-lookup"><span data-stu-id="8a79a-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="8a79a-136">Visual Studio 単体テストの既定のテンプレートは、一連の内部に少し乱れたの検索をボイラー プレート コードがします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="8a79a-137">みましょうをクリーンアップすることだけ次のコードを格納します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="8a79a-138">DinnerTest クラス上で、[TestClass] 属性は、テスト、だけでなく省略可能なテストの初期化および終了コードを格納するクラスとして識別されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="8a79a-139">その中のテストに [TestMethod] 属性を持つパブリック メソッドを追加して定義できます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="8a79a-140">次は、2 つ追加を実行するテスト、夕食クラスの最初の数値を示します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="8a79a-141">最初のテストでは、当社 Dinner が無効である新しい Dinner が正しく設定されているすべてのプロパティを指定せずに作成された場合を確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="8a79a-142">2 番目のテストでは、夕食に有効な値で設定されたすべてのプロパティがある場合、夕食が有効であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="8a79a-143">お気づきの上、テスト名は、明示的に指定 (とある程度詳細な) します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="8a79a-144">数百または数千の小規模のテストの作成最終的に可能性があります (特に、テスト ランナーでのエラーの一覧を対象にしている) 場合に、それぞれの動作と目的をすばやく判断しやすくために、これを行っています。</span><span class="sxs-lookup"><span data-stu-id="8a79a-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="8a79a-145">テストの名前をテストする機能をちなんだ必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="8a79a-146">以降を使用して、"名詞\_必要があります\_動詞"の名前付けパターン。</span><span class="sxs-lookup"><span data-stu-id="8a79a-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="8a79a-147">テスト パターン –「Arrange、Act、Assert」を意味する"AAA"を使用してテストを構造化お。</span><span class="sxs-lookup"><span data-stu-id="8a79a-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="8a79a-148">単体テスト中にセットアップを整列します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="8a79a-149">Act: 単体テストを実行し、結果をキャプチャ</span><span class="sxs-lookup"><span data-stu-id="8a79a-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="8a79a-150">アサート: 動作を確認してください。</span><span class="sxs-lookup"><span data-stu-id="8a79a-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="8a79a-151">記述するときおにならないように個々 のテストのテストが多すぎるしないでください。</span><span class="sxs-lookup"><span data-stu-id="8a79a-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="8a79a-152">代わりに各テストは、のみ、1 つの概念 (がかなり簡単にするエラーの原因を特定する) を確認してください。</span><span class="sxs-lookup"><span data-stu-id="8a79a-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="8a79a-153">アサート ステートメント テストごとに 1 つのみがあることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="8a79a-154">1 つ以上のアサート ステートメントをテスト メソッドである場合は場合、は、それらすべてに使用されている、同じ概念をテストして確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="8a79a-155">確かでない場合は、別のテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="8a79a-156">テストを実行しています</span><span class="sxs-lookup"><span data-stu-id="8a79a-156">Running Tests</span></span>

<span data-ttu-id="8a79a-157">Visual Studio 2008 Professional (および上位エディション) には、IDE 内でプロジェクトを Visual Studio 単体テストの実行に使用できる組み込みのテスト ランナーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="8a79a-158">選択する、**テスト -&gt;実行 -&gt;ソリューションのすべてのテスト**メニュー コマンド (または型 Ctrl R A) をすべての単体テストを実行します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="8a79a-159">または特定のテスト クラスまたはテスト メソッド内で、カーソルの位置を使用しまたは、**テスト -&gt;実行 -&gt;の現在のコンテキストのテスト**単体テストのサブセットを実行するメニュー コマンド (または ctrl キーを押し R 型 T)。</span><span class="sxs-lookup"><span data-stu-id="8a79a-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="8a79a-160">みましょう DinnerTest クラス内でカーソルを配置して、"Ctrl R、T"を定義したテストの実行、2 つに入力します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="8a79a-161">Visual Studio に表示されるときにこの作業を行う「テスト結果」ウィンドウと、このテストの実行結果内に表示されている後ほどお見せ。</span><span class="sxs-lookup"><span data-stu-id="8a79a-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="8a79a-162">*注: VS テスト結果 ウィンドウは、既定でのクラス名列を表示していません。これは、テスト結果 ウィンドウ内で右クリックし、列の追加/削除 メニューのコマンドを使用して追加できます。*</span><span class="sxs-lookup"><span data-stu-id="8a79a-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="8a79a-163">この 2 つのテスト時間に実行してすることができます。 1 秒あたりの一部のみ渡される、どちらも参照してください。</span><span class="sxs-lookup"><span data-stu-id="8a79a-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="8a79a-164">特定のルールの検証、ことを確認できるだけでなく、次の 2 つのヘルパー メソッドの IsUserHost() および IsUserRegisterd() – Dinner クラスに追加したをカバーするテストを作成することでそれらを拡張して」に進みますおできます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegisterd() – that we added to the Dinner class.</span></span> <span data-ttu-id="8a79a-165">Dinner クラスのためにこれらのすべてのテストをことによりより簡単かつ安全に後で新しいビジネス ルールと検証を追加します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="8a79a-166">夕食に、新しい規則のロジックを追加し、数秒以内、以前のロジック機能のいずれか、破損していないことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="8a79a-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="8a79a-167">どのようにわかりやすいテスト名を使用しやすい各テストの確認をすばやく把握することを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="8a79a-168">使用することをお勧め、 **Tools -&gt;オプション**メニュー コマンド、開く、テスト ツール-&gt;テストの実行構成 画面で、およびチェック"障害が発生したか結果が不確定の単体テストの結果をダブルクリックするとが表示されます。テストの障害発生時点"のチェック ボックスをオンします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="8a79a-169">こうと、テスト結果 ウィンドウでエラーをダブルクリックし、assert 障害にすぐにジャンプすることです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="8a79a-170">DinnersController 単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="8a79a-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="8a79a-171">当社 DinnersController 機能を確認するいくつかの単体テストを今すぐ作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="8a79a-172">うまく、テスト プロジェクト内の「コント ローラー」フォルダーを右クリックして、起動し、選択し、、**追加 -&gt;新しいテスト**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="8a79a-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="8a79a-173">「単体テスト」を作成し、名前"DinnersControllerTest.cs"おします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="8a79a-174">DinnersController Details() アクション メソッドを検証する 2 つのテスト メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="8a79a-175">最初は、既存の Dinner が要求されたときに、ビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="8a79a-176">2 つ目は、"NotFound"のビューが存在しない Dinner が要求されたときに返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="8a79a-177">上記のコードがクリーンにコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-177">The above code compiles clean.</span></span> <span data-ttu-id="8a79a-178">テストを実行したときに、どちらも失敗します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="8a79a-179">エラー メッセージを見ると、テストが失敗したが、DinnersRepository クラスできなかったので、データベースに接続することをおわかります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="8a79a-180">NerdDinner アプリケーションがローカル SQL Server Express のファイルを \App の下に存在する接続文字列を使用して\_NerdDinner アプリケーション プロジェクトのデータ ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="8a79a-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="8a79a-181">NerdDinner.Tests プロジェクトでコンパイルして実行を別のディレクトリ、アプリケーション プロジェクトであるため、接続文字列の相対パスの場所が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="8a79a-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="8a79a-182">お*でした*テスト プロジェクトに、SQL Express データベース ファイルをコピーすることによってこれを修正しをテスト プロジェクトの App.config にある適切なテスト接続文字列を追加します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="8a79a-183">これは、ブロック解除され、実行する上記のテストを取得します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="8a79a-184">実際のデータベースを使用してコードの単体テストに含まれるチャレンジの数。</span><span class="sxs-lookup"><span data-stu-id="8a79a-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="8a79a-185">具体的には、次のように使用します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-185">Specifically:</span></span>

- <span data-ttu-id="8a79a-186">単体テストの実行時間を大幅に遅くなります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="8a79a-187">それらを頻繁に実行する可能性が低く、テストを実行する時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="8a79a-188">秒 – で実行してそれを行うものとして、プロジェクトをコンパイルすると、必然的にすることができるに単体テストすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="8a79a-189">テスト内のセットアップおよび後処理用のロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="8a79a-190">各単体テストを作成する分離 (なし、副作用または依存関係) の他の独立したにします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="8a79a-191">実際のデータベースに対して作業を行うときにする必要がある状態に注意し、テストの状態にリセットします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="8a79a-192">"依存関係の挿入"これらの問題を回避し、マイクロソフトによるテストで実際のデータベースを使用する必要を避けるために役立つと呼ばれるデザイン パターンを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="8a79a-193">依存関係の挿入</span><span class="sxs-lookup"><span data-stu-id="8a79a-193">Dependency Injection</span></span>

<span data-ttu-id="8a79a-194">今すぐ DinnersController は「緊密」DinnerRepository クラスにします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="8a79a-195">「結合」は、ここで、明示的に依存している別のクラス機能するために状態を表します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="8a79a-196">DinnerRepository クラスには、データベースへのアクセスが必要であるため、密に結合された依存関係 DinnersController クラスには、DinnersController アクション メソッドをテストするためにデータベースが存在することを必要とするを DinnerRepository 両端にします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="8a79a-197">この問題を回避"依存関係の挿入"– あるアプローチ (データ アクセスを提供するリポジトリ クラス) のような依存関係がそれらを使用するクラス内で不要になった暗黙的に作成される場所と呼ばれるデザイン パターンを採用することによって取得できます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="8a79a-198">代わりに、依存関係に明示的に渡せるそれらを使用するクラスのコンス トラクター引数を使用します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="8a79a-199">依存関係は、インターフェイスを使用して定義されているが場合、おし、単体テストのシナリオ用の「偽」依存関係の実装で渡す柔軟性があります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="8a79a-200">これにより、実際にデータベースへのアクセスを必要としないテストに固有の依存関係の実装を作成することができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="8a79a-201">この動作を確認、DinnersController による依存性の注入を実装してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="8a79a-202">IDinnerRepository インターフェイスの抽出</span><span class="sxs-lookup"><span data-stu-id="8a79a-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="8a79a-203">取得および更新ディナー、コント ローラーが必要とするリポジトリ コントラクトをカプセル化する新しい IDinnerRepository インターフェイスを作成する、最初の手順がされます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="8a79a-204">このインターフェイス コントラクト \Models フォルダーを右クリックし を選択して手動で定義できます、**追加 -&gt;新しい項目の**メニュー コマンドと IDinnerRepository.cs をという名前の新しいインターフェイスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="8a79a-205">または、既存の DinnerRepository クラスからのインターフェイスを作成および使用リファクタリング ツールの Visual Studio Professional に組み込ま (および上位エディション) に自動的に抽出おできます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="8a79a-206">VS を使用してこのインターフェイスを抽出するには、単に DinnerRepository クラス テキスト エディターで、カーソルの位置しし、右クリックし、**リファクタリング -&gt;インターフェイスの抽出**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="8a79a-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="8a79a-207">これでは「インターフェイスの抽出」ダイアログを起動して、作成するには、インターフェイスの名前の入力を求めることです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="8a79a-208">IDinnerRepository 既定に設定され、既存の DinnerRepository クラス、インターフェイスに追加するすべてのパブリック メソッドを自動的に選択。</span><span class="sxs-lookup"><span data-stu-id="8a79a-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="8a79a-209">"Ok"ボタンをクリックすると Visual Studio は、アプリケーションに新しい IDinnerRepository インターフェイスを追加します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="8a79a-210">インターフェイスを実装できるように、既存の DinnerRepository クラスが更新されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="8a79a-211">コンス トラクターの挿入をサポートするために DinnersController の更新</span><span class="sxs-lookup"><span data-stu-id="8a79a-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="8a79a-212">これで、新しいインターフェイスを使用する DinnersController クラスが更新されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="8a79a-213">現在 DinnersController ハードコードされてその"dinnerRepository"フィールドが DinnerRepository クラスでは常に。</span><span class="sxs-lookup"><span data-stu-id="8a79a-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="8a79a-214">"DinnerRepository"のフィールドが型 DinnerRepository ではなく IDinnerRepository ようにして変更します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="8a79a-215">2 つのパブリック DinnersController コンス トラクターを追加します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="8a79a-216">コンス トラクターのいずれかにより、引数として渡される、IDinnerRepository ことができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="8a79a-217">もう 1 つは、既存の DinnerRepository 実装を使用する既定のコンス トラクターです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="8a79a-218">既定では ASP.NET MVC では、既定のコンス トラクターを使用して、コント ローラー クラスを作成するため、DinnersController 実行時に引き続き DinnerRepository クラスを使用してデータ アクセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="8a79a-219">渡すパラメーターのコンス トラクターを使用して、「偽」dinner リポジトリの実装で、ただし、単体テストを更新できます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="8a79a-220">この「偽」dinner リポジトリは、実際のデータベースへのアクセスが不要し、メモリ内のサンプル データを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="8a79a-221">FakeDinnerRepository クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="8a79a-222">FakeDinnerRepository クラスを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="8a79a-223">うまく NerdDinner.Tests プロジェクト内の"Fakes"ディレクトリを作成することで開始し、新しい FakeDinnerRepository クラスを追加、(フォルダーを右クリックし、選択**追加 -&gt;クラスの新しい**)。</span><span class="sxs-lookup"><span data-stu-id="8a79a-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="8a79a-224">FakeDinnerRepository クラス IDinnerRepository インターフェイスを実装できるように、コードが更新されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="8a79a-225">上を右クリックし、コンテキスト メニューのコマンドを「インターフェイスの実装 IDinnerRepository」おことができますし。</span><span class="sxs-lookup"><span data-stu-id="8a79a-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="8a79a-226">これにより、Visual Studio で自動的に「スタブ」の既定の実装で、FakeDinnerRepository クラスすべて IDinnerRepository インターフェイス メンバーの追加が発生します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="8a79a-227">インメモリ リストを使用する FakeDinnerRepository 実装し、更新することが&lt;Dinner&gt;コレクションがこれをコンス トラクターの引数として渡されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="8a79a-228">偽の IDinnerRepository 実装は、データベースや Dinner オブジェクトのメモリ内のリストを無効代わりに使用することを今すぐがあります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="8a79a-229">使用した、FakeDinnerRepository 単体テスト</span><span class="sxs-lookup"><span data-stu-id="8a79a-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="8a79a-230">データベースを使用できなかったために、以前に失敗した DinnersController 単体テストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="8a79a-231">次のコードを使用して DinnersController にサンプルのインメモリ Dinner データが設定される FakeDinnerRepository を使用するテスト メソッドを更新することをがします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="8a79a-232">これらのテストを実行すると、両方が合格しました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="8a79a-233">何より、実行するには、2 番目の一部のみを実行し、複雑なセットアップ/クリーンアップ ロジックは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="8a79a-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="8a79a-234">私たちは、実際のデータベースに接続することが必要なせずに単体テストのすべての DinnersController アクション メソッドのコード (インクルード一覧については、ページングは、詳細については、作成、更新および削除) のようになりましたことができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="8a79a-235">**依存関係の挿入フレームワークの側トピックの内容**</span><span class="sxs-lookup"><span data-stu-id="8a79a-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="8a79a-236">正常に機能しますが、依存関係の数と維持が困難になりますが、(上は) 同じように、手動による依存関係の挿入を実行して、アプリケーション内のコンポーネントが向上します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="8a79a-237">いくつかの依存関係の挿入フレームワークは、さらに多くの依存関係の管理の柔軟性を提供できる .NET に存在します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="8a79a-238">これらのフレームワークは、「制御の反転」(IoC) コンテナーとも呼ばを (最もよく使用されるコンス トラクター インジェクション実行時にオブジェクトに依存関係を渡すことを指定するための構成サポートの追加レベルを有効にするメカニズムを提供します。).</span><span class="sxs-lookup"><span data-stu-id="8a79a-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="8a79a-239">いくつかの最も一般的な OSS 依存関係の挿入/.net IOC フレームワークが含まれる: AutoFac、Ninject、Spring.NET、StructureMap、および Windsor です。</span><span class="sxs-lookup"><span data-stu-id="8a79a-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="8a79a-240">ASP.NET MVC の公開機能拡張 Api 解像度と、コント ローラーのインスタンス化に参加する開発者を有効にして、依存関係の挿入を有効にする/IoC フレームワークにおいて、このプロセス内で正常に統合します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="8a79a-241">DI/IOC フレームワークを使用しても、当社 DinnersController は –、DinnerRepositorys との間の結合を完全に削除がから既定のコンス トラクターを削除することできます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepositorys.</span></span> <span data-ttu-id="8a79a-242">おして、使用しない依存関係の挿入/NerdDinner アプリケーションと IOC フレームワークです。</span><span class="sxs-lookup"><span data-stu-id="8a79a-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="8a79a-243">ですが、NerdDinner コード ベースおよび機能が大きくなった場合、将来的にすることもお何か。</span><span class="sxs-lookup"><span data-stu-id="8a79a-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="8a79a-244">編集操作の単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="8a79a-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="8a79a-245">これで、DinnersController の編集機能を確認するいくつかの単体テストを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="8a79a-246">最初に、編集の操作の HTTP GET 以外のバージョンをテストします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="8a79a-247">有効な夕食が要求されたときに、DinnerFormViewModel オブジェクトによってバックアップされたビューが表示されることを確認するテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="8a79a-248">テストを実行したときに、わかります Edit メソッド プロパティにアクセスします User.Identity.Name Dinner.IsHostedBy() チェックを実行するときに、null 参照の例外がスローされたためにが失敗します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="8a79a-249">コント ローラーの基本クラスにユーザー オブジェクトは、ログインしたユーザーに関する詳細をカプセル化しは、実行時に、コント ローラーの作成時に ASP.NET MVC によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="8a79a-250">ユーザー オブジェクトが設定されていないため、web サーバー環境の外部で DinnersController は、テスト、(そのため、null 参照の例外)。</span><span class="sxs-lookup"><span data-stu-id="8a79a-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="8a79a-251">モック User.Identity.Name プロパティ</span><span class="sxs-lookup"><span data-stu-id="8a79a-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="8a79a-252">モック フレームワークでは、偽のバージョンのマイクロソフトによるテストをサポートする依存オブジェクトを動的に作成することを有効にして簡単にテストを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="8a79a-253">たとえば、当社 DinnersController シミュレートされたユーザー名を検索に使用できるユーザー オブジェクトを動的に作成するのにモック フレームワーク、編集操作のテストで使用できます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="8a79a-254">これにより、このテストを実行したときにスローされない null 参照が回避されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="8a79a-255">モック フレームワーク ASP.NET MVC で使用できる多くの .NET がある (ここでその一覧を確認できます: [ http://www.mockframeworks.com/ ](http://www.mockframeworks.com/))。</span><span class="sxs-lookup"><span data-stu-id="8a79a-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="8a79a-256">使用、オープン ソースのモック フレームワーク"Moq"と呼ばれる NerdDinner アプリケーションをテストするには、これからダウンロードできます。 無料[ http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)です。</span><span class="sxs-lookup"><span data-stu-id="8a79a-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="8a79a-257">ダウンロードされると、参照 NerdDinner.Tests プロジェクト内に追加 Moq.dll アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8a79a-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="8a79a-258">"CreateDinnersControllerAs(username)"ヘルパー メソッドを追加、テスト クラスと、パラメーターとしてユーザー名を受け取り、"mocks"DinnersController インスタンスの User.Identity.Name プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8a79a-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="8a79a-259">上記のモック オブジェクト (ある ASP.NET MVC はユーザー、要求、応答、およびセッションのようなランタイム オブジェクトを公開するのにコント ローラー クラスに渡されます) ControllerContext オブジェクトの fakes を作成するのに Moq を使用します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="8a79a-260">モックする ControllerContext HttpContext.User.Identity.Name プロパティがヘルパー メソッドに渡されたユーザー名の文字列を返すようにすることで"SetupGet"メソッドを呼び出しています。</span><span class="sxs-lookup"><span data-stu-id="8a79a-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="8a79a-261">ControllerContext プロパティとメソッドの任意の数を模擬表示おことができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="8a79a-262">この問題を説明するには、Request.IsAuthenticated プロパティ (– 以下のテストに実際に必要ないないが要求のプロパティを模擬表示する方法を説明するのに役立ちます) SetupGet() 呼び出しを追加しました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="8a79a-263">作業が完了するときに ControllerContext モックのインスタンスのヘルパー メソッドを返します DinnersController に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="8a79a-264">このヘルパー メソッドを使用して、別のユーザーに関係する編集のシナリオをテストする単体テストを記述できますようになりました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="8a79a-265">テストを実行したときに渡すようになりました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="8a79a-266">テストの UpdateModel() シナリオ</span><span class="sxs-lookup"><span data-stu-id="8a79a-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="8a79a-267">編集の操作の HTTP GET バージョンに対応するテストを作成しました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="8a79a-268">編集の操作の HTTP POST のバージョンを確認するいくつかのテストが作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="8a79a-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="8a79a-269">このアクション メソッドをサポートするうえで、興味深い新しいテスト シナリオは、コント ローラーの基本クラスで UpdateModel() ヘルパー メソッドの使用です。</span><span class="sxs-lookup"><span data-stu-id="8a79a-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="8a79a-270">このヘルパー メソッドを使用して、値をバインドするフォーム ポストを Dinner オブジェクト インスタンスにしています。</span><span class="sxs-lookup"><span data-stu-id="8a79a-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="8a79a-271">次は、どのフォーム ポストされた UpdateModel() ヘルパー メソッドを使用する値を提供可能を示す 2 つのテストを示します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="8a79a-272">FormCollection オブジェクトを作成してこれを行うし、コント ローラーで"ValueProvider"プロパティに割り当てるおします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="8a79a-273">最初のテストでは、正常に保存、ブラウザーがリダイレクトされるは、詳細のアクションを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="8a79a-274">2 番目のテストでは、無効な入力がポストされたときに、エラー メッセージでは、編集ビューをもう一度再アクションに表示されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>


[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="8a79a-275">テストのまとめ</span><span class="sxs-lookup"><span data-stu-id="8a79a-275">Testing Wrap-Up</span></span>

<span data-ttu-id="8a79a-276">単体テスト コント ローラー クラスに関連する主要な概念を説明してきました。</span><span class="sxs-lookup"><span data-stu-id="8a79a-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="8a79a-277">これらの手法を使用して、何百ものアプリケーションの動作を検証する簡単なテストを簡単に作成することできます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="8a79a-278">このコント ローラーとモデルのテストでは、実際のデータベースは必要ありません、ため非常に高速で簡単に実行されます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="8a79a-279">秒単位で何百もの自動テストを実行し、すぐに行った変更を超えたものかどうかについてのフィードバックになります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="8a79a-280">これにより、意見ご感想を継続的に向上させるため、リファクタリング、およびアプリケーションを調整する、信頼度は役立ちます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="8a79a-281">テストを説明した最後のトピックの「– としてテストが何かため、開発プロセス最後に行う必要がありますが、!</span><span class="sxs-lookup"><span data-stu-id="8a79a-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="8a79a-282">反対に、開発プロセスでできるだけ早期自動テストを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8a79a-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="8a79a-283">そのため実行ではきれいにすぐにフィードバックを作成したら、アプリケーションの使用シナリオ、について慎重に検討しを使用してアプリケーションを設計する方法を説明するようを重ねると、結合の点に注意することができます。</span><span class="sxs-lookup"><span data-stu-id="8a79a-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="8a79a-284">後の本の章がテスト駆動開発 (TDD)、および ASP.NET MVC で使用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="8a79a-285">TDD は、反復的なコーディングの推奨事項は、結果として得られるコードが適合するテストを記述する場所です。</span><span class="sxs-lookup"><span data-stu-id="8a79a-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="8a79a-286">TDD で、実装する機能を検証するテストを作成することで各機能を開始します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="8a79a-287">テスト最初により、明確に理解しておいて、機能と方法としてサポートされている作業単位を作成します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="8a79a-288">テストが記述された (およびが失敗することを確認した) 後にのみか、実際の検証機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="8a79a-289">既に、機能が動作すると想定される方法のユース ケースを考える時間を費やすことに、ための要件の理解を深める必要がそれらを実装する最善の方法とします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="8a79a-290">– テストを再実行してとして即時のフィードバックを取得、実装が完了したときにするかどうか、機能が正しく機能します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="8a79a-291">以上の 10 章 TDD を説明します。</span><span class="sxs-lookup"><span data-stu-id="8a79a-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="8a79a-292">次の手順</span><span class="sxs-lookup"><span data-stu-id="8a79a-292">Next Step</span></span>

<span data-ttu-id="8a79a-293">いくつかの最終的なコメントをラップします。</span><span class="sxs-lookup"><span data-stu-id="8a79a-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="8a79a-294">[前へ](use-ajax-to-implement-mapping-scenarios.md)
> [次へ](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="8a79a-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
