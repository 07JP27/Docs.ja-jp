---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC、Web ページに XSRF/CSRF 防止 |Microsoft ドキュメント
author: Rick-Anderson
description: これにより、悪意のある web サイトに影響を与える、interacti web ホスト アプリケーションへの攻撃をクロスサイト リクエスト フォージェリ (XSRF または CSRF とも呼ばれます) には.
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/10/2018
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="5414b-103">ASP.NET MVC、Web ページに XSRF/CSRF 防止</span><span class="sxs-lookup"><span data-stu-id="5414b-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="5414b-104">によって[Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="5414b-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="5414b-105">サイト間の要求が偽造 (XSRF または CSRF とも呼ばれます) は、悪意のある web サイトに影響を与える、クライアント ブラウザーおよびブラウザーによって信頼されている web サイト間の相互作用 web ホスト アプリケーションへの攻撃です。</span><span class="sxs-lookup"><span data-stu-id="5414b-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="5414b-106">Web ブラウザーが web サイトにすべての要求で自動的に認証トークンを送信するため、このような攻撃が可能になります。</span><span class="sxs-lookup"><span data-stu-id="5414b-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="5414b-107">標準的な例は、ASP など、認証 cookie です。NET のフォーム認証チケット。</span><span class="sxs-lookup"><span data-stu-id="5414b-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="5414b-108">ただし、(Windows 認証、Basic、およびなど) などの任意の永続的な認証メカニズムを使用する web サイトの場合は、これらの攻撃対象となることができます。</span><span class="sxs-lookup"><span data-stu-id="5414b-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="5414b-109">XSRF 攻撃がフィッシング攻撃とは異なります。</span><span class="sxs-lookup"><span data-stu-id="5414b-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="5414b-110">フィッシング攻撃では、対象ユーザーとの対話が必要です。</span><span class="sxs-lookup"><span data-stu-id="5414b-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="5414b-111">フィッシング攻撃では、悪意のある web サイトのターゲットの web サイト、うまくまねます、攻撃者に機密情報を提示するように、対象を間違うです。</span><span class="sxs-lookup"><span data-stu-id="5414b-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="5414b-112">XSRF 攻撃ではありません多くの場合、相互作用犠牲者から必要です。</span><span class="sxs-lookup"><span data-stu-id="5414b-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="5414b-113">代わりに、攻撃者は、移行先の web サイトに関連するすべての cookie を自動的に送信するブラウザーで証明書利用者です。</span><span class="sxs-lookup"><span data-stu-id="5414b-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="5414b-114">詳細については、次を参照してください。、 [Web アプリケーションのセキュリティのプロジェクトを開く](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))です。</span><span class="sxs-lookup"><span data-stu-id="5414b-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="5414b-115">攻撃の構造</span><span class="sxs-lookup"><span data-stu-id="5414b-115">Anatomy of an attack</span></span>

<span data-ttu-id="5414b-116">XSRF 攻撃を使用してすべての要素をユーザーが一部オンライン バンキングのトランザクションを実行するにを検討してください。</span><span class="sxs-lookup"><span data-stu-id="5414b-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="5414b-117">最初に、このユーザーは、この時点で、応答ヘッダーには、認証 cookie WoodgroveBank.com と、ログをアクセスします。</span><span class="sxs-lookup"><span data-stu-id="5414b-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="5414b-118">認証 cookie は、セッションの cookie であるため、これは自動的にクリアされますブラウザーによってブラウザー プロセスが終了したとき。</span><span class="sxs-lookup"><span data-stu-id="5414b-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="5414b-119">ただし、それまでは、ブラウザーが自動的に含まれる WoodgroveBank.com 要求ごとに cookie です。ユーザーは、彼女銀行サイト上のフォームに入力し、ブラウザーがサーバーにこの要求を行うために、別のアカウントに $1000 を転送するようになりましたがします。</span><span class="sxs-lookup"><span data-stu-id="5414b-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="5414b-120">この操作には、(通貨のトランザクションを開始) の副作用があるためバンキングのサイトがこの操作を開始するために HTTP POST を要求するように選択します。</span><span class="sxs-lookup"><span data-stu-id="5414b-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="5414b-121">サーバーは、要求から認証トークンを読み取りますは現在のユーザーのアカウント番号を検索、十分な資金が存在することを検証し、接続先のアカウントに、トランザクションを開始します。</span><span class="sxs-lookup"><span data-stu-id="5414b-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="5414b-122">オンライン バンキング完了彼女ユーザー バンキングのサイトから離れた場所に移動し、web 上の他の場所にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="5414b-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="5414b-123">埋め込まれた ページで、次のマークアップには – fabrikam.com – これらのサイトのいずれかが含まれています、 &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="5414b-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="5414b-124">この要求にブラウザーが発生しています。</span><span class="sxs-lookup"><span data-stu-id="5414b-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="5414b-125">攻撃者のサーバーを利用している彼女は、ターゲット サイトに HTTP POST を自動的に作成するブラウザーに Javascript の小さなスニペットを使用していて、ユーザーは、ターゲット web サイトの有効な認証トークンを必要があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="5414b-126">認証トークンがまだ有効では、銀行サイトが 250 ドルの攻撃者のアカウントへの転送を開始します。</span><span class="sxs-lookup"><span data-stu-id="5414b-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="5414b-127">非効率的な緩和策</span><span class="sxs-lookup"><span data-stu-id="5414b-127">Ineffective mitigations</span></span>

<span data-ttu-id="5414b-128">上記のシナリオでは、という事実 WoodgroveBank.com SSL 経由でアクセスされていた SSL のみの認証クッキーができなかったこと、攻撃を阻止するために十分な興味深い勧めします。</span><span class="sxs-lookup"><span data-stu-id="5414b-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="5414b-129">攻撃者を指定すること、 [URI スキーム](http://en.wikipedia.org/wiki/URI_scheme)(https) 自分の&lt;フォーム&gt;要素、およびブラウザーは引き続きこれらの cookie は、URI と一致している限り、対象のサイトに期限が切れていない cookie を送信目的のターゲットのスキーム。</span><span class="sxs-lookup"><span data-stu-id="5414b-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="5414b-130">ユーザー必要があります単にいないを参照してください信頼されていないサイトを信頼済みサイトがオンラインで安全なままにしておくことだけを訪問として 1 つと言えるでしょう。</span><span class="sxs-lookup"><span data-stu-id="5414b-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="5414b-131">いくつかの情報源が残念ながらこのアドバイス常に実用的ではありません。</span><span class="sxs-lookup"><span data-stu-id="5414b-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="5414b-132">おそらく、ユーザー「信頼」ローカル ニュース サイト ConsolidatedMessenger します。</span><span class="sxs-lookup"><span data-stu-id="5414b-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="5414b-133">ConsolidatedMessenger.com、代わりに、サイトのアクセスがそのサイトに進み、攻撃者が fabrikam.com 上で実行されるコードの同じスニペットの挿入を使用できる XSS 脆弱性があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="5414b-134">受信要求があることを確認することができます、 [Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)ドメインを参照します。</span><span class="sxs-lookup"><span data-stu-id="5414b-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="5414b-135">これにより、知らないうちにサード パーティ製のドメインから送信された要求は停止します。</span><span class="sxs-lookup"><span data-stu-id="5414b-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="5414b-136">ただし、一部のユーザーには、プライバシー保護のため、ブラウザーの Referer ヘッダーが無効にして、対象にインストールされている特定のセキュリティ保護されていないソフトウェアがある場合、攻撃者はそのヘッダーを偽装場合があることができます。</span><span class="sxs-lookup"><span data-stu-id="5414b-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="5414b-137">確認、 [Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) XSRF 攻撃を防ぐための安全な方法とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="5414b-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="5414b-138">Web スタック ランタイム XSRF の緩和策</span><span class="sxs-lookup"><span data-stu-id="5414b-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="5414b-139">ASP.NET Web スタック ランタイムのバリアントを使用して、[シンクロナイザー トークン パターン](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)XSRF 攻撃から防御するためにします。</span><span class="sxs-lookup"><span data-stu-id="5414b-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="5414b-140">シンクロナイザー トークン パターンの一般的な形式は次の 2 つの ANTI-XSRF トークンが (に加えて、認証トークン) は、各 HTTP POST を使用してサーバーに送信されたこと: として、cookie、フォームの値としてもう 1 つのトークン。</span><span class="sxs-lookup"><span data-stu-id="5414b-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="5414b-141">ASP.NET ランタイムによって生成されたトークンの値は、決定的であるか、攻撃者が予測可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="5414b-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="5414b-142">トークンが送信されると、サーバーは両方のトークン比較チェックに合格する場合にのみ継続する要求を許可します。</span><span class="sxs-lookup"><span data-stu-id="5414b-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="5414b-143">XSRF 要求検証*セッション トークン*は HTTP クッキーとして格納され、現在そのペイロードに次の情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="5414b-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="5414b-144">128 ビットのランダムな識別子で構成されるセキュリティ トークンです。</span><span class="sxs-lookup"><span data-stu-id="5414b-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="5414b-145">次の図は、XSRF 要求検証セッション トークン Internet Explorer F12 開発者ツールで表示されます: (注これは、現在の実装は、件名、でも変更される可能性をします)。</span><span class="sxs-lookup"><span data-stu-id="5414b-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="5414b-146">*フィールド トークン*として格納されて、`<input type="hidden" />`そのペイロードに次の情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="5414b-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="5414b-147">ログインしているユーザーのユーザー名 (認証された) 場合。</span><span class="sxs-lookup"><span data-stu-id="5414b-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="5414b-148">その他のデータによって提供される、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)です。</span><span class="sxs-lookup"><span data-stu-id="5414b-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="5414b-149">ANTI-XSRF トークンのペイロードが暗号化および署名済み、ツールを使用して、トークンを調べるときに、ユーザー名を表示できないようにします。</span><span class="sxs-lookup"><span data-stu-id="5414b-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="5414b-150">提供される暗号サービスで web アプリケーションで ASP.NET 4.0 がターゲットとするときに、 [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)ルーチンです。</span><span class="sxs-lookup"><span data-stu-id="5414b-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="5414b-151">Web アプリケーションが ASP.NET 4.5 を対象とするまたは高い、暗号サービスは、によって提供される場合、 [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))ルーチンより優れたパフォーマンス、拡張性、およびセキュリティを提供します。</span><span class="sxs-lookup"><span data-stu-id="5414b-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="5414b-152">詳細については、次のブログの投稿を参照してください。</span><span class="sxs-lookup"><span data-stu-id="5414b-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="5414b-153">ASP.NET 4.5 での暗号化の機能強化、pt です。1</span><span class="sxs-lookup"><span data-stu-id="5414b-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="5414b-154">ASP.NET 4.5 での暗号化の機能強化、pt です。2</span><span class="sxs-lookup"><span data-stu-id="5414b-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="5414b-155">ASP.NET 4.5 での暗号化の機能強化、pt です。3</span><span class="sxs-lookup"><span data-stu-id="5414b-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="5414b-156">トークンを生成します。</span><span class="sxs-lookup"><span data-stu-id="5414b-156">Generating the tokens</span></span>

<span data-ttu-id="5414b-157">ANTI-XSRF トークンを生成するには、呼び出し、 [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC ビューからのメソッドまたは@AntiForgery.GetHtmlRazor ページから ()。</span><span class="sxs-lookup"><span data-stu-id="5414b-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="5414b-158">ランタイムは、次の手順を実行し、されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="5414b-159">現在の HTTP 要求には既に ANTI-XSRF セッション トークンが含まれている場合 (ANTI-XSRF cookie \_ \_RequestVerificationToken)、これからセキュリティ トークンを抽出します。</span><span class="sxs-lookup"><span data-stu-id="5414b-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="5414b-160">HTTP 要求に ANTI-XSRF セッション トークンが含まれていない場合、またはセキュリティ トークンの抽出が失敗した場合は、新しいランダムな ANTI-XSRF トークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="5414b-161">上記の手順 (1) と現在のログイン ユーザーの id からセキュリティ トークンを使用して ANTI-XSRF フィールド トークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="5414b-162">(ユーザー id を確認する方法については、次を参照してください、 **[特別なサポートを使用するシナリオ](#_Scenarios_with_special)**以下のセクションです。)。さらに場合、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx)が構成されている場合、ランタイムが呼び出す、 [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)メソッド フィールド トークンに返される文字列を含めるとします。</span><span class="sxs-lookup"><span data-stu-id="5414b-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="5414b-163">(を参照してください、 **[構成および機能拡張](#_Configuration_and_extensibility)**詳細についてはします)。</span><span class="sxs-lookup"><span data-stu-id="5414b-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="5414b-164">新しい ANTI-XSRF トークン生成した場合 (1) の手順で、新しいセッション トークンは内包するが作成され、送信 HTTP クッキーのコレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="5414b-165">手順 (2) のフィールドのトークンにラップされます、`<input type="hidden" />`要素、および HTML マークアップをこの値となる、戻り値の`Html.AntiForgeryToken()`または`AntiForgery.GetHtml()`です。</span><span class="sxs-lookup"><span data-stu-id="5414b-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="5414b-166">トークンを検証します。</span><span class="sxs-lookup"><span data-stu-id="5414b-166">Validating the tokens</span></span>

<span data-ttu-id="5414b-167">入力方向の ANTI-XSRF トークンを検証するには、開発者が含まれています、 [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)彼女 MVC アクションまたはコント ローラー、または彼女の呼び出しの属性を`@AntiForgery.Validate()`自分の Razor ページから。</span><span class="sxs-lookup"><span data-stu-id="5414b-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="5414b-168">ランタイムでは、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="5414b-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="5414b-169">フィールド トークンが、受信セッション トークンが読み取られ、それぞれから抽出された ANTI-XSRF トークンです。</span><span class="sxs-lookup"><span data-stu-id="5414b-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="5414b-170">ANTI-XSRF トークンは、各手順 (2) の生成のルーチンで同一でなければなりません。</span><span class="sxs-lookup"><span data-stu-id="5414b-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="5414b-171">現在のユーザーが認証されている場合、自分のユーザー名はフィールドのトークンに格納されているユーザー名と比較されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="5414b-172">ユーザー名が一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-172">The usernames must match.</span></span>
3. <span data-ttu-id="5414b-173">場合、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)が構成されているランタイムの呼び出し、 *ValidateAdditionalData*メソッドです。</span><span class="sxs-lookup"><span data-stu-id="5414b-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="5414b-174">メソッドは、ブール値を返す必要があります*true*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="5414b-175">検証が成功した場合、要求の続行が許可されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="5414b-176">検証に失敗した場合、フレームワーク、 *HttpAntiForgeryException*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="5414b-177">エラー条件</span><span class="sxs-lookup"><span data-stu-id="5414b-177">Failure conditions</span></span>

<span data-ttu-id="5414b-178">以降、ASP.NET Web スタック ランタイム v2 で任意*HttpAntiForgeryException*中にスローされる検証が失敗の原因に関する詳細情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="5414b-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="5414b-179">現在定義されているエラー状態は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="5414b-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="5414b-180">セッション トークンまたはフォームのトークンが要求内に存在ではありません。</span><span class="sxs-lookup"><span data-stu-id="5414b-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="5414b-181">セッション トークンまたはフォームのトークンは、読み取り可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="5414b-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="5414b-182">これの最も一般的な原因は、ASP.NET Web スタック ランタイムまたはファームのバージョンに不一致が実行されているファーム場所、 &lt;machineKey&gt; Web.config 内の要素がマシン間で異なります。</span><span class="sxs-lookup"><span data-stu-id="5414b-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="5414b-183">Fiddler などのツールを使用すると、いずれかの ANTI-XSRF トークンを改ざんによってこの例外を強制します。</span><span class="sxs-lookup"><span data-stu-id="5414b-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="5414b-184">セッション トークンとフィールド トークンがスワップされました。</span><span class="sxs-lookup"><span data-stu-id="5414b-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="5414b-185">セッション トークンとフィールドのトークンには、一致していないセキュリティ トークンが含まれます。</span><span class="sxs-lookup"><span data-stu-id="5414b-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="5414b-186">フィールドのトークンに埋め込まれたユーザー名では、現在のログインのユーザーのユーザー名が一致しません。</span><span class="sxs-lookup"><span data-stu-id="5414b-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="5414b-187">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)*メソッドが返される*false*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="5414b-188">ANTI-XSRF 設備もトークンの生成または検証中に追加のチェックを実行して、例外がスロー、これらのチェック中にエラー。</span><span class="sxs-lookup"><span data-stu-id="5414b-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="5414b-189">参照してください、 [WIF/ACS/クレーム ベース認証](#_WIF_ACS)と**[構成および機能拡張](#_Configuration_and_extensibility)**詳細については、セクションです。</span><span class="sxs-lookup"><span data-stu-id="5414b-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="5414b-190">特別なサポートを使用するシナリオ</span><span class="sxs-lookup"><span data-stu-id="5414b-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="5414b-191">匿名認証</span><span class="sxs-lookup"><span data-stu-id="5414b-191">Anonymous authentication</span></span>

<span data-ttu-id="5414b-192">ANTI-XSRF システムには、「匿名」が定義されているユーザーとして、匿名ユーザー用の特別なサポートが含まれています。 ここで、 *IIdentity.IsAuthenticated*プロパティから返される*false*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="5414b-193">(前に、ユーザーが認証される) のログイン ページと、アプリケーションで使用されているメカニズム以外のカスタム認証方式に XSRF の保護を提供するようなシナリオ*IIdentity*ユーザーを識別します。</span><span class="sxs-lookup"><span data-stu-id="5414b-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="5414b-194">これらのシナリオをサポートするには、セッションとフィールドのトークンは、128 ビット ランダムに生成された非透過識別子であるセキュリティ トークンが参加していることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="5414b-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="5414b-195">このセキュリティ トークンは、彼女は匿名 id の目的を効果的に機能するために、サイトが移動したときに、個々 のユーザーのセッションを追跡するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="5414b-196">空の文字列は、上記の生成と検証ルーチンにユーザー名の代わりに使用されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="5414b-197">WIF/ACS/クレーム ベース認証</span><span class="sxs-lookup"><span data-stu-id="5414b-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="5414b-198">通常、 *IIdentity* 、.NET Framework に組み込まれているクラス プロパティが設定されている*IIdentity.Name*は特定のアプリケーション内で特定のユーザーを一意に識別するための十分なです。</span><span class="sxs-lookup"><span data-stu-id="5414b-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="5414b-199">たとえば、 *FormsIdentity.Name* (これは、そのデータベースに応じて、すべてのアプリケーションに対して一意では)、メンバーシップ データベースに格納されているユーザー名を返します*WindowsIdentity.Name*を返します、ユーザー、およびなどのドメイン修飾 id です。</span><span class="sxs-lookup"><span data-stu-id="5414b-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="5414b-200">これらのシステムだけでなく認証を提供します。これらも*識別*をアプリケーションにユーザー。</span><span class="sxs-lookup"><span data-stu-id="5414b-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="5414b-201">クレーム ベースの認証では、その一方は必ずしも必要ありません、特定のユーザーを識別します。</span><span class="sxs-lookup"><span data-stu-id="5414b-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="5414b-202">代わりに、 *ClaimsPrincipal*と*ClaimsIdentity*型のセットに割り当てられた*クレーム*インスタンス、個別の要求が「は 18 + 歳以上」をする可能性がありますか"管理者"を何でもです。</span><span class="sxs-lookup"><span data-stu-id="5414b-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="5414b-203">ユーザーを識別されているとは限りませんしていないため、ランタイムは使用できません、 *ClaimsIdentity.Name*プロパティを特定のユーザーの一意の識別子として。</span><span class="sxs-lookup"><span data-stu-id="5414b-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="5414b-204">チームが実際の例を表示、 *ClaimsIdentity.Name*返します*null*フレンドリ (表示) 名を返しますまたは、が一意の識別子として使用するために適切でない文字列を返しますそれ以外の場合、。ユーザー。</span><span class="sxs-lookup"><span data-stu-id="5414b-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="5414b-205">クレーム ベース認証を使用する展開の多くを使用している[Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) に特にです。</span><span class="sxs-lookup"><span data-stu-id="5414b-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="5414b-206">ACS では、個々 の開発者は構成がによって*id プロバイダー* (ADFS、Microsoft アカウント プロバイダーなど OpenID プロバイダーなどの yahoo! など)、id プロバイダーを返すと*の識別子の名前*.</span><span class="sxs-lookup"><span data-stu-id="5414b-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="5414b-207">これらの名前識別子は、電子メール アドレスのように Personally Identifiable Information (PII) を含めることは、または匿名化された Private Personal Identifier (PPID) のような可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="5414b-208">関係なく、(id プロバイダー、名前の識別子) 組十分には機能し、特定のユーザーの適切な監視トークンとして生成するときに、ASP.NET Web スタック ランタイムは、ユーザー名の代わりに、組を使用できるように、サイトを閲覧彼女とANTI-XSRF フィールド トークンを検証しています。</span><span class="sxs-lookup"><span data-stu-id="5414b-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="5414b-209">Id プロバイダーと名前の識別子の特定の Uri は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="5414b-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="5414b-210">(この[ACS doc ページ](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)詳細についてはします)。</span><span class="sxs-lookup"><span data-stu-id="5414b-210">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="5414b-211">生成するか、トークンを検証する、ASP.NET Web スタック ランタイムは実行時に再試行してください型にバインド。</span><span class="sxs-lookup"><span data-stu-id="5414b-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="5414b-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (用、WIF SDK。)</span><span class="sxs-lookup"><span data-stu-id="5414b-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="5414b-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5)。</span><span class="sxs-lookup"><span data-stu-id="5414b-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="5414b-214">これらの型が存在する場合、現在のユーザーの*IIIIdentity*これらのいずれかの型を実装クラスまたはサブクラス、ANTI-XSRF 機能は、(id プロバイダー、名前の識別子) を使用する組を生成するときに、ユーザー名の代わりにし、トークンを検証しています。</span><span class="sxs-lookup"><span data-stu-id="5414b-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="5414b-215">このような組が存在しない場合、要求は開発者に、使用中、特定のクレーム ベースの認証メカニズムを理解する ANTI-XSRF システムを構成する方法を説明するエラーで失敗します。</span><span class="sxs-lookup"><span data-stu-id="5414b-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="5414b-216">参照してください、 **[構成および機能拡張](#_Configuration_and_extensibility)**詳細についてはします。</span><span class="sxs-lookup"><span data-stu-id="5414b-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="5414b-217">OAuth または OpenID 認証</span><span class="sxs-lookup"><span data-stu-id="5414b-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="5414b-218">最後に、ANTI-XSRF 機能は、OAuth または OpenID 認証を使用するアプリケーションにとって特別なサポートがします。</span><span class="sxs-lookup"><span data-stu-id="5414b-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="5414b-219">このサポートは、ヒューリスティックに基づく: 場合、現在*IIdentity.Name*はユーザー名の比較を実行し、http:// または https://で始まる既定 OrdinalIgnoreCase の比較子ではなく序数の比較子を使用します。</span><span class="sxs-lookup"><span data-stu-id="5414b-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="5414b-220">構成および機能拡張</span><span class="sxs-lookup"><span data-stu-id="5414b-220">Configuration and extensibility</span></span>

<span data-ttu-id="5414b-221">場合によっては、開発者は、厳密な制御、ANTI-XSRF 生成と検証の動作をする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="5414b-222">たとえば、応答に HTTP クッキーを自動的に追加の Web ページと MVC ヘルパーの既定の動作が望ましく、おそらくと、開発者がトークンを他の場所を保持することもします。</span><span class="sxs-lookup"><span data-stu-id="5414b-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="5414b-223">この作業に役立つ 2 つの Api が存在します。</span><span class="sxs-lookup"><span data-stu-id="5414b-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="5414b-224">*GetTokens*既存 XSRF 要求検証セッションのトークン (を null にすることがあります) を入力としてのメソッドの受け取りと新しい XSRF 要求検証セッションのトークンとフィールドのトークンを出力として生成します。</span><span class="sxs-lookup"><span data-stu-id="5414b-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="5414b-225">トークンは、単に不透明な文字列; の装飾なしの*formToken*値のインスタンスは折り返されません内、&lt;入力&gt;タグ。</span><span class="sxs-lookup"><span data-stu-id="5414b-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="5414b-226">*NewCookieToken*値 null も指定できます。 これが発生した場合、 *oldCookieToken*値がまだ有効では、新しい応答 cookie を設定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="5414b-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="5414b-227">呼び出し元*GetTokens* 、必要な応答のクッキーを永続化または; 必要なマークアップを生成する役割が、 *GetTokens*メソッド自体は、副作用として、応答を変更しません。</span><span class="sxs-lookup"><span data-stu-id="5414b-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="5414b-228">*検証*メソッドは、受信セッション トークンとフィールド上に、ここに挙げた検証ロジックを実行します。</span><span class="sxs-lookup"><span data-stu-id="5414b-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="5414b-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="5414b-229">AntiForgeryConfig</span></span>

<span data-ttu-id="5414b-230">開発者は、アプリケーションから ANTI-XSRF システムを構成することがあります\_を開始します。</span><span class="sxs-lookup"><span data-stu-id="5414b-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="5414b-231">構成はプログラムです。</span><span class="sxs-lookup"><span data-stu-id="5414b-231">Configuration is programmatic.</span></span> <span data-ttu-id="5414b-232">静的プロパティ*AntiForgeryConfig*型について以下に説明します。</span><span class="sxs-lookup"><span data-stu-id="5414b-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="5414b-233">要求を使用するほとんどのユーザーを UniqueClaimTypeIdentifier プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="5414b-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="5414b-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="5414b-234">**Property**</span></span> | <span data-ttu-id="5414b-235">**説明**</span><span class="sxs-lookup"><span data-stu-id="5414b-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="5414b-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="5414b-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="5414b-237">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)をトークンの生成中に追加のデータを提供し、トークンの検証中に追加のデータを使用します。</span><span class="sxs-lookup"><span data-stu-id="5414b-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="5414b-238">既定値は*null*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-238">The default value is *null*.</span></span> <span data-ttu-id="5414b-239">詳細については、次を参照してください。、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)セクションです。</span><span class="sxs-lookup"><span data-stu-id="5414b-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="5414b-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="5414b-240">**CookieName**</span></span> | <span data-ttu-id="5414b-241">HTTP クッキーの名前を提供する文字列を使用して、セッションの ANTI-XSRF トークンを格納します。</span><span class="sxs-lookup"><span data-stu-id="5414b-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="5414b-242">この値が設定されていない場合、名前が自動的に生成されます、アプリケーションの展開された仮想パスに基づきます。</span><span class="sxs-lookup"><span data-stu-id="5414b-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="5414b-243">既定値は*null*です。</span><span class="sxs-lookup"><span data-stu-id="5414b-243">The default value is *null*.</span></span> |
| <span data-ttu-id="5414b-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="5414b-244">**RequireSsl**</span></span> | <span data-ttu-id="5414b-245">ANTI-XSRF トークンは、SSL で保護されたチャネル経由で送信するために必要かどうかを決定するブール値。</span><span class="sxs-lookup"><span data-stu-id="5414b-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="5414b-246">この値が場合*true*、自動的に生成された cookie は、「セキュリティで保護された」フラグを設定すると、持ち ANTI-XSRF Api が SSL を使用していない送信される要求から呼び出された場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="5414b-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="5414b-247">既定値は *false* です。</span><span class="sxs-lookup"><span data-stu-id="5414b-247">The default value is *false*.</span></span> |
| <span data-ttu-id="5414b-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="5414b-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="5414b-249">ANTI-XSRF システムにクレーム ベース id のサポートを非アクティブ化するかどうかを決定するブール値。</span><span class="sxs-lookup"><span data-stu-id="5414b-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="5414b-250">この値が場合*true*、システムと見なされます*IIdentity.Name*ユーザーごとの一意の識別子として使用するための適切なは、特別なケースは試みません*IClaimsIdentity*または*ClClaimsIdentity* 」の説明に従って、 [WIF/ACS/クレーム ベース認証](#_WIF_ACS)セクションです。</span><span class="sxs-lookup"><span data-stu-id="5414b-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="5414b-251">既定値は `false` です。</span><span class="sxs-lookup"><span data-stu-id="5414b-251">The default value is `false`.</span></span> |
| <span data-ttu-id="5414b-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="5414b-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="5414b-253">どの要求の種類を示す文字列は、ユーザーごとに一意の識別子として使用するための適切なです。</span><span class="sxs-lookup"><span data-stu-id="5414b-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="5414b-254">この値が設定され、現在場合*IIdentity*で指定されたクレームに基づく、システムは、種類のクレームを抽出しよう*UniqueClaimTypeIdentifier*、され、対応する値が使用されますフィールドのトークンを生成するときにユーザーのユーザー名の代わりに</span><span class="sxs-lookup"><span data-stu-id="5414b-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="5414b-255">要求の種類が見つからない場合、システムには、要求は失敗します。</span><span class="sxs-lookup"><span data-stu-id="5414b-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="5414b-256">既定値は*null*、(id プロバイダー、名前の識別子)、システムを使用することを示します組、ユーザーのユーザー名の代わりに、上記のとおりです。</span><span class="sxs-lookup"><span data-stu-id="5414b-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="5414b-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="5414b-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="5414b-258">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)*型により、各トークン内の追加データのラウンド トリップで ANTI-XSRF システムの動作を拡張する開発者です。</span><span class="sxs-lookup"><span data-stu-id="5414b-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="5414b-259">*GetAdditionalData*メソッドが呼び出された各フィールド トークンが生成され、戻り値が生成されたトークンに含まれています。</span><span class="sxs-lookup"><span data-stu-id="5414b-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="5414b-260">実装者は、このメソッドから、タイムスタンプ、nonce、またはユーザーがその他の値を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="5414b-261">同様に、 *ValidateAdditionalData*メソッドが呼び出された各フィールド トークンが検証され、トークン内に埋め込まれた「その他のデータ」文字列は、メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="5414b-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="5414b-262">検証ルーチンは、(トークンの作成時に格納されている時間に対して現在の時刻を確認しています) でのタイムアウトを実装する可能性があります、nonce ルーチン、またはその他のチェックに必要なロジック。</span><span class="sxs-lookup"><span data-stu-id="5414b-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="5414b-263">設計に関する決定事項とセキュリティの考慮事項</span><span class="sxs-lookup"><span data-stu-id="5414b-263">Design decisions and security considerations</span></span>

<span data-ttu-id="5414b-264">セッションとフィールドのトークンをリンクするセキュリティ トークンは技術的には必要な場合にのみ XSRF 攻撃からの匿名/未認証のユーザーを保護しようとしています。</span><span class="sxs-lookup"><span data-stu-id="5414b-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="5414b-265">1 つとして、ユーザーが認証されると、(おそらくは cookie の形式で送信された) 自体の認証トークンを使用できる、シンクロナイザーの半分のトークンの組。</span><span class="sxs-lookup"><span data-stu-id="5414b-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="5414b-266">ただし、ヒット未認証のユーザーがログイン ページを保護するための有効なシナリオはされ、ANTI-XSRF ロジックは常に生成し、認証されたユーザーについても、セキュリティ トークンを検証して単純なされていました。</span><span class="sxs-lookup"><span data-stu-id="5414b-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="5414b-267">またはいくつか追加の保護を設定またはセッション トークンを別の障壁を克服する攻撃者となる推測と、攻撃者によってフィールド トークンが侵害されたことを。</span><span class="sxs-lookup"><span data-stu-id="5414b-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="5414b-268">複数のアプリケーションが 1 つのドメインでホストされている場合は、開発者が注意を使用してください。</span><span class="sxs-lookup"><span data-stu-id="5414b-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="5414b-269">たとえば、にもかかわらず*example1.cloudapp.net*と*example2.cloudapp.net*別のホストは、下にあるすべてのホスト間で暗黙的な信頼関係がある、  *\*. cloudapp.net*ドメイン。</span><span class="sxs-lookup"><span data-stu-id="5414b-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="5414b-270">この暗黙的な信頼関係[により、互いの cookie に影響を与える可能性のある信頼されていないホスト](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks)(同じオリジンのポリシー AJAX 要求を必ずしも適用されません HTTP クッキーに)。</span><span class="sxs-lookup"><span data-stu-id="5414b-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="5414b-271">ASP.NET Web スタック ランタイムは、フィールド トークンにユーザー名が埋め込まれている悪意のあるサブドメインがセッション トークンを上書きできない場合でもそのことはできません、ユーザーの有効なフィールド トークンを生成するために、いくつかの対策を提供します。</span><span class="sxs-lookup"><span data-stu-id="5414b-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="5414b-272">ただし、このような環境でホストされている場合、組み込みの ANTI-XSRF ルーチンまだことはできません防御セッションの乗っ取りまたは XSRF のログイン。</span><span class="sxs-lookup"><span data-stu-id="5414b-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="5414b-273">ANTI-XSRF ルーチン現在はいない防御[clickjacking](https://www.owasp.org/index.php/Clickjacking)です。</span><span class="sxs-lookup"><span data-stu-id="5414b-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="5414b-274">Clickjacking 自体防御するアプリケーションが簡単に行う、X のフレームのオプションを送信することによって: SAMEORIGIN を持つ各応答ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="5414b-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="5414b-275">このヘッダーは、すべての最近使用したブラウザーでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="5414b-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="5414b-276">詳細については、次を参照してください。、 [IE ブログ](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL ブログ](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)、および[OWASP](https://www.owasp.org/index.php/Clickjacking)です。</span><span class="sxs-lookup"><span data-stu-id="5414b-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="5414b-277">将来のリリース、MVC、ASP.NET Web スタック ランタイム可能性があり、Web ページ ANTI-XSRF ヘルパーは、アプリケーションは自動的にこの攻撃から保護できるように自動的にこのヘッダーを設定します。</span><span class="sxs-lookup"><span data-stu-id="5414b-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="5414b-278">Web 開発者は、サイトがない XSS 攻撃に対して脆弱であることを確認する続行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5414b-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="5414b-279">XSS 攻撃は非常に強力でありが成功するには、XSRF 攻撃からの ASP.NET Web スタック ランタイム防御とも改ページします。</span><span class="sxs-lookup"><span data-stu-id="5414b-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="5414b-280">受信確認</span><span class="sxs-lookup"><span data-stu-id="5414b-280">Acknowledgment</span></span>

<span data-ttu-id="5414b-281">[@LeviBroderick](https://twitter.com/LeviBroderick)、作成者、ASP.NET セキュリティ コードの多くのこの情報の一括です。</span><span class="sxs-lookup"><span data-stu-id="5414b-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
