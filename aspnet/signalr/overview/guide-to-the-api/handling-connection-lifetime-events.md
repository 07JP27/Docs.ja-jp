---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: "理解および SignalR で接続の有効期間イベントの処理 |Microsoft ドキュメント"
author: pfletcher
description: "この記事では、ハブ API によって公開されているイベントを使用する方法について説明します。"
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 7a0a549f73ea303ec5694bb69d4eac52beb54098
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/10/2017
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="d28ad-103">理解および SignalR で接続の有効期間イベントの処理</span><span class="sxs-lookup"><span data-stu-id="d28ad-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="d28ad-104">によって[Patrick Fletcher](https://github.com/pfletcher)、 [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="d28ad-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="d28ad-105">この記事では、SignalR の接続、再接続、切断イベントを処理することができますをおよび構成できるタイムアウトとキープア ライブの設定の概要を示します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="d28ad-106">アーティクルは、SignalR と接続の有効期間イベントの一部に関する知識があると仮定します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="d28ad-107">SignalR の概要については、次を参照してください。 [SignalR の概要](../getting-started/introduction-to-signalr.md)です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="d28ad-108">接続の有効期間イベントのリストは、次のリソースを参照してください。</span><span class="sxs-lookup"><span data-stu-id="d28ad-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="d28ad-109">ハブ クラスでの接続の有効期間のイベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="d28ad-110">JavaScript クライアントで接続の有効期間のイベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="d28ad-111">.NET クライアントで接続の有効期間のイベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="d28ad-112">このトピックで使用されているソフトウェア バージョン</span><span class="sxs-lookup"><span data-stu-id="d28ad-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="d28ad-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="d28ad-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="d28ad-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="d28ad-114">.NET 4.5</span></span>
> - <span data-ttu-id="d28ad-115">SignalR バージョン 2</span><span class="sxs-lookup"><span data-stu-id="d28ad-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="d28ad-116">このトピックの以前のバージョン</span><span class="sxs-lookup"><span data-stu-id="d28ad-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="d28ad-117">SignalR の以前のバージョンについては、次を参照してください。[古いバージョンの SignalR](../older-versions/index.md)です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="d28ad-118">質問やコメント</span><span class="sxs-lookup"><span data-stu-id="d28ad-118">Questions and comments</span></span>
> 
> <span data-ttu-id="d28ad-119">このチュートリアルをリンクする方法と、ページの下部にあるコメントで改善新機能にフィードバックを送信してください。</span><span class="sxs-lookup"><span data-stu-id="d28ad-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="d28ad-120">チュートリアルに直接関連付けられていない質問がある場合を投稿、 [ASP.NET SignalR フォーラム](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)または[StackOverflow.com](http://stackoverflow.com/)です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="d28ad-121">概要</span><span class="sxs-lookup"><span data-stu-id="d28ad-121">Overview</span></span>

<span data-ttu-id="d28ad-122">この記事は、次のセクションで構成されています。</span><span class="sxs-lookup"><span data-stu-id="d28ad-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="d28ad-123">接続の有効期間の用語とシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="d28ad-124">SignalR 接続、トランスポート接続、および物理的な接続</span><span class="sxs-lookup"><span data-stu-id="d28ad-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="d28ad-125">トランスポートが切断されたときのシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="d28ad-126">クライアント切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="d28ad-127">サーバーが切断されたときのシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="d28ad-128">タイムアウトとキープア ライブの設定</span><span class="sxs-lookup"><span data-stu-id="d28ad-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="d28ad-129">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="d28ad-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="d28ad-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="d28ad-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="d28ad-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="d28ad-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="d28ad-132">タイムアウトとキープア ライブの設定を変更する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="d28ad-133">接続の切断についてユーザーに通知する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="d28ad-134">継続的に再接続する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="d28ad-135">サーバー コードでクライアントを切断する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="d28ad-136">切断の原因を検出します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="d28ad-137">API リファレンス トピックへのリンクは、.NET 4.5 のバージョンの API といます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="d28ad-138">.NET 4 を使用している場合は、次を参照してください。[の API のトピックは、.NET 4 バージョン](https://msdn.microsoft.com/en-us/library/jj891075(v=vs.100).aspx)します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/en-us/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="d28ad-139">接続の有効期間の用語とシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="d28ad-140">`OnReconnected` SignalR ハブ内のイベント ハンドラーがのすぐ後に実行できる`OnConnected`がいない後`OnDisconnected`特定のクライアントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="d28ad-141">再接続、切断されることがなくすることが理由は、SignalR で word「接続」を使用しているいくつかの方法があることです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="d28ad-142">SignalR 接続、トランスポート接続、および物理的な接続</span><span class="sxs-lookup"><span data-stu-id="d28ad-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="d28ad-143">この記事は区別*SignalR 接続*、*トランスポート接続*、および*物理接続*:</span><span class="sxs-lookup"><span data-stu-id="d28ad-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="d28ad-144">**SignalR 接続**クライアントとサーバーの URL、SignalR の API によって維持され、接続 ID によって一意に識別間に論理リレーションシップを参照</span><span class="sxs-lookup"><span data-stu-id="d28ad-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="d28ad-145">このリレーションシップに関するデータは、SignalR が管理し、トランスポート接続を確立するために使用します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="d28ad-146">リレーションシップの end と SignalR 破棄することも、データのクライアントを呼び出すと、`Stop`メソッドまたはタイムアウトの制限に達すると、SignalR が失われるトランスポート接続を再確立しようとしています。</span><span class="sxs-lookup"><span data-stu-id="d28ad-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="d28ad-147">**トランスポート接続**クライアントとサーバー、4 つのトランスポートの Api のいずれかで保持されている間に論理リレーションシップを指す: Websocket、server によって送信されるイベントが永久にフレーム、または長いポーリングします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="d28ad-148">SignalR では、トランスポート API を使用して、トランスポート接続を作成し、トランスポート API がトランスポート接続を作成する物理ネットワーク接続の存在に依存します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="d28ad-149">SignalR でが終了するとき、またはトランスポート API は、物理的な接続が切断されたことを検出すると、トランスポート接続が終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="d28ad-150">**物理的な接続**参照する物理ネットワーク リンク--ワイヤ、ワイヤレス信号をルーターなど、クライアント コンピューターとサーバー コンピューター間の通信を容易にします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="d28ad-151">物理的な接続がトランスポート接続を確立するために存在する必要があります、SignalR の接続を確立するためにトランスポート接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="d28ad-152">ただし、物理的な接続の重大なしない常に即座に終了トランスポート接続または SignalR 接続にこのトピックの後半で説明するとおりです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="d28ad-153">次の図で SignalR 接続は、ハブ API と PersistentConnection API SignalR レイヤーで表される、トランスポートの接続がトランスポート層で表されるおよび物理的な接続は、サーバー間を結ぶ線によって表されますクライアントとします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR のアーキテクチャ図](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="d28ad-155">呼び出すと、 `Start` SignalR クライアントのメソッドは、サーバーに物理的に接続を確立するために必要なすべての情報と SignalR クライアント コードを提供します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="d28ad-156">SignalR クライアント コードでは、この情報を使用して、HTTP 要求を送信し、4 つのトランスポートのいずれかを使用する物理接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="d28ad-157">トランスポート接続が失敗したか、サーバーが失敗する場合、SignalR 接続しない離れたはすぐに、クライアントがまだ同じ SignalR URL に新しいトランスポート接続を自動的に再確立するために必要な情報です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="d28ad-158">このシナリオでは、ユーザー アプリケーションによる介入は必要なく、新しい SignalR 接続が開始しない SignalR クライアント コードでは、新しいトランスポート接続を確立するときにします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="d28ad-159">SignalR 接続の連続性は、ファクトに反映されますを呼び出すときに作成される接続 ID、`Start`メソッドでは変更されません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="d28ad-160">`OnReconnected`トランスポート接続が失われた後に自動的に再確立されたときに、ハブのイベント ハンドラーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="d28ad-161">`OnDisconnected` SignalR 接続の最後にイベント ハンドラーを実行します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="d28ad-162">SignalR 接続は、次の方法のいずれかで終了できます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="d28ad-163">クライアントが呼び出す場合、`Stop`メソッド、停止メッセージは、サーバーに送信され、クライアントとサーバーの両方、SignalR 接続が即座に終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="d28ad-164">クライアントとサーバー間の接続が失われた後にクライアントが再接続して、サーバーが再接続するクライアントの待機です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="d28ad-165">再接続の試行が成功、切断のタイムアウト期間の終了する場合は、クライアントとサーバーの両方には、SignalR 接続が終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="d28ad-166">クライアントが再接続するには試行を中止し、サーバーが、形式の SignalR 接続の破棄します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="d28ad-167">呼び出す可能性をしなくても実行しているクライアントが停止した場合、`Stop`メソッド、サーバーが再接続するには、クライアントの待機し、切断のタイムアウト期間後、SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="d28ad-168">かどうか、サーバーが実行を停止、クライアントの再接続しよう (再転送接続) を作成し、切断のタイムアウト期間後、SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="d28ad-169">接続の問題がないと、ユーザーのアプリケーションを呼び出して、SignalR 接続の終了、`Stop`メソッド、SignalR 接続のトランスポート接続を開始および同じ時刻についてで終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="d28ad-170">次のセクションでは、他のシナリオをさらに詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="d28ad-171">トランスポートが切断されたときのシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="d28ad-172">物理的な接続が遅くなる可能性がまたは接続の中断がある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="d28ad-173">中断時間の長さなどの要因によってトランスポート接続が削除される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="d28ad-174">SignalR では、トランスポート接続を再確立が試行されます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="d28ad-175">トランスポート接続 API が中断を検出し、トランスポート接続が切断場合がありますを SignalR 検索すぐに接続が失われること。</span><span class="sxs-lookup"><span data-stu-id="d28ad-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="d28ad-176">他のシナリオでトランスポート接続 API も SignalR のどちらも認識はすぐになり接続が失われたことです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="d28ad-177">SignalR クライアントが呼び出される関数を使用して、ポーリング時間の長いを除くすべてのトランスポートで*keepalive*トランスポート API が検出できない接続が失われるを確認します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="d28ad-178">長いポーリングの接続については、次を参照してください。[タイムアウト設定と keepalive 設定](#timeoutkeepalive)このトピックで後述します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="d28ad-179">接続がアクティブでないときに、サーバーはクライアントにキープア ライブ パケットを送信定期的にします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="d28ad-180">この記事の内容が書き込まれる時点で、既定の間隔は 10 秒ごと</span><span class="sxs-lookup"><span data-stu-id="d28ad-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="d28ad-181">これらのパケットをリッスンしてでは、クライアントが、接続の問題があるかどうかを指示することができます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="d28ad-182">キープア ライブ パケットが受信されない場合が予想される場合、しばらくしてから、クライアントが想定動作を遅くしたり中断などの接続に関する問題があること。</span><span class="sxs-lookup"><span data-stu-id="d28ad-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="d28ad-183">Keepalive はまだ受け取っていない場合より長い時間が経過したら、クライアントで、接続が切断されてとの再接続を試みるを開始します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="d28ad-184">次の図は、トランスポート API によって認識されないすぐに物理接続に問題があるときに、一般的なシナリオで発生するクライアントとサーバーのイベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="d28ad-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="d28ad-185">図は、次の状況に適用されます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="d28ad-186">トランスポートは、Websocket、永久に枠、またはサーバーによって送信されるイベントがします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="d28ad-187">物理ネットワーク接続の中断の期間があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="d28ad-188">トランスポート API にはなりません、中断の対応する SignalR 機能に依存、keepalive がそれらを検出するようにします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![トランスポートの切断](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="d28ad-190">クライアントが再接続をモードに入る切断タイムアウト制限内でのトランスポート接続を確立できない場合は、サーバーは、SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="d28ad-191">サーバーが、ハブを実行する場合は、`OnDisconnected`メソッドおよび後で接続するクライアントを管理する場合に、クライアントに送信する切断メッセージをキュー。</span><span class="sxs-lookup"><span data-stu-id="d28ad-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="d28ad-192">接続解除コマンドと呼び出しを受け取る場合は、クライアントは再接続して、`Stop`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="d28ad-193">このシナリオで`OnReconnected`クライアントが再接続された場合は実行されず`OnDisconnected`クライアントが呼び出しては実行されません`Stop`です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="d28ad-194">次の図は、このシナリオを示します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-194">The following diagram illustrates this scenario.</span></span>

![トランスポートが中断される - サーバーのタイムアウト](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="d28ad-196">SignalR 接続の有効期間イベントの中で、クライアントで発生する可能性がありますを次に示します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="d28ad-197">`ConnectionSlow`クライアントのイベントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="d28ad-198">最後のメッセージから keepalive タイムアウト期間のプリセットの比率が経過または keepalive ping を受信したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="d28ad-199">Keepalive の既定のタイムアウト警告期間とは、2/3 keepalive タイムアウト時間のです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="d28ad-200">Keepalive タイムアウトは 20 秒は約 13 秒で警告が発生したためです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="d28ad-201">既定では、サーバー ping を送信 keepalive、10 秒ごと、keepalive ping 2 秒ごと (キープア ライブのタイムアウト値と keepalive タイムアウト警告値の差の 3 分の 1) は、クライアントを確認します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="d28ad-202">API のトランスポートが切断の対応になった場合は、keepalive タイムアウト警告期間が経過する前に、切断の SignalR を通知する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="d28ad-203">その場合は、`ConnectionSlow`イベントは発生しませんが、および SignalR に直接移動、`Reconnecting`イベント。</span><span class="sxs-lookup"><span data-stu-id="d28ad-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="d28ad-204">`Reconnecting`クライアントのイベントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="d28ad-205">接続が失われた、または (b)、keepalive タイムアウト期間が経過後、最後のメッセージかを keepalive ping を受信しました (a)、トランスポート API が検出したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="d28ad-206">SignalR クライアント コードでは、再接続を試行を開始します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="d28ad-207">トランスポート接続が失われたときに何らかのアクションを実行するアプリケーションの場合は、このイベントを処理することができます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="d28ad-208">既定のキープア ライブのタイムアウト期間は 20 秒では現在です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="d28ad-209">クライアント コードでは、SignalR が再接続をモードの間のハブ メソッドを呼び出すしようとして、SignalR は、コマンドを送信しようとします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="d28ad-210">ほとんどの場合、このような試行失敗しますが、状況によっては成功する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="d28ad-211">サーバー送信イベント、永久にフレーム、および長いポーリング トランスポート、SignalR は、いずれかのメッセージを送信するクライアントが使用してメッセージの受信に使用されている 1 つの 2 つの通信チャネルを使用します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="d28ad-212">受信に使用するチャネルが完全に開いている 1 つと、物理的な接続が中断されたときに閉じられている 1 つであります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="d28ad-213">物理的な接続が復元した場合、クライアントからサーバーへのメソッド呼び出しがあります正常に受信チャネルが再確立される前に、使用可能なままの送信に使用するチャネル。</span><span class="sxs-lookup"><span data-stu-id="d28ad-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="d28ad-214">戻り値は、SignalR が再び受信するために使用するチャネルを開くまで受信しません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="d28ad-215">`Reconnected`クライアントのイベントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="d28ad-216">トランスポート接続が再確立されると発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="d28ad-217">`OnReconnected`ハブ内のイベント ハンドラーを実行します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="d28ad-218">`Closed`クライアントのイベント (`disconnected` JavaScript でのイベント)。</span><span class="sxs-lookup"><span data-stu-id="d28ad-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="d28ad-219">切断のタイムアウト期間は、SignalR クライアント コードがトランスポート接続が切断後に再接続しようとしているときに有効期限が切れるときに発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="d28ad-220">既定値の切断のタイムアウトは 30 秒です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="d28ad-221">(ため、接続の終了時に、このイベントは発生も、`Stop`メソッドが呼び出されます)。</span><span class="sxs-lookup"><span data-stu-id="d28ad-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="d28ad-222">トランスポート API で検出されない、keepalive ping keepalive タイムアウト警告期間よりも長いのサーバーからの受信を遅延しないトランスポート接続の中断は、任意の接続が発生する有効期間イベントを発生させない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="d28ad-223">一部のネットワーク環境が意図的に、アイドル状態の接続を閉じるし、キープア ライブ パケットの別の関数は、これらのネットワークであること、SignalR 接続で使用することでこれを防ぐためにします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="d28ad-224">極端なケースで keepalive ping の既定の頻度できない可能性がありますの接続終了を防ぐために十分な数です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="d28ad-225">その場合はより多くの場合、送信される keepalive ping を構成できます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="d28ad-226">詳細については、次を参照してください。[タイムアウト設定と keepalive 設定](#timeoutkeepalive)このトピックで後述します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="d28ad-227">**重要な**: ここで説明されているイベントの順序は保証されません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="d28ad-228">SignalR は、このスキームによって予測可能な方法で接続の有効期間のイベントを発生させるすべての試行がネットワーク イベントの多くのバリエーションとトランスポート Api など、基になる通信フレームワークがそれらに対応する多くの方法があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="d28ad-229">たとえば、`Reconnected`クライアントが再接続された場合、イベントを発生しない可能性がまたは`OnConnected`接続を確立する試行が成功すると、サーバー上のハンドラーを実行可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="d28ad-230">このトピックでは、特定の標準的な環境によって通常生成される影響のみを説明します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="d28ad-231">クライアント切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-231">Client disconnection scenarios</span></span>

<span data-ttu-id="d28ad-232">ブラウザー クライアントで、SignalR 接続を維持する SignalR クライアント コードは、web ページの JavaScript のコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="d28ad-233">ですが、SignalR 接続が終了のいずれかから移動したときに、なぜページ別、およびその 's 理由複数接続がある複数の接続 Id で複数のブラウザー ウィンドウまたはタブから接続する場合。</span><span class="sxs-lookup"><span data-stu-id="d28ad-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="d28ad-234">SignalR クライアント コードでは、そのブラウザー イベントを処理して呼び出しのために、SignalR 接続を直ちに終了、ユーザーは、ブラウザー ウィンドウまたはタブを閉じるで新しいページに移動または、ページを更新、ときに、`Stop`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="d28ad-235">これらのシナリオで、または任意のクライアント プラットフォーム、アプリケーションを呼び出すときに、`Stop`メソッド、`OnDisconnected`サーバー上のイベント ハンドラーをすぐに実行させ、クライアント、`Closed`イベント (イベントの名前は`disconnected`でJavaScript の場合)。</span><span class="sxs-lookup"><span data-stu-id="d28ad-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="d28ad-236">クライアント アプリケーションまたはで実行されているコンピューターがクラッシュまたは (たとえば、ユーザーの終了時に、ラップトップ) スリープ状態に、変更点について、サーバーは通知されません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="d28ad-237">サーバーが認識できる限り、接続の中断により、クライアントが失われる可能性があり、クライアントは再接続を試みている可能性がします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="d28ad-238">により、クライアント、再接続するには、サーバーが待機するようなシナリオではそのため、および`OnDisconnected`切断タイムアウト期間 (既定では約 30 秒) が経過するまでは実行されません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="d28ad-239">次の図は、このシナリオを示します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-239">The following diagram illustrates this scenario.</span></span>

![クライアント コンピューターに失敗しました](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="d28ad-241">サーバーが切断されたときのシナリオ</span><span class="sxs-lookup"><span data-stu-id="d28ad-241">Server disconnection scenarios</span></span>

<span data-ttu-id="d28ad-242">サーバーがオフラインになると--、再起動、失敗すると、アプリケーション ドメインは、リサイクルなど、結果が失われた接続のような可能性がありますまたはトランスポート API および SignalR 可能性があることを認識すぐに、サーバーがなくなり、SignalR が可能性がありますを開始せずに再接続しようとしています。させると、`ConnectionSlow`イベント。</span><span class="sxs-lookup"><span data-stu-id="d28ad-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="d28ad-243">クライアントが再接続をモードになる場合と、サーバーを復旧または再起動や、新しいサーバーがオンラインに切断タイムアウト期間の有効期限が切れる前に、クライアントを復元または新しいサーバーに再接続します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="d28ad-244">クライアントの SignalR 接続を継続する場合は、および`Reconnected`イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="d28ad-245">最初のサーバーで`OnDisconnected`が実行されることと、新しいサーバーで`OnReconnected`が実行される`OnConnected`前にそのサーバーにそのクライアントに対して実行されたことはありません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="d28ad-246">(影響は前回の接続のアクティビティのメモリがない場合は、クライアントが再接続する同じサーバーに、再起動またはアプリケーション ドメインのリサイクル後、サーバーが再起動し、同じ)。次の図は、トランスポート API がすぐに、接続が切断された対応が前提としています。 そのため、`ConnectionSlow`イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![サーバーの障害と再接続](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="d28ad-248">サーバーが利用可能にならない切断タイムアウト期間内で、SignalR 接続が終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="d28ad-249">このシナリオでは、`Closed`イベント (`disconnected` JavaScript クライアントで) がクライアントで発生しますが、`OnDisconnected`サーバーで呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="d28ad-250">次の図は、トランスポート API はならないこと、接続が切断された対応 SignalR keepalive 機能によって検出されたために前提としています。 および`ConnectionSlow`イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![サーバーの障害とタイムアウト](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="d28ad-252">タイムアウトとキープア ライブの設定</span><span class="sxs-lookup"><span data-stu-id="d28ad-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="d28ad-253">既定値`ConnectionTimeout`、 `DisconnectTimeout`、および`KeepAlive`値はほとんどのシナリオに適していますが、環境内に特別なニーズに応じて変更できます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="d28ad-254">たとえば、ネットワーク環境では、5 秒間アイドル状態になって接続が閉じ、keepalive 値を小さく必要があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="d28ad-255">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="d28ad-255">ConnectionTimeout</span></span>

<span data-ttu-id="d28ad-256">この設定では、オープンで終了して、新しい接続を開く前に応答を待機しているトランスポート接続のままにする時間を表します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="d28ad-257">既定値は、110 秒です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="d28ad-258">この設定では、のみ keepalive 機能は無効にすると、通常、時間の長いにのみ適用されますが適用されます。 トランスポートをポーリングします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="d28ad-259">次の図は、時間の長いでこの設定の効果のトランスポート接続をポーリングします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![長いポーリングのトランスポートの接続](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="d28ad-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="d28ad-261">DisconnectTimeout</span></span>

<span data-ttu-id="d28ad-262">この設定は、発生させる前にトランスポート接続が失われた後に待機する時間を表す、`Disconnected`イベント。</span><span class="sxs-lookup"><span data-stu-id="d28ad-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="d28ad-263">既定値は 30 秒です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-263">The default value is 30 seconds.</span></span> <span data-ttu-id="d28ad-264">設定すると`DisconnectTimeout`、`KeepAlive`の 1/3 に自動的に設定されている、`DisconnectTimeout`値。</span><span class="sxs-lookup"><span data-stu-id="d28ad-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="d28ad-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="d28ad-265">KeepAlive</span></span>

<span data-ttu-id="d28ad-266">この設定では、アイドル状態の接続でキープア ライブ パケットを送信する前に待機する時間を表します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="d28ad-267">既定値は、10 秒です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-267">The default value is 10 seconds.</span></span> <span data-ttu-id="d28ad-268">この値が複数の 1/3 のすることはできません、`DisconnectTimeout`値。</span><span class="sxs-lookup"><span data-stu-id="d28ad-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="d28ad-269">両方を設定する場合は、`DisconnectTimeout`と`KeepAlive`設定、`KeepAlive`後`DisconnectTimeout`です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="d28ad-270">それ以外の場合、`KeepAlive`設定が上書きされる場合`DisconnectTimeout`が自動的に設定`KeepAlive`タイムアウト値の 1/3 にします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="d28ad-271">Keepalive の機能を無効にする場合は、設定`KeepAlive`を null にします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="d28ad-272">Keepalive 機能は使用できません自動的に、時間の長いトランスポートをポーリングします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="d28ad-273">タイムアウトとキープア ライブの設定を変更する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="d28ad-274">これらの設定の既定値を変更するで設定`Application_Start`で、 *Global.asax*ファイルを次の例で示すようにします。</span><span class="sxs-lookup"><span data-stu-id="d28ad-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="d28ad-275">サンプル コードに示すように値は、既定値と同じです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="d28ad-276">接続の切断についてユーザーに通知する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="d28ad-277">一部のアプリケーションでは、接続の問題がある場合に、ユーザーにメッセージを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="d28ad-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="d28ad-278">これを行う方法に関するいくつかのオプションとがあります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="d28ad-279">生成されたプロキシを使用して、JavaScript クライアントは、次のコード サンプルです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="d28ad-280">処理、`connectionSlow`再接続モードに入る前に、SignalR は接続の問題を認識するとすぐにメッセージを表示するイベントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="d28ad-281">処理、 `reconnecting` SignalR が切断を認識しており、再接続をモードに入るはときにメッセージを表示するイベントです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="d28ad-282">処理、`disconnected`と再接続を試行してメッセージを表示するイベントがタイムアウトしました。呼び出すことによって、SignalR 接続を再起動するサーバーとの接続が再度を再確立する唯一の方法は、このシナリオでは、`Start`メソッドで、新しい接続 ID が作成されます</span><span class="sxs-lookup"><span data-stu-id="d28ad-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="d28ad-283">次のコード例では、フラグを使用して呼び出すことによって発生 SignalR 接続への通常の終了後、再接続するタイムアウトした場合にのみ通知を発行することを確認してください、`Stop`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="d28ad-284">継続的に再接続する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-284">How to continuously reconnect</span></span>

<span data-ttu-id="d28ad-285">一部のアプリケーションでは、自動的に失われ、再接続の試行がタイムアウトした後に、接続を再確立することができます。実行するに呼び出せる、`Start`メソッドから、`Closed`イベント ハンドラー (`disconnected` JavaScript クライアントにイベント ハンドラー)。</span><span class="sxs-lookup"><span data-stu-id="d28ad-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="d28ad-286">呼び出す前に期間を待機することができます`Start`もこれを回避するために頻繁に場合、サーバーまたは物理的な接続は使用できません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="d28ad-287">次のコード サンプルは、生成されたプロキシを使用して、JavaScript クライアントによってです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="d28ad-288">モバイル クライアントで認識する潜在的な問題は、継続的な再接続試行サーバーまたは物理的な接続を利用できない場合に、不要なバッテリ ドレイン可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d28ad-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="d28ad-289">サーバー コードでクライアントを切断する方法</span><span class="sxs-lookup"><span data-stu-id="d28ad-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="d28ad-290">SignalR バージョン 2 のクライアントを切断するための組み込みのサーバー API ではありません。</span><span class="sxs-lookup"><span data-stu-id="d28ad-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="d28ad-291">ある[今後、この機能を追加するためのプラン](https://github.com/SignalR/SignalR/issues/2101)です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="d28ad-292">SignalR の現在のリリースでは、サーバーからクライアントを切断する最も簡単な方法は、クライアントで disconnect メソッドを実装し、サーバーからそのメソッドを呼び出すにです。</span><span class="sxs-lookup"><span data-stu-id="d28ad-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="d28ad-293">次のコード サンプルでは、生成されたプロキシを使用して、JavaScript クライアントの disconnect メソッドを示します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="d28ad-294">セキュリティ - も、どちらものクライアントを切断するのには、このメソッドも、提案された組み込み API により対応クライアントが再接続でしたかハッキングされたコードを削除する場合がありますので、悪意のあるコードを実行しているハッキングされたクライアントのシナリオ、`stopClient`メソッドまたは変更動作します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="d28ad-295">ステートフルなサービス拒否 (DOS) の保護を実装する適切な場所がではなく、フレームワーク、またはサーバー層のフロント エンド インフラストラクチャではなく、します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="d28ad-296">切断の原因を検出します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="d28ad-297">SignalR 2.1 では、オーバー ロードをサーバーに追加`OnDisconnect`タイムアウトではなく、クライアントが意図的に切断されたかどうかを示すイベントです。`StopCalled`パラメーターが true の場合は、クライアントが接続を明示的に終了します。</span><span class="sxs-lookup"><span data-stu-id="d28ad-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="d28ad-298">JavaScript では、サーバー エラーの原因、クライアントを切断する場合、エラー情報が渡されますとしてクライアントに`$.connection.hub.lastError`です。</span><span class="sxs-lookup"><span data-stu-id="d28ad-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="d28ad-299">**C# サーバー コード:`stopCalled`パラメーター**</span><span class="sxs-lookup"><span data-stu-id="d28ad-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="d28ad-300">**JavaScript クライアント コード: にアクセスする`lastError`で、`disconnect`イベント。**</span><span class="sxs-lookup"><span data-stu-id="d28ad-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
