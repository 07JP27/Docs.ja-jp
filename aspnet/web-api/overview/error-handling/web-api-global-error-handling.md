---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: グローバルのエラー処理 ASP.NET Web API 2 |Microsoft ドキュメント
author: davidmatson
description: ''
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: c593c56ba3d0ee8ebf6dc425408d2c3b91c83f93
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2018
ms.locfileid: "28042587"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="0e31f-102">グローバルなエラー ASP.NET Web API 2 の処理</span><span class="sxs-lookup"><span data-stu-id="0e31f-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="0e31f-103">によって[David Matson](https://github.com/davidmatson)、 [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="0e31f-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

<span data-ttu-id="0e31f-104">今日はありません簡単な方法でログインするか、グローバルにエラーを処理する Web API です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="0e31f-105">使用していくつかのハンドルされない例外を処理できる[例外フィルター](exception-handling.md)はさまざまな例外フィルターが処理できない場合がありますが、します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="0e31f-106">例:</span><span class="sxs-lookup"><span data-stu-id="0e31f-106">For example:</span></span>

1. <span data-ttu-id="0e31f-107">コント ローラーのコンス トラクターからスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="0e31f-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="0e31f-108">メッセージ ハンドラーからスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="0e31f-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="0e31f-109">ルーティング時にスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="0e31f-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="0e31f-110">応答のコンテンツのシリアル化中にスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="0e31f-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="0e31f-111">ログインし、(可能な場合) を処理するシンプルで一貫した方法を提供するこれらの例外。</span><span class="sxs-lookup"><span data-stu-id="0e31f-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="0e31f-112">エラー応答を送信することはできませんし、すべて行うには大文字と小文字が例外をログの場合、例外を処理するための 2 つの主要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="0e31f-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="0e31f-113">後者の場合の例は、応答のコンテンツをストリーミングの途中で例外がスローされたときその場合に遅すぎますステータス コード、ヘッダー、およびコンテンツの一部が既に実行がネットワーク経由で単に接続を中止しましたのでために、新しい応答メッセージを送信します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="0e31f-114">新しい応答メッセージを生成するためには、例外を処理することはできない場合でも、例外をログ記録がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="0e31f-115">エラーを検出できる場合、次に示すように、該当するエラー応答を返すことができますお。</span><span class="sxs-lookup"><span data-stu-id="0e31f-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="0e31f-116">既存のオプション</span><span class="sxs-lookup"><span data-stu-id="0e31f-116">Existing Options</span></span>

<span data-ttu-id="0e31f-117">加え[例外フィルター](exception-handling.md)、[メッセージ ハンドラー](../advanced/http-message-handlers.md) 、500 番台のすべての応答を観察する今日使用できますが、元のエラーに関するコンテキストを持っていないものとして、これらの応答で動作するが困難ですが、します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="0e31f-118">メッセージ ハンドラーでは、いくつかのケースを処理できるに関する例外フィルターと同じ制限があります。Web API にはエラー状態をキャプチャするトレース インフラストラクチャはありますが、トレース インフラストラクチャは診断目的およびは not に設計されています。 または実稼働環境で実行するために適しています。</span><span class="sxs-lookup"><span data-stu-id="0e31f-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="0e31f-119">グローバル例外処理とログ記録は、実稼動中に実行でき、既存の監視ソリューションに接続するサービスをする必要があります (たとえば、 [ELMAH](https://code.google.com/p/elmah/) )。</span><span class="sxs-lookup"><span data-stu-id="0e31f-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="0e31f-120">ソリューションの概要</span><span class="sxs-lookup"><span data-stu-id="0e31f-120">Solution Overview</span></span>

 <span data-ttu-id="0e31f-121">2 つの新しいユーザー-置き換え可能なサービスを提供して[IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)と IExceptionHandler、ログに記録し、未処理の例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="0e31f-122">サービスは、次の 2 つの主な相違点と、非常に似ています。</span><span class="sxs-lookup"><span data-stu-id="0e31f-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="0e31f-123">サポートされていますが、複数の例外ロガー、1 つの例外ハンドラーのみを登録します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="0e31f-124">例外ロガー常に呼び出される、接続を中止しようとしている場合でもです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="0e31f-125">例外ハンドラーの取得時のみ呼び出すまだを選択する応答メッセージを送信できませんでした。</span><span class="sxs-lookup"><span data-stu-id="0e31f-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="0e31f-126">両方のサービス例外が検出された時点からの関連情報を含む例外コンテキストへのアクセスを提供する、特に[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)、 [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)では、例外と例外のソース (以下詳細) がスローされます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="0e31f-127">デザインの原則</span><span class="sxs-lookup"><span data-stu-id="0e31f-127">Design Principles</span></span>

1. <span data-ttu-id="0e31f-128">**互換性に影響する変更なし**ものに影響するソリューションの重要な制約は、契約を入力するか重大な変更がなければ、マイナー リリースまたは動作をこの機能が追加されているためです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="0e31f-129">この制約は、500 の応答に例外にすると、既存の catch ブロックの観点からを実行するよう一部のクリーンアップから除外します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="0e31f-130">この追加のクリーンアップが後続のメジャー リリースのことをお勧めです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="0e31f-131">これは重要な場合くださいにについて投票する[ASP.NET Web API ユーザー音声](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="0e31f-132">**Web API との一貫性を維持する構築**Web API のフィルターのパイプラインは、特定のアクション、コント ローラー固有またはグローバル スコープでロジックを適用する際の柔軟性に横断的関心事に対応する優れた方法です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="0e31f-133">フィルター、例外、フィルターなどのグローバル スコープで登録されている場合でも常にアクションとコント ローラーのコンテキストであります。</span><span class="sxs-lookup"><span data-stu-id="0e31f-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="0e31f-134">コントラクトに適したフィルター、例外フィルターもグローバルにスコープを持つものにいくつかの例外が、アクションまたはコント ローラーのコンテキストがありませんは、メッセージ ハンドラーからの例外など、状況を処理に適していないことを意味が存在します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="0e31f-135">例外処理フィルターで利用可能になる柔軟なスコープを使用したい場合は、例外フィルターお必要があります。</span><span class="sxs-lookup"><span data-stu-id="0e31f-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="0e31f-136">コント ローラー コンテキストの外部での例外を処理する必要がある場合も必要として、別のコンストラクト (何か、コント ローラー コンテキストとアクション コンテキストの制限なし) の完全なグローバル エラー処理のためです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="0e31f-137">使用する場合</span><span class="sxs-lookup"><span data-stu-id="0e31f-137">When to Use</span></span>

- <span data-ttu-id="0e31f-138">例外ロガーは、Web API によってキャッチされたすべての未処理の例外を参照するソリューションです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="0e31f-139">例外ハンドラーは、Web API によってキャッチされた未処理の例外へのすべての可能な応答をカスタマイズするためのソリューションです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="0e31f-140">例外フィルターは、特定のアクションまたはコント ローラーに関連するサブセット未処理の例外を処理する最も簡単なソリューションです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="0e31f-141">サービスの詳細情報</span><span class="sxs-lookup"><span data-stu-id="0e31f-141">Service Details</span></span>

 <span data-ttu-id="0e31f-142">例外ロガーとハンドラー サービス インターフェイスには、単純な非同期メソッドのそれぞれのコンテキストを取得します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="0e31f-143">これらのインターフェイスの両方の基本クラスも提供します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="0e31f-144">ログインするか、推奨される処理に必要なすべてのコア (同期または非同期) メソッドをオーバーライドする時間。</span><span class="sxs-lookup"><span data-stu-id="0e31f-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="0e31f-145">ログ記録、`ExceptionLogger`基底クラスはコア ログ記録のメソッドが呼び出されるようにのみ 1 回例外ごとに (後で反映される場合でもさらに、呼び出し履歴の最大および再度でキャッチされます)。</span><span class="sxs-lookup"><span data-stu-id="0e31f-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="0e31f-146">`ExceptionHandler`基底クラスが入れ子になったレガシを無視して、コール スタックの上部にある例外 catch ブロックにのみ、メソッドを処理コアを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="0e31f-147">(これらの基本クラスの簡素化されたバージョンは、後述の付録では) です。両方`IExceptionLogger`と`IExceptionHandler`経由で例外に関する情報が表示される、`ExceptionContext`です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="0e31f-148">常に提供するために、フレームワークの例外ロガーまたは例外ハンドラーは、呼び出すとき、`Exception`と`Request`です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="0e31f-149">単体テストを除いて常に提供する、`RequestContext`です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="0e31f-150">提供することはほとんどありません、`ControllerContext`と`ActionContext`(例外フィルターの catch ブロックからの呼び出し) の場合のみです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="0e31f-151">非常にまれを提供する、 `Response`(ときの途中で、応答を書き込もうとしている IIS 場合) でのみです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="0e31f-152">これらのプロパティのいくつかありますので注意してください`null`をチェックするコンシューマーの責任です`null`例外クラスのメンバーにアクセスする前にします。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="0e31f-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="0e31f-153">catch ブロックが例外を説明を示す文字列です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="0e31f-154">Catch ブロックの文字列は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="0e31f-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="0e31f-155">HttpServer (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="0e31f-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="0e31f-156">HttpControllerDispatcher (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="0e31f-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="0e31f-157">HttpBatchHandler (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="0e31f-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="0e31f-158">IExceptionFilter (ExecuteAsync 例外フィルター パイプラインの ApiController の処理)</span><span class="sxs-lookup"><span data-stu-id="0e31f-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="0e31f-159">OWIN ホスト:</span><span class="sxs-lookup"><span data-stu-id="0e31f-159">OWIN host:</span></span>

    - <span data-ttu-id="0e31f-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span><span class="sxs-lookup"><span data-stu-id="0e31f-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="0e31f-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span><span class="sxs-lookup"><span data-stu-id="0e31f-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="0e31f-162">Web ホスト:</span><span class="sxs-lookup"><span data-stu-id="0e31f-162">Web host:</span></span>

    - <span data-ttu-id="0e31f-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span><span class="sxs-lookup"><span data-stu-id="0e31f-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="0e31f-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span><span class="sxs-lookup"><span data-stu-id="0e31f-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="0e31f-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span><span class="sxs-lookup"><span data-stu-id="0e31f-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="0e31f-166">Catch ブロックの文字列のリストも静的読み取り専用プロパティを使用して使用できます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="0e31f-167">(静的 ExceptionCatchBlocks には、コアの catch ブロックの文字列は以外の場合は 1 つ静的クラスの各 OWIN と web ホストの残りの部分が表示されます)。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="0e31f-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="0e31f-168">呼び出しスタックの一番上でのみ例外処理の推奨のパターンに従うにとって便利です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="0e31f-169">入れ子になった catch ブロックで発生した任意の場所 500 の応答に例外を有効ではなく、例外ハンドラーにホストで認識されるに約されるまで反映されるまで例外ことができます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="0e31f-170">加え、 `ExceptionContext`、ロガー取得完全経由で情報のもう 1 つのピース`ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="0e31f-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="0e31f-171">2 番目のプロパティでは、 `CanBeHandled`、により、処理できない例外を識別するロガー。</span><span class="sxs-lookup"><span data-stu-id="0e31f-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="0e31f-172">ときに、接続は中止されますと新しい応答メッセージを送信できません、ロガーが呼び出されますが、ハンドラーが***いない***呼び出される、ロガーはこのプロパティからは、このシナリオを特定できます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="0e31f-173">追加する、 `ExceptionContext`、ハンドラーが完全に設定できます 1 つの複数のプロパティを取得`ExceptionHandlerContext`例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="0e31f-174">例外ハンドラーを設定して例外を処理したことを示します、`Result`アクションの結果をプロパティ (たとえば、 [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)、 [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)、 [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)、またはカスタムの結果)。</span><span class="sxs-lookup"><span data-stu-id="0e31f-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="0e31f-175">場合、`Result`プロパティが null で、例外が処理されないと、元の例外が再度スローされます。</span><span class="sxs-lookup"><span data-stu-id="0e31f-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="0e31f-176">コール スタックの上部にある例外の特別な手順で API の呼び出し元に対して適切な応答をように作成しました。</span><span class="sxs-lookup"><span data-stu-id="0e31f-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="0e31f-177">例外は、ホストまで伝達する場合は、呼び出し元は死亡の黄色の画面を参照してくださいまたはその他のホストには、応答は通常、HTML と通常は適切な API エラー応答が提供されています。</span><span class="sxs-lookup"><span data-stu-id="0e31f-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="0e31f-178">このような場合は、null 以外の場合と、カスタムの例外ハンドラーが明示的に設定する場合にだけ、結果が開始されるバックアップを作成する`null`(未処理の) は、例外ホストに伝達します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="0e31f-179">設定`Result`に`null`このような場合に利用できます 2 つのシナリオ。</span><span class="sxs-lookup"><span data-stu-id="0e31f-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="0e31f-180">OWIN には、カスタム例外処理前に、/外部 Web API を登録するミドルウェアを Web API がホストされています。</span><span class="sxs-lookup"><span data-stu-id="0e31f-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="0e31f-181">ローカル ブラウザー経由でのデバッグ、死亡の黄色の画面は未処理の例外の応答を実際には便利です。</span><span class="sxs-lookup"><span data-stu-id="0e31f-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="0e31f-182">例外ロガーと例外ハンドラーの両方で何もしませんロガーやハンドラー自体は、例外をスローした場合に回復します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="0e31f-183">(例外を伝達、場合に、このページの下部にあるフィードバックを送信できるようにすること以外がある場合より適切な方法です。)例外ロガーやハンドラーのコントラクトは、それらにならないように伝達; 呼び出し元の例外それ以外の場合、例外はだけ、多くの場合、一番ホストに伝達する (ASP のようなエラーが HTML の発生しました。NET の黄色の画面) (JSON または XML を期待する API の呼び出し元に対して推奨されるオプションは通常ありません) をクライアントに送信されています。</span><span class="sxs-lookup"><span data-stu-id="0e31f-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="0e31f-184">使用例</span><span class="sxs-lookup"><span data-stu-id="0e31f-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="0e31f-185">トレースの例外ロガー</span><span class="sxs-lookup"><span data-stu-id="0e31f-185">Tracing Exception Logger</span></span>

<span data-ttu-id="0e31f-186">例外データを送信する (Visual Studio でのデバッグ出力ウィンドウを含む) 構成済みのトレース ソースに以下の例外ロガー。</span><span class="sxs-lookup"><span data-stu-id="0e31f-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="0e31f-187">カスタム エラー メッセージの例外ハンドラー</span><span class="sxs-lookup"><span data-stu-id="0e31f-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="0e31f-188">次は、サポートに連絡用電子メール アドレスを含む、クライアントへのカスタム エラー応答を生成します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="0e31f-189">例外フィルターを登録します。</span><span class="sxs-lookup"><span data-stu-id="0e31f-189">Registering Exception Filters</span></span>

<span data-ttu-id="0e31f-190">「ASP.NET MVC 4 Web アプリケーション」のプロジェクト テンプレートを使用して、プロジェクトを作成する場合は、コードを記述して Web API 構成中、`WebApiConfig`クラスで、*アプリ/_Start*フォルダー。</span><span class="sxs-lookup"><span data-stu-id="0e31f-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="0e31f-191">付録: 基底クラスの詳細</span><span class="sxs-lookup"><span data-stu-id="0e31f-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
