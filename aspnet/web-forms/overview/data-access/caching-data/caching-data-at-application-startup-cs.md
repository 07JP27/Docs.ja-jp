---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: (C#) アプリケーションの起動時にデータのキャッシュ |Microsoft ドキュメント
author: rick-anderson
description: 一部のデータが頻繁に使用する Web アプリケーションでと、一部のデータを頻繁に使用されます。 この ASP.NET アプリケーション b のパフォーマンス機能を向上させる.
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: 8d962a182b5136d3e44ce678a355c9679b4c8be1
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2018
---
<a name="caching-data-at-application-startup-c"></a><span data-ttu-id="7201f-104">(C#) アプリケーションの起動時にデータのキャッシュ</span><span class="sxs-lookup"><span data-stu-id="7201f-104">Caching Data at Application Startup (C#)</span></span>
====================
<span data-ttu-id="7201f-105">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="7201f-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="7201f-106">PDF をダウンロードします。</span><span class="sxs-lookup"><span data-stu-id="7201f-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="7201f-107">一部のデータが頻繁に使用する Web アプリケーションでと、一部のデータを頻繁に使用されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="7201f-108">ASP.NET アプリケーションのパフォーマンスを向上させる、頻繁に使用されるデータと呼ばれる手法を事前に読み込むことによりおことができます。</span><span class="sxs-lookup"><span data-stu-id="7201f-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as.</span></span> <span data-ttu-id="7201f-109">このチュートリアルでは、プロアクティブなを読み込み、これはアプリケーションの起動時に、キャッシュにデータを読み込む方法の 1 つを示します。</span><span class="sxs-lookup"><span data-stu-id="7201f-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>


## <a name="introduction"></a><span data-ttu-id="7201f-110">はじめに</span><span class="sxs-lookup"><span data-stu-id="7201f-110">Introduction</span></span>

<span data-ttu-id="7201f-111">2 つの前のチュートリアルは、プレゼンテーション層と層のキャッシュ内のデータをキャッシュに検査します。</span><span class="sxs-lookup"><span data-stu-id="7201f-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="7201f-112">[、ObjectDataSource でデータをキャッシュ](caching-data-with-the-objectdatasource-cs.md)ObjectDataSource s キャッシュ プレゼンテーション層でデータをキャッシュする機能を使用してきました。</span><span class="sxs-lookup"><span data-stu-id="7201f-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource s caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="7201f-113">[アーキテクチャのデータ キャッシュ](caching-data-in-the-architecture-cs.md)新しい、個別のキャッシュ層でキャッシュを確認します。</span><span class="sxs-lookup"><span data-stu-id="7201f-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="7201f-114">これらのチュートリアルのために使用両方*事後対応型の読み込み*データ キャッシュを使用して操作するためにします。</span><span class="sxs-lookup"><span data-stu-id="7201f-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="7201f-115">事後対応型の読み込み、データが要求されるたびに、システム最初に確認を行う場合、キャッシュで s。</span><span class="sxs-lookup"><span data-stu-id="7201f-115">With reactive loading, each time the data is requested, the system first checks if it s in the cache.</span></span> <span data-ttu-id="7201f-116">以外の場合、データベースなど、元のソースからデータを取得してキャッシュに格納しておく。</span><span class="sxs-lookup"><span data-stu-id="7201f-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="7201f-117">事後対応型の読み込みを主な利点は、簡単に実装します。</span><span class="sxs-lookup"><span data-stu-id="7201f-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="7201f-118">不均一なパフォーマンスは、要求間での欠点の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="7201f-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="7201f-119">前のチュートリアルからキャッシュ レイヤーを使用して製品情報を表示するページを想像してください。</span><span class="sxs-lookup"><span data-stu-id="7201f-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="7201f-120">このページが初めて、閲覧またはメモリの制約または指定した有効期限に到達したことにより、キャッシュされたデータが削除された後に初めてアクセスした、ときに、データベースからデータを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="7201f-121">そのため、キャッシュによってこれらのユーザー要求を処理可能なユーザー要求よりも長くかかります。</span><span class="sxs-lookup"><span data-stu-id="7201f-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="7201f-122">*プロアクティブな読み込み*のために必要な前にキャッシュされたデータを読み込むことにより要求間で代替のキャッシュ管理戦略パフォーマンスをその平滑化を提供します。</span><span class="sxs-lookup"><span data-stu-id="7201f-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it s needed.</span></span> <span data-ttu-id="7201f-123">通常、プロアクティブな読み込みは、定期的にチェック、またはを基になるデータへの更新されたときに通知がいくつかのプロセスを使用します。</span><span class="sxs-lookup"><span data-stu-id="7201f-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="7201f-124">このプロセスは、その状態に保つにキャッシュを更新します。</span><span class="sxs-lookup"><span data-stu-id="7201f-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="7201f-125">事前対応型の読み込みが低速のデータベース接続、Web サービス、または他の動作が遅く特にデータ ソースから基になるデータが送られた場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="7201f-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="7201f-126">事前読み込みするには、この方法は、作成、管理、および変更を確認し、キャッシュを更新するためのプロセスを展開する必要がありますを実装するのには困難です。</span><span class="sxs-lookup"><span data-stu-id="7201f-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="7201f-127">プロアクティブを読み込み、およびおは、このチュートリアルでは探索を種類別のフレーバーでは、アプリケーションの起動時にキャッシュにデータを読み込んでいます。</span><span class="sxs-lookup"><span data-stu-id="7201f-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="7201f-128">この方法は、データベースのルックアップ テーブル内のレコードなどの静的データをキャッシュに特に便利です。</span><span class="sxs-lookup"><span data-stu-id="7201f-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="7201f-129">主体的および対応を読み込み、さらに長所と短所、および実装に関する推奨事項の一覧の相違点の詳細についてを参照してください、 [、キャッシュの内容を管理する](https://msdn.microsoft.com/library/ms978503.aspx)のセクションで、 [キャッシュは、.NET Framework アプリケーションのアーキテクチャ ガイド](https://msdn.microsoft.com/library/ms978498.aspx)です。</span><span class="sxs-lookup"><span data-stu-id="7201f-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="7201f-130">手順 1: アプリケーションの起動時にキャッシュするデータの種類を決定します。</span><span class="sxs-lookup"><span data-stu-id="7201f-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="7201f-131">生成するデータを定期的に変更し、長い exorbitantly 受け取らないで前の 2 つのチュートリアル作業に検査お事後対応型の読み込みを使用してキャッシュの例。</span><span class="sxs-lookup"><span data-stu-id="7201f-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="7201f-132">事後対応型の読み込みで使用される有効期限が不要な場合は、キャッシュされたデータを決して変更しません。</span><span class="sxs-lookup"><span data-stu-id="7201f-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="7201f-133">同様に、キャッシュされるデータに生成する極端に時間がある場合は、パラメーターは、それらのユーザー要求は検索に時間がかかる待機中、基になるデータに置いておくキャッシュを空になりますが取得されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="7201f-134">静的データとアプリケーションの起動時に生成する非常に長い時間がかかるデータ キャッシュを検討してください。</span><span class="sxs-lookup"><span data-stu-id="7201f-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="7201f-135">データベースがある多数のダイナミック、頻繁に変化する値、最ももことは、相当量の静的データです。</span><span class="sxs-lookup"><span data-stu-id="7201f-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="7201f-136">たとえば、ほぼすべてのデータ モデルでは、選択肢の固定セットから特定の値を含む 1 つまたは複数の列があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="7201f-137">A`Patients`データベース テーブルがあります、`PrimaryLanguage`列を持つ一連の値は、英語、スペイン語、フランス語、ロシア語、日本語、およびに可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="7201f-138">多くの場合、このような列を使用して実装*ルックアップ テーブル*です。</span><span class="sxs-lookup"><span data-stu-id="7201f-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="7201f-139">英語またはフランス語での文字列を格納するのではなく、`Patients`テーブル、2 番目のテーブルが作成を持つ、一般的には、それぞれの値のレコードと 2 つの列の一意の識別子と文字列による説明。</span><span class="sxs-lookup"><span data-stu-id="7201f-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="7201f-140">`PrimaryLanguage`内の列、`Patients`テーブルが参照テーブルに対応する一意識別子を格納します。</span><span class="sxs-lookup"><span data-stu-id="7201f-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="7201f-141">図 1 の患者 John doe さん s の第一言語は英語、Ed Johnson s はロシア語です。</span><span class="sxs-lookup"><span data-stu-id="7201f-141">In Figure 1, patient John Doe s primary language is English, while Ed Johnson s is Russian.</span></span>


![言語の表は、Patients テーブルで使用される参照テーブルです。](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="7201f-143">**図 1**:`Languages`テーブルは、ルックアップ テーブルで使用される、`Patients`テーブル</span><span class="sxs-lookup"><span data-stu-id="7201f-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>


<span data-ttu-id="7201f-144">内のレコードによって設定可能な言語のドロップダウン リストには編集または新しい患者を作成するためのユーザー インターフェイスが含まれます、`Languages`テーブル。</span><span class="sxs-lookup"><span data-stu-id="7201f-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="7201f-145">このインターフェイスは、毎回キャッシュを使用しない、システムがアクセスしたクエリを実行する必要があります、`Languages`テーブル。</span><span class="sxs-lookup"><span data-stu-id="7201f-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="7201f-146">これは無駄と不要なので、非常にまれに、参照テーブルの値を変更ことです。</span><span class="sxs-lookup"><span data-stu-id="7201f-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="7201f-147">キャッシュは、`Languages`前のチュートリアルで確認事後対応型の読み込みと同じ手法を使用してデータをします。</span><span class="sxs-lookup"><span data-stu-id="7201f-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="7201f-148">事後対応型の読み込み、ただし、静的なルックアップ テーブルのデータの不要な時間ベースの期限を使用します。</span><span class="sxs-lookup"><span data-stu-id="7201f-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="7201f-149">事後対応型の読み込みを使用するキャッシュは、キャッシュなしでよりも高くなりますが、中に最善の方法は能動的に、参照テーブルにデータを読み込む、キャッシュ アプリケーションの起動時になります。</span><span class="sxs-lookup"><span data-stu-id="7201f-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="7201f-150">このチュートリアルでは、ルックアップ テーブルのデータをキャッシュし、その他の静的な情報をする方法について取り上げます。</span><span class="sxs-lookup"><span data-stu-id="7201f-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="7201f-151">手順 2: データをキャッシュするさまざまな方法を確認します。</span><span class="sxs-lookup"><span data-stu-id="7201f-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="7201f-152">情報は、さまざまな方法を使用して ASP.NET アプリケーションでプログラムによってキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="7201f-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="7201f-153">お ve 既に前のチュートリアルで、データ キャッシュを使用する方法を説明します。</span><span class="sxs-lookup"><span data-stu-id="7201f-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="7201f-154">または、オブジェクトできるプログラムでキャッシュを使用して*静的メンバー*または*アプリケーション状態*です。</span><span class="sxs-lookup"><span data-stu-id="7201f-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="7201f-155">クラスを使用するときに通常クラス必要があります最初にインスタンス化前に、そのメンバーにアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="7201f-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="7201f-156">たとえば、当社のビジネス ロジック層内のクラスのいずれかのメソッドを呼び出す必要があります最初インスタンスを作成クラスの。</span><span class="sxs-lookup"><span data-stu-id="7201f-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="7201f-157">呼び出すことができます前に*SomeMethod*または使用*SomeProperty*、最初にクラスを使用して、インスタンスを作成する必要があります、`new`キーワード。</span><span class="sxs-lookup"><span data-stu-id="7201f-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="7201f-158">*SomeMethod*と*SomeProperty*特定のインスタンスに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="7201f-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="7201f-159">これらのメンバーの有効期間は、それらの関連オブジェクトの有効期間に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="7201f-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="7201f-160">*静的メンバー*、変数、プロパティ、および間で共有される方法は、その一方で、*すべて*クラスのインスタンスと、その結果、クラスと同じ長さの有効期間があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="7201f-161">静的メンバーが、キーワードで表される`static`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="7201f-162">静的メンバーに加えアプリケーション状態を使用してデータをキャッシュできます。</span><span class="sxs-lookup"><span data-stu-id="7201f-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="7201f-163">各 ASP.NET アプリケーションでは、すべてのユーザーとアプリケーションのページ間で共有される s 名前/値のコレクションを保持します。</span><span class="sxs-lookup"><span data-stu-id="7201f-163">Each ASP.NET application maintains a name/value collection that s shared across all users and pages of the application.</span></span> <span data-ttu-id="7201f-164">使用してこのコレクションにアクセスできる、 [ `HttpContext`クラス](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)s [ `Application`プロパティ](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)、ASP.NET ページの分離コード クラスを使用して次のようにします。</span><span class="sxs-lookup"><span data-stu-id="7201f-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page s code-behind class like so:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="7201f-165">データ キャッシュは、時間および依存関係に基づく切れ、キャッシュ項目の優先度などのメカニズムを提供するデータのキャッシュの多くの豊富な API を提供します。</span><span class="sxs-lookup"><span data-stu-id="7201f-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="7201f-166">静的メンバーとアプリケーションの状態、ページの開発者によってこのような機能が手動で追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="7201f-167">アプリケーションの有効期間中にアプリケーションの起動時にデータをキャッシュする場合は、データ キャッシュの利点が行われます。</span><span class="sxs-lookup"><span data-stu-id="7201f-167">When caching data at application startup for the lifetime of the application, however, the data cache s advantages are moot.</span></span> <span data-ttu-id="7201f-168">このチュートリアルでは、静的データのキャッシュのすべての 3 つの手法を使用するコードを紹介します。</span><span class="sxs-lookup"><span data-stu-id="7201f-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="7201f-169">手順 3: キャッシュ、`Suppliers`テーブル データ</span><span class="sxs-lookup"><span data-stu-id="7201f-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="7201f-170">データベース テーブル日付を実装したら、Northwind は、従来のルックアップ テーブルを含めないでください。</span><span class="sxs-lookup"><span data-stu-id="7201f-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="7201f-171">次の 4 つのデータ テーブルとして実装された、DAL は静的でない値がすべてのモデル テーブルです。</span><span class="sxs-lookup"><span data-stu-id="7201f-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="7201f-172">DAL とし、新しいクラスと、BLL をメソッドに、新しい DataTable を追加する時間を費やすのではなくこのチュートリアルでは s をだけ使用できますのふりを`Suppliers`テーブル %s のデータは静的です。</span><span class="sxs-lookup"><span data-stu-id="7201f-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let s just pretend that the `Suppliers` table s data is static.</span></span> <span data-ttu-id="7201f-173">そのため、アプリケーションの起動時にこのデータをキャッシュする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="7201f-174">開始するには、という名前の新しいクラスを作成`StaticCache.cs`で、`CL`フォルダーです。</span><span class="sxs-lookup"><span data-stu-id="7201f-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>


![CL フォルダーに StaticCache.cs クラスを作成します。](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="7201f-176">**図 2**: 作成、`StaticCache.cs`クラス内で、`CL`フォルダー</span><span class="sxs-lookup"><span data-stu-id="7201f-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>


<span data-ttu-id="7201f-177">このキャッシュからデータを返すメソッドと同様に、適切なキャッシュ ストアに起動時にデータを読み込むメソッドを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="7201f-178">上記の例では、静的メンバー変数、`suppliers`からの結果を保持するために、`SuppliersBLL`クラス s`GetSuppliers()`から呼び出されるメソッド、`LoadStaticCache()`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7201f-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class s `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="7201f-179">`LoadStaticCache()`メソッドは、まず、アプリケーションの中に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-179">The `LoadStaticCache()` method is meant to be called during the application s start.</span></span> <span data-ttu-id="7201f-180">このデータはアプリケーションの起動時に読み込まれると、仕入先データを使用する必要がある任意のページを呼び出すことができます、`StaticCache`クラスの`GetSuppliers()`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7201f-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class s `GetSuppliers()` method.</span></span> <span data-ttu-id="7201f-181">したがって、仕入先を取得するデータベースへの呼び出しのみアプリケーションの起動時に 1 回は発生します。</span><span class="sxs-lookup"><span data-stu-id="7201f-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="7201f-182">静的メンバー変数を使用して、キャッシュ ストアとしてではなくまたはを使用アプリケーションの状態や、データ キャッシュします。</span><span class="sxs-lookup"><span data-stu-id="7201f-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="7201f-183">次のコードでは、アプリケーションの状態を使用するによるクラスを示します。</span><span class="sxs-lookup"><span data-stu-id="7201f-183">The following code shows the class retooled to use application state:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="7201f-184">`LoadStaticCache()`、仕入先の情報が、アプリケーション変数に格納されている*キー*です。</span><span class="sxs-lookup"><span data-stu-id="7201f-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="7201f-185">適切な型として返されます (`Northwind.SuppliersDataTable`) から`GetSuppliers()`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-185">It s returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="7201f-186">アプリケーションの状態を使用して ASP.NET ページの分離コード クラスでアクセスできるときに`Application["key"]`、使用する必要があります、アーキテクチャの`HttpContext.Current.Application["key"]`現在を取得するために`HttpContext`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="7201f-187">同様に、データ キャッシュは、次のコードに示すように、キャッシュ ストアとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="7201f-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>


[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="7201f-188">時間ベース期限を指定しないと、データ キャッシュにアイテムを追加するには、使用、`System.Web.Caching.Cache.NoAbsoluteExpiration`と`System.Web.Caching.Cache.NoSlidingExpiration`入力パラメーターとして値。</span><span class="sxs-lookup"><span data-stu-id="7201f-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="7201f-189">データ キャッシュ s のこの特定のオーバー ロード`Insert`メソッドがオンにして指定できます、*優先度*キャッシュ項目の。</span><span class="sxs-lookup"><span data-stu-id="7201f-189">This particular overload of the data cache s `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="7201f-190">優先順位を使用して、使用可能なメモリが不足しているときに、キャッシュから清掃を行うには、どのような項目を決定します。</span><span class="sxs-lookup"><span data-stu-id="7201f-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="7201f-191">ここで、優先度使用`NotRemovable`、清掃このキャッシュ項目に t が勝利したことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-191">Here we use the priority `NotRemovable`, which ensures that this cache item won t be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="7201f-192">このチュートリアルのダウンロードを実装して、`StaticCache`クラスの静的メンバー変数の方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="7201f-192">This tutorial s download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="7201f-193">アプリケーションの状態とデータのキャッシュ方法のコードは、クラス ファイル内のコメントで使用できます。</span><span class="sxs-lookup"><span data-stu-id="7201f-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>


## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="7201f-194">手順 4: アプリケーションの起動時にコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="7201f-195">Web アプリケーションが初めて起動したときに、コードを実行する必要がありますをという名前の特殊なファイルを作成する`Global.asax`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="7201f-196">このファイルは、アプリケーションで、セッションでのイベント ハンドラーを含めることができ、要求レベルのイベント、およびそれがここで、アプリケーションが開始されるたびに実行されるコードを追加できます。</span><span class="sxs-lookup"><span data-stu-id="7201f-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="7201f-197">追加、`Global.asax`を Visual Studio のソリューション エクスプ ローラーで web サイト プロジェクト名を右クリックし、[新しい項目の追加] を選択して web アプリケーションのルート ディレクトリのファイルです。</span><span class="sxs-lookup"><span data-stu-id="7201f-197">Add the `Global.asax` file to your web application s root directory by right-clicking on the website project name in Visual Studio s Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="7201f-198">[新しい項目の追加] ダイアログ ボックスからグローバル アプリケーション クラス項目の種類を選択し、[追加] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="7201f-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="7201f-199">既に存在する場合、`Global.asax`プロジェクト、項目の種類は、新しい項目の追加 ダイアログ ボックスは表示されませんグローバル アプリケーション クラス内のファイルです。</span><span class="sxs-lookup"><span data-stu-id="7201f-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>


<span data-ttu-id="7201f-200">[![Global.asax ファイルを Web アプリケーションのルート ディレクトリに追加します。](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="7201f-200">[![Add the Global.asax File to Your Web Application s Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="7201f-201">**図 3**: 追加、 `Global.asax` Web アプリケーション ルート ディレクトリにファイル ([フルサイズのイメージを表示するをクリックして](caching-data-at-application-startup-cs/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="7201f-201">**Figure 3**: Add the `Global.asax` File to Your Web Application s Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>


<span data-ttu-id="7201f-202">既定値`Global.asax`ファイル テンプレートには、サーバー側内の 5 つのメソッドが含まれています。`<script>`タグ。</span><span class="sxs-lookup"><span data-stu-id="7201f-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="7201f-203">**`Application_Start`** web アプリケーションを初めて起動したときに実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="7201f-204">**`Application_End`** アプリケーションがシャット ダウン中と実行されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="7201f-205">**`Application_Error`** 未処理の例外がアプリケーションに到達するたびに実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="7201f-206">**`Session_Start`** 新しいセッションが作成されるときに実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="7201f-207">**`Session_End`** セッションが期限切れまたは破棄すると実行されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="7201f-208">`Application_Start`イベント ハンドラーがアプリケーション ライフ サイクル中に 1 回だけ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="7201f-208">The `Application_Start` event handler is called only once during an application s life cycle.</span></span> <span data-ttu-id="7201f-209">アプリケーションの開始と、最初に、ASP.NET のリソースがアプリケーションから要求されたアプリケーションが再起動されるまで実行を続けるの内容を変更することによって発生することができますが、`/Bin`フォルダー、変更`Global.asax`、変更、内容、`App_Code`フォルダー、または変更する、`Web.config`原因は他の間でのファイルです。</span><span class="sxs-lookup"><span data-stu-id="7201f-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="7201f-210">参照してください[ASP.NET アプリケーションのライフ サイクルの概要](https://msdn.microsoft.com/library/ms178473.aspx)詳細についてはアプリケーションのライフ サイクルにします。</span><span class="sxs-lookup"><span data-stu-id="7201f-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="7201f-211">これらのチュートリアルののみいただくためにコードを追加して、`Application_Start`メソッドでは自由に、他のユーザーを削除します。</span><span class="sxs-lookup"><span data-stu-id="7201f-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="7201f-212">`Application_Start`を呼び出すだけで、`StaticCache`クラスの`LoadStaticCache()`は読み込まれて、仕入先の情報をキャッシュするメソッド。</span><span class="sxs-lookup"><span data-stu-id="7201f-212">In `Application_Start`, simply call the `StaticCache` class s `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="7201f-213">すべてが s です!</span><span class="sxs-lookup"><span data-stu-id="7201f-213">That s all there is to it!</span></span> <span data-ttu-id="7201f-214">アプリケーションの起動時に、`LoadStaticCache()`メソッドは、BLL から供給業者の情報を取得し、静的メンバー変数に保存 (でを使用して最終的なキャッシュを格納するか、`StaticCache`クラス)。</span><span class="sxs-lookup"><span data-stu-id="7201f-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="7201f-215">この動作を確認するためにブレークポイントを設定、`Application_Start`メソッドと、アプリケーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="7201f-216">アプリケーションの開始時に、ブレークポイントにヒットすることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="7201f-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="7201f-217">ただし、後続の要求も、実行、`Application_Start`メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="7201f-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>


<span data-ttu-id="7201f-218">[![Application_Start イベント ハンドラーが実行されていることを確認するブレークポイントを使用してください。](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="7201f-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="7201f-219">**図 4**: ことを確認するブレークポイントを使用している、`Application_Start`イベント ハンドラーが実行されている ([フルサイズのイメージを表示するをクリックして](caching-data-at-application-startup-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="7201f-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>


> [!NOTE]
> <span data-ttu-id="7201f-220">ヒットしない場合、`Application_Start`デバッグを開始するときに、ブレークポイントは、アプリケーションが既に開始します。</span><span class="sxs-lookup"><span data-stu-id="7201f-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="7201f-221">強制的に変更することで再起動するアプリケーション、`Global.asax`または`Web.config`ファイルし、し、もう一度やり直してください。</span><span class="sxs-lookup"><span data-stu-id="7201f-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="7201f-222">単に追加 (または削除できます)、これらのファイルをすばやくアプリケーションを再起動する 1 つの最後の空白行です。</span><span class="sxs-lookup"><span data-stu-id="7201f-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>


## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="7201f-223">手順 5: キャッシュされたデータを表示します。</span><span class="sxs-lookup"><span data-stu-id="7201f-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="7201f-224">この時点で、`StaticCache`クラス経由でアクセスできるアプリケーションの起動時にキャッシュされた仕入先データのバージョンには、その`GetSuppliers()`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7201f-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="7201f-225">プレゼンテーション層からこのデータを使用するには、ObjectDataSource を使用またはプログラムによって呼び出すおことができます、`StaticCache`クラスの`GetSuppliers()`ASP.NET ページの分離コード クラスのメソッドです。</span><span class="sxs-lookup"><span data-stu-id="7201f-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class s `GetSuppliers()` method from an ASP.NET page s code-behind class.</span></span> <span data-ttu-id="7201f-226">ObjectDataSource、GridView コントロールを使用して、キャッシュされた仕入先の情報を表示する見て s を使用できます。</span><span class="sxs-lookup"><span data-stu-id="7201f-226">Let s look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="7201f-227">開いて開始、 `AtApplicationStartup.aspx`  ページで、`Caching`フォルダーです。</span><span class="sxs-lookup"><span data-stu-id="7201f-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="7201f-228">GridView を設定、デザイナーには、ツールボックスからドラッグその`ID`プロパティを`Suppliers`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="7201f-229">次に、GridView から s スマート タグを選択してという名前の新しい ObjectDataSource を作成する`SuppliersCachedDataSource`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-229">Next, from the GridView s smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="7201f-230">構成を使用する ObjectDataSource、`StaticCache`クラスの`GetSuppliers()`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="7201f-230">Configure the ObjectDataSource to use the `StaticCache` class s `GetSuppliers()` method.</span></span>


<span data-ttu-id="7201f-231">[![構成、ObjectDataSource StaticCache クラスを使用するには](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="7201f-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="7201f-232">**図 5**: 構成を使用する ObjectDataSource、`StaticCache`クラス ([フルサイズのイメージを表示するをクリックして](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="7201f-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>


<span data-ttu-id="7201f-233">[![GetSuppliers() メソッドを使用して、キャッシュされた仕入先データを取得するには](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="7201f-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="7201f-234">**図 6**: を使用して、`GetSuppliers()`キャッシュ仕入先データを取得する方法 ([フルサイズのイメージを表示するをクリックして](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="7201f-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>


<span data-ttu-id="7201f-235">ウィザードを完了すると、Visual Studio が自動的に追加 BoundFields 内のデータ フィールドの各`SuppliersDataTable`です。</span><span class="sxs-lookup"><span data-stu-id="7201f-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="7201f-236">GridView と ObjectDataSource s 宣言型マークアップは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="7201f-236">Your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="7201f-237">図 7 は、ブラウザーで表示したときに、ページを示します。</span><span class="sxs-lookup"><span data-stu-id="7201f-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="7201f-238">出力は、同じ BLL s からデータをプルおが`SuppliersBLL`クラスを使用して、`StaticCache`クラスは、アプリケーションの起動時にキャッシュされたとして仕入先データを返します。</span><span class="sxs-lookup"><span data-stu-id="7201f-238">The output is the same had we pulled the data from the BLL s `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="7201f-239">ブレークポイントを設定することができます、`StaticCache`クラスの`GetSuppliers()`この動作を確認するメソッド。</span><span class="sxs-lookup"><span data-stu-id="7201f-239">You can set breakpoints in the `StaticCache` class s `GetSuppliers()` method to verify this behavior.</span></span>


<span data-ttu-id="7201f-240">[![GridView に、キャッシュされた仕入先データが表示されます。](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="7201f-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="7201f-241">**図 7**: GridView に、キャッシュされた仕入先データが表示されます ([フルサイズのイメージを表示するをクリックして](caching-data-at-application-startup-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="7201f-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>


## <a name="summary"></a><span data-ttu-id="7201f-242">まとめ</span><span class="sxs-lookup"><span data-stu-id="7201f-242">Summary</span></span>

<span data-ttu-id="7201f-243">すべてのほとんどのデータ モデルには、かなりルックアップ テーブルの形式で実装される通常の静的なデータにはが含まれています。</span><span class="sxs-lookup"><span data-stu-id="7201f-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="7201f-244">この情報は、静的でないの理由もなく継続的にデータベースにアクセスするたびにこの情報を表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7201f-244">Since this information is static, there s no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="7201f-245">さらに、その静的な性質により、データをキャッシュする場合が s、有効期限の必要はありません。</span><span class="sxs-lookup"><span data-stu-id="7201f-245">Furthermore, due to its static nature, when caching the data there s no need for an expiry.</span></span> <span data-ttu-id="7201f-246">このチュートリアルでは、このようなデータを取得し、データ キャッシュ、アプリケーションの状態、および静的メンバー変数を介した、それをキャッシュする方法を説明しました。</span><span class="sxs-lookup"><span data-stu-id="7201f-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="7201f-247">この情報は、アプリケーションの起動時にキャッシュされ、アプリケーション秒の有効期間全体でキャッシュに残ります。</span><span class="sxs-lookup"><span data-stu-id="7201f-247">This information is cached at application startup and remains in the cache throughout the application s lifetime.</span></span>

<span data-ttu-id="7201f-248">このチュートリアルを過去の 2 つのお ve アプリケーション秒の有効期間の間のデータのキャッシュだけでなく切れの時間ベースを使用して説明しました。</span><span class="sxs-lookup"><span data-stu-id="7201f-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application s lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="7201f-249">データベースのデータをキャッシュする場合は、時間ベースの有効期限がより小さい理想的なあります。</span><span class="sxs-lookup"><span data-stu-id="7201f-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="7201f-250">キャッシュを定期的にフラッシュするではなく、基になるデータベースのデータが変更されたときにのみ、キャッシュされた項目を削除する最適ながあります。</span><span class="sxs-lookup"><span data-stu-id="7201f-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="7201f-251">この理想は、[次へ]、チュートリアルについて見ていきましょう SQL キャッシュ依存関係を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="7201f-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="7201f-252">満足プログラミング!</span><span class="sxs-lookup"><span data-stu-id="7201f-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="7201f-253">作成者について</span><span class="sxs-lookup"><span data-stu-id="7201f-253">About the Author</span></span>

<span data-ttu-id="7201f-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックとの創設者の作成者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、1998 年からマイクロソフトの Web テクノロジで取り組んできました。</span><span class="sxs-lookup"><span data-stu-id="7201f-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="7201f-255">Scott は、コンサルタント、トレーナー、ライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="7201f-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="7201f-256">最新の著書[ *Sam 学べる自分で ASP.NET 2.0 が 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)です。</span><span class="sxs-lookup"><span data-stu-id="7201f-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="7201f-257">彼に到達できる[ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)彼のブログを使用して含まれているのか[ http://ScottOnWriting.NET](http://ScottOnWriting.NET)です。</span><span class="sxs-lookup"><span data-stu-id="7201f-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="7201f-258">感謝の特別な</span><span class="sxs-lookup"><span data-stu-id="7201f-258">Special Thanks To</span></span>

<span data-ttu-id="7201f-259">このチュートリアルの系列は既に多くの便利なレビュー担当者によって確認済みです。</span><span class="sxs-lookup"><span data-stu-id="7201f-259">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="7201f-260">このチュートリアルの潜在顧客レビュー担当者は、Teresa マーフィーおよび Zack Jones がいました。</span><span class="sxs-lookup"><span data-stu-id="7201f-260">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="7201f-261">今後、MSDN の記事を確認することに関心のあるですか。</span><span class="sxs-lookup"><span data-stu-id="7201f-261">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="7201f-262">場合は、ドロップ me 一度に 1 行ずつ[mitchell@4GuysFromRolla.comです。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="7201f-262">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="7201f-263">[前へ](caching-data-in-the-architecture-cs.md)
> [次へ](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="7201f-263">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
