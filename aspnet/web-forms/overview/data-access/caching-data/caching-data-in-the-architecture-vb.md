---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: "アーキテクチャ (VB) のデータ キャッシュ |Microsoft ドキュメント"
author: rick-anderson
description: "前のチュートリアルでは、プレゼンテーション層でキャッシュを適用する方法を学習します。 このチュートリアルでは、当社レイヤード architectu を活用する方法を学習しています."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: 1aca89b022bb3bb7e4154ab575b5bb5513144cd5
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/24/2018
---
<a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="1983f-104">アーキテクチャ (VB) でデータのキャッシュ</span><span class="sxs-lookup"><span data-stu-id="1983f-104">Caching Data in the Architecture (VB)</span></span>
====================
<span data-ttu-id="1983f-105">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="1983f-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="1983f-106">[サンプル アプリをダウンロード](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe)または[PDF のダウンロード](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="1983f-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="1983f-107">前のチュートリアルでは、プレゼンテーション層でキャッシュを適用する方法を学習します。</span><span class="sxs-lookup"><span data-stu-id="1983f-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="1983f-108">このチュートリアルでは、利用するために、複数層のアーキテクチャのビジネス ロジック層でデータをキャッシュする方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="1983f-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="1983f-109">キャッシュ レイヤーを含めるアーキテクチャを拡張することによってこの作業を行います。</span><span class="sxs-lookup"><span data-stu-id="1983f-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="1983f-110">はじめに</span><span class="sxs-lookup"><span data-stu-id="1983f-110">Introduction</span></span>

<span data-ttu-id="1983f-111">前のチュートリアルで説明したとおり、ObjectDataSource のデータのキャッシュは、いくつかのプロパティを設定するなどの単純です。</span><span class="sxs-lookup"><span data-stu-id="1983f-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="1983f-112">残念ながら、ASP.NET ページのキャッシュ ポリシーを密に結合するプレゼンテーション層でキャッシュ、ObjectDataSource が適用されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="1983f-113">解除するには、このような couplings を許可する、複数層のアーキテクチャを作成する理由の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="1983f-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="1983f-114">データ アクセス層、データ アクセスの詳細を分離するときに、ビジネス ロジック層はたとえば、ASP.NET ページからビジネス ロジックを切り離します。</span><span class="sxs-lookup"><span data-stu-id="1983f-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="1983f-115">このビジネス ロジックとデータ アクセスの詳細の分離は優先、一部を読みやすく、保守性の向上、および変更をより柔軟なシステムがいるためです。</span><span class="sxs-lookup"><span data-stu-id="1983f-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="1983f-116">ドメインのナレッジとプレゼンテーション層が t の開発者が自分のジョブを実行するために、データベースの詳細について理解しておく必要がある作業分担こともできます。</span><span class="sxs-lookup"><span data-stu-id="1983f-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="1983f-117">キャッシュ ポリシーをプレゼンテーション層から分離することは、同様のメリットを提供します。</span><span class="sxs-lookup"><span data-stu-id="1983f-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="1983f-118">このチュートリアルではこのアーキテクチャによりを補強おは、*キャッシュ レイヤー* (または略して CL) のキャッシュ ポリシーを使用します。</span><span class="sxs-lookup"><span data-stu-id="1983f-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="1983f-119">キャッシュ レイヤーが含まれます、`ProductsCL`などのメソッドに製品情報へのアクセスを提供するクラス`GetProducts()`、`GetProductsByCategoryID(categoryID)`などと、呼び出されるとは、キャッシュからデータを取得する最初の試行に、します。</span><span class="sxs-lookup"><span data-stu-id="1983f-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="1983f-120">これらのメソッドを適切な呼び出しは、キャッシュが空の場合は、 `ProductsBLL` DAL からデータを入手はさらに、BLL 内のメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="1983f-121">`ProductsCL`メソッドが返す前に、BLL から取得されたデータをキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="1983f-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="1983f-122">図 1 に示す、CL は、プレゼンテーション層とビジネス ロジック層との間存在します。</span><span class="sxs-lookup"><span data-stu-id="1983f-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![キャッシュ レイヤー (CL) が別のレイヤーのアーキテクチャ](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="1983f-124">**図 1**:「キャッシュ レイヤー (CL) が別のレイヤーのアーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="1983f-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="1983f-125">手順 1: キャッシュ レイヤー クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="1983f-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="1983f-126">このチュートリアルでは 1 つのクラスを使用して非常に単純な CL を作成、`ProductsCL`メソッドのほんの一部のみを持ちます。</span><span class="sxs-lookup"><span data-stu-id="1983f-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="1983f-127">完全なキャッシュ レイヤー全体のアプリケーションの作成が必要になります作成`CategoriesCL`、 `EmployeesCL`、および`SuppliersCL`クラス、および BLL 内の各データ アクセスまたは変更メソッドのこれらのキャッシュ レイヤーのクラスのメソッドを提供します。</span><span class="sxs-lookup"><span data-stu-id="1983f-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="1983f-128">同様に、BLL および DAL では、キャッシュ レイヤー理想的として実装してください、別のクラス ライブラリ プロジェクトただし、内のクラスとして実装しましたが、`App_Code`フォルダーです。</span><span class="sxs-lookup"><span data-stu-id="1983f-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="1983f-129">Let s に新しいサブフォルダーを作成、DAL および BLL クラスからより多くのクリーンに独立した、CL クラスに、`App_Code`フォルダーです。</span><span class="sxs-lookup"><span data-stu-id="1983f-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="1983f-130">右クリックし、`App_Code`ソリューション エクスプ ローラーでフォルダーが新しいフォルダーを選択し、新しいフォルダーの名前を付けます`CL`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="1983f-131">このフォルダーを作成した後を追加してという名前の新しいクラス`ProductsCL.vb`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>


![CL をという名前の新しいフォルダーと ProductsCL.vb をという名前のクラスを追加します。](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="1983f-133">**図 2**: という名前の新しいフォルダーを追加`CL`とという名前のクラス`ProductsCL.vb`</span><span class="sxs-lookup"><span data-stu-id="1983f-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>


<span data-ttu-id="1983f-134">`ProductsCL`クラスは、対応するビジネス ロジック層クラスにあるデータ アクセスと変更方法の同じセットを含める必要があります (`ProductsBLL`)。</span><span class="sxs-lookup"><span data-stu-id="1983f-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="1983f-135">Let s だけで使用したビルドをここでは、いくつかのパターンを大まかに、CL でこれらのメソッドの作成する代わり。</span><span class="sxs-lookup"><span data-stu-id="1983f-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="1983f-136">具体的には、追加、`GetProducts()`と`GetProductsByCategoryID(categoryID)`手順 3. でメソッドおよび`UpdateProduct`手順 4. でオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="1983f-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="1983f-137">残りを追加する`ProductsCL`メソッドおよび`CategoriesCL`、 `EmployeesCL`、および`SuppliersCL`都合のクラスです。</span><span class="sxs-lookup"><span data-stu-id="1983f-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="1983f-138">手順 2: 読み取りと、データ キャッシュへの書き込み</span><span class="sxs-lookup"><span data-stu-id="1983f-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="1983f-139">前のチュートリアルで内部的に探索機能をキャッシュ ObjectDataSource BLL から取得されたデータを格納するのに ASP.NET データ キャッシュを使用します。</span><span class="sxs-lookup"><span data-stu-id="1983f-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="1983f-140">データ キャッシュもアクセスできますプログラムで ASP.NET ページの分離コード クラスとは、web アプリケーションのアーキテクチャのクラスから。</span><span class="sxs-lookup"><span data-stu-id="1983f-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="1983f-141">読み書き可能なデータ キャッシュにページ s の ASP.NET 分離コード クラスから、するには、次のパターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="1983f-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="1983f-142">[ `Cache`クラス](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)s [ `Insert`メソッド](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)数のオーバー ロードがします。</span><span class="sxs-lookup"><span data-stu-id="1983f-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="1983f-143">`Cache("key") = value``Cache.Insert(key, value)`同意語として使用し、定義済みの有効期限なしの指定したキーを使用して、キャッシュに項目を追加両方です。</span><span class="sxs-lookup"><span data-stu-id="1983f-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="1983f-144">通常は、依存関係、時間ベースの期限切れ、またはその両方として、キャッシュにアイテムを追加するときに、有効期限を指定します。</span><span class="sxs-lookup"><span data-stu-id="1983f-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="1983f-145">その他のいずれかを使用して`Insert`依存関係または時間ベースの有効期限情報を提供するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="1983f-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="1983f-146">最初とを確認する場合は、要求されたデータがキャッシュに、必要な場合は、s メソッドが必要なキャッシュ レイヤーは、そこからそれを返します。</span><span class="sxs-lookup"><span data-stu-id="1983f-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="1983f-147">要求されたデータがキャッシュにない場合は、適切な BLL メソッド呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="1983f-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="1983f-148">その戻り値はキャッシュされ、返される、次のシーケンス図に示すようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1983f-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![場合、キャッシュ レイヤーのメソッドが、キャッシュからデータを返す、s 利用可能](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="1983f-150">**図 3**: 場合、キャッシュ レイヤーのメソッドが、キャッシュからデータを返す、s 利用可能</span><span class="sxs-lookup"><span data-stu-id="1983f-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="1983f-151">図 3 に、シーケンスは、CL のクラスに次のパターンを使用して行われます。</span><span class="sxs-lookup"><span data-stu-id="1983f-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="1983f-152">ここでは、*型*キャッシュに格納されているデータの種類は、`Northwind.ProductsDataTable`などの*キー*キャッシュ アイテムを一意に識別するキーです。</span><span class="sxs-lookup"><span data-stu-id="1983f-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="1983f-153">場合、指定した項目*キー*し、キャッシュに含まれない*インスタンス*なります`Nothing`データが適切な BLL メソッドから取得され、キャッシュに追加します。</span><span class="sxs-lookup"><span data-stu-id="1983f-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="1983f-154">時間によって`Return instance`に達すると、*インスタンス*BLL から取り出したりキャッシュからいずれかと、データへの参照が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1983f-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="1983f-155">キャッシュからデータにアクセスするときに、上記のパターンを使用することを確認します。</span><span class="sxs-lookup"><span data-stu-id="1983f-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="1983f-156">一見すると、それと同等のように検索する次のパターンには、競合状態を導入する微妙な違いが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1983f-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="1983f-157">競合状態は散発的明らかにそれ自体を再現するが困難なためにデバッグが困難です。</span><span class="sxs-lookup"><span data-stu-id="1983f-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="1983f-158">この 2 番目の差を不適切なコード スニペットはではなく、ローカル変数にキャッシュされた項目への参照を格納する、データ キャッシュにアクセス条件ステートメント内で直接*と*で、`Return`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="1983f-159">このコードに達するを想像してください。`Cache("key")`は`Nothing`、その前に、`Return`ステートメントに達すると、システムが削除*キー*キャッシュからです。</span><span class="sxs-lookup"><span data-stu-id="1983f-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="1983f-160">このまれなケースで、コードが返されます`Nothing`予期された型のオブジェクトではなくです。</span><span class="sxs-lookup"><span data-stu-id="1983f-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="1983f-161">データ キャッシュとはスレッド セーフの単純な読み取りまたは書き込みアクセスをスレッドを同期する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="1983f-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="1983f-162">ただし、アトミックである必要がキャッシュ内のデータに対して複数の操作を実行する必要がある場合は、ロック、またはその他のスレッド セーフを確保するメカニズムを実装する責任は。</span><span class="sxs-lookup"><span data-stu-id="1983f-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="1983f-163">参照してください[ASP.NET キャッシュへのアクセスの同期](http://www.ddj.com/184406369)詳細についてはします。</span><span class="sxs-lookup"><span data-stu-id="1983f-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="1983f-164">項目をプログラムによって、データを使用してキャッシュから削除する、 [ `Remove`メソッド](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)次のようにします。</span><span class="sxs-lookup"><span data-stu-id="1983f-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="1983f-165">手順 3: がから製品情報を返す、`ProductsCL`クラス</span><span class="sxs-lookup"><span data-stu-id="1983f-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="1983f-166">このチュートリアル let s から製品情報を返すための 2 つのメソッドを実装するため、`ProductsCL`クラス:`GetProducts()`と`GetProductsByCategoryID(categoryID)`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="1983f-167">使用するような`ProductsBL`ビジネス ロジック層内のクラス、`GetProducts()`メソッド、CL では、すべての製品としてに関する情報を返します、`Northwind.ProductsDataTable`オブジェクト、中に`GetProductsByCategoryID(categoryID)`指定したカテゴリからの製品のすべてを返します。</span><span class="sxs-lookup"><span data-stu-id="1983f-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="1983f-168">次のコード内のメソッドの一部を示しています、`ProductsCL`クラス。</span><span class="sxs-lookup"><span data-stu-id="1983f-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="1983f-169">最初に、注意してください、`DataObject`と`DataObjectMethodAttribute`クラスおよびメソッドに適用される属性です。</span><span class="sxs-lookup"><span data-stu-id="1983f-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="1983f-170">これらの属性は、クラスとメソッドが、ウィザードの手順で表示する必要がありますされるを示す、ObjectDataSource のウィザードに情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="1983f-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="1983f-171">CL クラスとメソッドがプレゼンテーション層で、ObjectDataSource からアクセスされる、ため、デザイン時のエクスペリエンスを強化するためにこれらの属性を追加します。</span><span class="sxs-lookup"><span data-stu-id="1983f-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="1983f-172">参照、[ビジネス ロジック層を作成する](../introduction/creating-a-business-logic-layer-vb.md)チュートリアルこれらの属性とその影響についてより詳細に説明します。</span><span class="sxs-lookup"><span data-stu-id="1983f-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="1983f-173">`GetProducts()`と`GetProductsByCategoryID(categoryID)`メソッドから返されたデータ、`GetCacheItem(key)`メソッドは、ローカルの変数に代入されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="1983f-174">`GetCacheItem(key)`メソッドで、間もなく検証、に基づいて、指定されたキャッシュから特定の項目が返されます*キー*です。</span><span class="sxs-lookup"><span data-stu-id="1983f-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="1983f-175">キャッシュ内でこのようなデータが見つからない場合は、対応するから取得`ProductsBLL`クラス メソッドとを使用してキャッシュに追加し、`AddCacheItem(key, value)`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="1983f-176">`GetCacheItem(key)`と`AddCacheItem(key, value)`メソッド インターフェイスは、それぞれデータ キャッシュ、読み取りおよび書き込み値を使用します。</span><span class="sxs-lookup"><span data-stu-id="1983f-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="1983f-177">`GetCacheItem(key)`メソッドは、2 つのシンプルです。</span><span class="sxs-lookup"><span data-stu-id="1983f-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="1983f-178">渡されたを使用してキャッシュ クラスから単純に、値が返されます*キー*:</span><span class="sxs-lookup"><span data-stu-id="1983f-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="1983f-179">`GetCacheItem(key)`使用しません*キー*呼び出し、代わりに、指定されたように値、`GetCacheKey(key)`を返すメソッド、*キー* ProductsCache-先頭に付加します。</span><span class="sxs-lookup"><span data-stu-id="1983f-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="1983f-180">`MasterCacheKeyArray`、ProductsCache、文字列を保持するもで使用される、`AddCacheItem(key, value)`メソッドをすぐにおわかりのようです。</span><span class="sxs-lookup"><span data-stu-id="1983f-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="1983f-181">ASP.NET ページの分離コード クラスから、データ キャッシュにアクセスする使用、`Page`クラス s [ `Cache`プロパティ](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)のような構文と`Cache("key") = value`手順 2. で説明したように、します。</span><span class="sxs-lookup"><span data-stu-id="1983f-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="1983f-182">アーキテクチャ内のクラスから、データ キャッシュを使ってアクセスできますか`HttpRuntime.Cache`または`HttpContext.Current.Cache`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="1983f-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)のブログ エントリ[HttpRuntime.Cache vs です。HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)でわずかなパフォーマンスを得ることをノート`HttpRuntime`の代わりに`HttpContext.Current`以外の場合はその結果、`ProductsCL`を使用して`HttpRuntime`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="1983f-184">クラス ライブラリ プロジェクトを使用して、アーキテクチャが実装されたかどうかへの参照を追加する必要があります、`System.Web`アセンブリを使用するために、 [ `HttpRuntime` ](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)と[ `HttpContext` ](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)クラス。</span><span class="sxs-lookup"><span data-stu-id="1983f-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="1983f-185">項目は、キャッシュ内で見つからない場合、`ProductsCL`クラス s のメソッドが BLL からデータを取得しを使用してキャッシュに追加する、`AddCacheItem(key, value)`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="1983f-186">追加する*値*キャッシュに 60 秒の時刻の有効期限を使用する次のコードを使用でした。</span><span class="sxs-lookup"><span data-stu-id="1983f-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="1983f-187">`DateTime.Now.AddSeconds(CacheDuration)`将来の中で時間ベースの有効期限が 60 秒を指定[ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)ありませんスライド式有効期限が s を示します。</span><span class="sxs-lookup"><span data-stu-id="1983f-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="1983f-188">この中に`Insert`メソッドのオーバー ロードには絶対両方のパラメーターの入力の有効期限をスライドさせて、提供し、のみ、2 つのいずれか。</span><span class="sxs-lookup"><span data-stu-id="1983f-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="1983f-189">絶対時刻とする時間間隔の両方を指定しようとする場合、`Insert`メソッドがスローされます、`ArgumentException`例外。</span><span class="sxs-lookup"><span data-stu-id="1983f-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="1983f-190">この実装、`AddCacheItem(key, value)`メソッドは現在いくつかの欠点がします。</span><span class="sxs-lookup"><span data-stu-id="1983f-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="1983f-191">対処し、手順 4. でこれらの問題を解決しています。</span><span class="sxs-lookup"><span data-stu-id="1983f-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="1983f-192">手順 4: は、アーキテクチャを変更では、ときに、データ キャッシュを無効になります</span><span class="sxs-lookup"><span data-stu-id="1983f-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="1983f-193">データの取得方法、と共にキャッシュ レイヤーは挿入、更新、およびデータを削除するため、BLL として同じメソッドを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1983f-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="1983f-194">CL のデータの変更方法は、キャッシュされたデータを変更しないでくださいがではなくメソッドを呼び出し、BLL s 対応するデータ変更をし、キャッシュが無効にします。</span><span class="sxs-lookup"><span data-stu-id="1983f-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="1983f-195">これには、そのキャッシュの機能が有効な場合に、ObjectDataSource が適用される同じ動作を前のチュートリアルで説明したとおり、およびその`Insert`、 `Update`、または`Delete`メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="1983f-196">次`UpdateProduct`オーバー ロードは、CL でデータの変更メソッドを実装する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1983f-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="1983f-197">適切なデータ変更のビジネス ロジック層メソッドが呼び出されますが、その応答が返される前に、キャッシュを無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="1983f-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="1983f-198">残念ながら、キャッシュを無効には単純なため、`ProductsCL`クラス s`GetProducts()`と`GetProductsByCategoryID(categoryID)`メソッドの各項目をキャッシュに追加、異なるキーを持つ、`GetProductsByCategoryID(categoryID)`メソッドごとに異なるキャッシュ項目を追加する一意*categoryID*です。</span><span class="sxs-lookup"><span data-stu-id="1983f-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="1983f-199">キャッシュが無効になる、ときに削除する必要があります*すべて*によって追加された項目の`ProductsCL`クラスです。</span><span class="sxs-lookup"><span data-stu-id="1983f-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="1983f-200">これには、関連付けることによって、*依存関係をキャッシュ*でキャッシュに追加された各項目に、`AddCacheItem(key, value)`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="1983f-201">一般に、キャッシュの依存関係は、キャッシュ、ファイル システム、または Microsoft SQL Server データベースからデータをファイルに別のアイテムを指定できます。</span><span class="sxs-lookup"><span data-stu-id="1983f-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="1983f-202">依存関係が変わるかがキャッシュから削除すると、関連付けられているキャッシュ項目は自動的にキャッシュから削除します。</span><span class="sxs-lookup"><span data-stu-id="1983f-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="1983f-203">このチュートリアルでは、キャッシュによって追加されるすべてのアイテムの依存関係をキャッシュとして機能するためには追加の項目を作成する、`ProductsCL`クラスです。</span><span class="sxs-lookup"><span data-stu-id="1983f-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="1983f-204">こうすれば、これらの項目すべて削除できますキャッシュから、キャッシュの依存関係を削除します。</span><span class="sxs-lookup"><span data-stu-id="1983f-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="1983f-205">使用すると、s の更新プログラム、`AddCacheItem(key, value)`メソッドの各項目がこのメソッドで、キャッシュに追加されるように関連付けられて、1 つのキャッシュの依存関係。</span><span class="sxs-lookup"><span data-stu-id="1983f-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="1983f-206">`MasterCacheKeyArray`ProductsCache、単一の値を保持する文字列配列です。</span><span class="sxs-lookup"><span data-stu-id="1983f-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="1983f-207">最初に、キャッシュ項目がキャッシュに追加され、現在の日付と時刻を割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="1983f-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="1983f-208">キャッシュ項目が既に存在する場合は更新されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="1983f-209">次に、キャッシュの依存関係が作成されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="1983f-210">[ `CacheDependency`クラス](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)s のコンス トラクターのオーバー ロードの数が、ここで使用されている 1 つでは、2 つが必要です`String`の入力を配列します。</span><span class="sxs-lookup"><span data-stu-id="1983f-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="1983f-211">1 つ目は、一連の依存関係として使用するファイルを指定します。</span><span class="sxs-lookup"><span data-stu-id="1983f-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="1983f-212">ファイル ベースの依存関係の値を使用する必要ありませんので`Nothing`は最初の入力パラメーターを使用します。</span><span class="sxs-lookup"><span data-stu-id="1983f-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="1983f-213">2 番目の入力パラメーターは、依存関係として使用するキャッシュ キーのセットを指定します。</span><span class="sxs-lookup"><span data-stu-id="1983f-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="1983f-214">ここでは、単一の依存関係を指定して`MasterCacheKeyArray`です。</span><span class="sxs-lookup"><span data-stu-id="1983f-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="1983f-215">`CacheDependency`に渡され、`Insert`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="1983f-216">この変更により`AddCacheItem(key, value)`invaliding、キャッシュは、依存関係を削除するように単純です。</span><span class="sxs-lookup"><span data-stu-id="1983f-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="1983f-217">手順 5: は、プレゼンテーション層から、キャッシュ レイヤーを呼び出す</span><span class="sxs-lookup"><span data-stu-id="1983f-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="1983f-218">データを操作する手法を使用してこれらのチュートリアル全体で検証したキャッシュ レイヤーのクラスとメソッドを使用できます。</span><span class="sxs-lookup"><span data-stu-id="1983f-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="1983f-219">キャッシュされたデータの操作を示すためには、に対する変更を保存、`ProductsCL`クラスを開き、 `FromTheArchitecture.aspx`  ページで、`Caching`フォルダー GridView を追加します。</span><span class="sxs-lookup"><span data-stu-id="1983f-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="1983f-220">GridView s のスマート タグから新しい ObjectDataSource を作成します。</span><span class="sxs-lookup"><span data-stu-id="1983f-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="1983f-221">ウィザードの最初の手順で表示されるはずの`ProductsCL`クラスのドロップダウン リストからオプションのいずれか。</span><span class="sxs-lookup"><span data-stu-id="1983f-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="1983f-222">[![ビジネス オブジェクトのドロップダウン リストで、ProductsCL クラスが含まれています。](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="1983f-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="1983f-223">**図 4**:`ProductsCL`ビジネス オブジェクトのドロップダウン リストにクラスが含まれる ([フルサイズのイメージを表示するをクリックして](caching-data-in-the-architecture-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="1983f-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>


<span data-ttu-id="1983f-224">選択した後`ProductsCL`、[次へ] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="1983f-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="1983f-225">タブで、ドロップダウン リストが 2 つの項目の`GetProducts()`と`GetProductsByCategoryID(categoryID)`し、[更新] タブが唯一の`UpdateProduct`オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="1983f-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="1983f-226">選択、`GetProducts()`メソッドの選択 タブおよび`UpdateProducts`更新 タブをクリックしてからメソッドを完了します。</span><span class="sxs-lookup"><span data-stu-id="1983f-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="1983f-227">[![ドロップダウン リストに ProductsCL クラスのメソッドの一覧します。](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="1983f-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="1983f-228">**図 5**:`ProductsCL`ドロップダウン リストにクラスのメソッドの一覧 ([フルサイズのイメージを表示するをクリックして](caching-data-in-the-architecture-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="1983f-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>


<span data-ttu-id="1983f-229">ウィザードを完了すると、Visual Studio は、ObjectDataSource s を設定`OldValuesParameterFormatString`プロパティを`original_{0}`GridView に適切なフィールドを追加します。</span><span class="sxs-lookup"><span data-stu-id="1983f-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="1983f-230">変更、`OldValuesParameterFormatString`プロパティの既定値に戻す`{0}`、およびページング、並べ替え、および編集をサポートする GridView を構成します。</span><span class="sxs-lookup"><span data-stu-id="1983f-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="1983f-231">以降、 `UploadProducts` CL で使用するオーバー ロードには、編集した製品の名前と価格、これらのフィールドのみが編集できるように、GridView を制限します。</span><span class="sxs-lookup"><span data-stu-id="1983f-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="1983f-232">前のチュートリアルでは、定義したため、フィールドを含める GridView、 `ProductName`、 `CategoryName`、および`UnitPrice`フィールドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="1983f-233">自由書式設定と構造体をレプリケートすることは、宣言、GridView と ObjectDataSource s 場合マークアップは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="1983f-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="1983f-234">この時点で、キャッシュ レイヤーを使用するページがあります。</span><span class="sxs-lookup"><span data-stu-id="1983f-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="1983f-235">アクションでキャッシュを表示するブレークポイントを設定、`ProductsCL`クラス s`GetProducts()`と`UpdateProduct`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="1983f-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="1983f-236">並べ替えとページングのデータを表示するのには、キャッシュから取得したときに、ブラウザーとコードをステップ内のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1983f-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="1983f-237">レコードを更新し、キャッシュを無効にし、データが GridView にバインドし直すときに、BLL から取得は、その結果、ことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="1983f-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="1983f-238">この記事の付属のダウンロードで提供されるキャッシュ レイヤーは完了しません。</span><span class="sxs-lookup"><span data-stu-id="1983f-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="1983f-239">1 つのクラスが含まれている`ProductsCL`、のみに、いくつかのメソッドをスポーツをします。</span><span class="sxs-lookup"><span data-stu-id="1983f-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="1983f-240">1 つの ASP.NET ページのみが、CL を使用してさらに、(`~/Caching/FromTheArchitecture.aspx`) BLL を直接参照他のすべてのユーザーもいます。</span><span class="sxs-lookup"><span data-stu-id="1983f-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="1983f-241">アプリケーションで、CL を使用する場合は、プレゼンテーション層からすべての呼び出しは必要があるを必要とすると、CL CL のクラスに移動し、メソッドは、これらのクラスとプレゼンテーション層によって現在使用 BLL でメソッドについて説明します。</span><span class="sxs-lookup"><span data-stu-id="1983f-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="1983f-242">まとめ</span><span class="sxs-lookup"><span data-stu-id="1983f-242">Summary</span></span>

<span data-ttu-id="1983f-243">キャッシュは、ASP.NET 2.0 の SqlDataSource によるプレゼンテーション層と ObjectDataSource コントロールに適用できる、中に責任を理想的にはキャッシュは、アーキテクチャの別のレイヤーに委任します。</span><span class="sxs-lookup"><span data-stu-id="1983f-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="1983f-244">このチュートリアルでは、プレゼンテーション層とビジネス ロジック層の間にあるキャッシュ レイヤーを作成しました。</span><span class="sxs-lookup"><span data-stu-id="1983f-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="1983f-245">キャッシュ レイヤーは、同じクラスと BLL 内に存在し、プレゼンテーション層から呼び出されるメソッドのセットを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1983f-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="1983f-246">この例と前のチュートリアルでは、探索おキャッシュ レイヤーの例は、発生*事後対応型の読み込み*です。</span><span class="sxs-lookup"><span data-stu-id="1983f-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="1983f-247">事後対応型の読み込みとデータの要求が行われ、キャッシュからそのデータが不足している場合にのみ、データはキャッシュに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="1983f-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="1983f-248">データが*能動的に読み込まれた*をキャッシュに技法にデータを読み込む、キャッシュが実際に必要とせずにします。</span><span class="sxs-lookup"><span data-stu-id="1983f-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="1983f-249">次のチュートリアルでは、キャッシュ アプリケーションの起動時に静的な値を格納する方法について詳しく見てみると、プロアクティブな読み込みの例が表示されます。</span><span class="sxs-lookup"><span data-stu-id="1983f-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="1983f-250">満足プログラミング!</span><span class="sxs-lookup"><span data-stu-id="1983f-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="1983f-251">作成者について</span><span class="sxs-lookup"><span data-stu-id="1983f-251">About the Author</span></span>

<span data-ttu-id="1983f-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックとの創設者の作成者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、1998 年からマイクロソフトの Web テクノロジで取り組んできました。</span><span class="sxs-lookup"><span data-stu-id="1983f-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="1983f-253">Scott は、コンサルタント、トレーナー、ライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="1983f-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="1983f-254">最新の著書[ *Sam 学べる自分で ASP.NET 2.0 が 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)です。</span><span class="sxs-lookup"><span data-stu-id="1983f-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="1983f-255">彼に到達できる[ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)彼のブログを使用して含まれているのか[http://ScottOnWriting.NET](http://ScottOnWriting.NET)です。</span><span class="sxs-lookup"><span data-stu-id="1983f-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="1983f-256">感謝の特別な</span><span class="sxs-lookup"><span data-stu-id="1983f-256">Special Thanks To</span></span>

<span data-ttu-id="1983f-257">このチュートリアルの系列は既に多くの便利なレビュー担当者によって確認済みです。</span><span class="sxs-lookup"><span data-stu-id="1983f-257">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="1983f-258">このチュートリアルのレビュー担当者の潜在顧客が Teresa マーフィーしました。</span><span class="sxs-lookup"><span data-stu-id="1983f-258">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="1983f-259">今後、MSDN の記事を確認することに関心のあるですか。</span><span class="sxs-lookup"><span data-stu-id="1983f-259">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="1983f-260">場合は、ドロップ me 一度に 1 行ずつ[mitchell@4GuysFromRolla.comです。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="1983f-260">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="1983f-261">[前へ](caching-data-with-the-objectdatasource-vb.md)
[次へ](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="1983f-261">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
