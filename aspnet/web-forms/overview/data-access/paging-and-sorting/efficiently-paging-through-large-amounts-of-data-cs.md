---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: 大量のデータ (c#) を効率的にページング |Microsoft ドキュメント
author: rick-anderson
description: 大量のデータ、その基になるデータ ソース コントロール retriev として使用するときに、データのプレゼンテーション コントロールの既定のページング オプションは適していません.
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: ea1fd06f8eb7c53c3e9e7fb10c46974eb2af2acd
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2018
ms.locfileid: "30889658"
---
<a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="6702d-103">効率的に大量のデータ (c#) のページング</span><span class="sxs-lookup"><span data-stu-id="6702d-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>
====================
<span data-ttu-id="6702d-104">によって[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="6702d-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="6702d-105">[サンプル アプリをダウンロード](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe)または[PDF のダウンロード](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="6702d-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="6702d-106">データのプレゼンテーション コントロールの既定のページング オプションは適していません大量のデータを使用するときに、データのサブセットのみが表示される場合でも、その基になるデータ ソース コントロールをすべてのレコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="6702d-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="6702d-107">このような状況で必要がありますにカスタムにページングできます。</span><span class="sxs-lookup"><span data-stu-id="6702d-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="6702d-108">はじめに</span><span class="sxs-lookup"><span data-stu-id="6702d-108">Introduction</span></span>

<span data-ttu-id="6702d-109">前のチュートリアルで説明したように 2 つの方法のいずれかのページングを実装できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="6702d-110">**既定のページング**ページングを有効にするオプションをチェックするだけで実装できるデータ Web コントロールのスマート タグですただし、データのページを表示しているときに、ObjectDataSource を取得*すべて*であっても、レコードの。ページで、それらのサブセットのみが表示されます</span><span class="sxs-lookup"><span data-stu-id="6702d-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="6702d-111">**カスタム ページング**既定のパフォーマンスが向上にユーザーが要求されたデータの特定のページに表示される必要のあるデータベースからレコードだけを取得することによってページングしかし、カスタム ページングは、もう少しの作業を実装するには既定のページングより</span><span class="sxs-lookup"><span data-stu-id="6702d-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="6702d-112">実装だけチェックのチェック ボックスがあり、re 簡単操作のため完了です。</span><span class="sxs-lookup"><span data-stu-id="6702d-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="6702d-113">既定のページングは、魅力的なオプションです。</span><span class="sxs-lookup"><span data-stu-id="6702d-113">default paging is an attractive option.</span></span> <span data-ttu-id="6702d-114">その na ve アプローチのすべてのレコードを取得中では、implausible 場合に、多数の同時ユーザーに十分に大量のデータまたはサイトをページングするとき。</span><span class="sxs-lookup"><span data-stu-id="6702d-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="6702d-115">このような状況では、応答性の高いシステムを提供するためにページングするカスタムにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="6702d-116">カスタム ページングのチャレンジは、データの特定のページに必要なレコードの正確なセットを返すクエリを記述できることです。</span><span class="sxs-lookup"><span data-stu-id="6702d-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="6702d-117">幸いにも、Microsoft SQL Server 2005 が提供 new キーワードの順位付け結果を得るするレコードの適切なサブセットを取得できる効率的にクエリを記述することにより、します。</span><span class="sxs-lookup"><span data-stu-id="6702d-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="6702d-118">このチュートリアルではこの新しい SQL Server 2005 キーワードを使用して GridView コントロールのカスタム ページングを実装する方法が表示されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="6702d-119">カスタム ページングのユーザー インターフェイスと同じである 1 つのページから、[次へ] を使用するステップの既定のページングのカスタム ページングがあります数倍の既定のページングよりも高速です。</span><span class="sxs-lookup"><span data-stu-id="6702d-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="6702d-120">カスタム ページングによって行われる正確なパフォーマンスの向上は、を介してページングされるレコードと、データベース サーバー上に配置されている負荷の合計数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="6702d-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="6702d-121">このチュートリアルの最後にカスタム ページング経由で取得したパフォーマンスの利点を示すいくつかの大まかなメトリックに紹介します。</span><span class="sxs-lookup"><span data-stu-id="6702d-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="6702d-122">手順 1: カスタム ページング プロセスの理解</span><span class="sxs-lookup"><span data-stu-id="6702d-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="6702d-123">データのページングとページに表示される正確なレコードは、要求されているデータのページとページあたりに表示されるレコードの数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="6702d-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="6702d-124">たとえばを想像 81 の製品を複数のページを 1 ページあたり 10 個の製品を表示します。</span><span class="sxs-lookup"><span data-stu-id="6702d-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="6702d-125">最初のページを表示するときに d たい製品 1 ~ 10 です。2 番目のページを表示するときに d お関心がある製品 11 から 20 で。</span><span class="sxs-lookup"><span data-stu-id="6702d-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="6702d-126">取得する必要があるレコードと、ページング インターフェイスの表示方法を規定する 3 つの変数です。</span><span class="sxs-lookup"><span data-stu-id="6702d-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="6702d-127">**開始行インデックス**] ページで表示するデータの最初の行のインデックス。 この [インデックスことができますがページ インデックスのページごとに表示するレコードを乗算することと、1 つ追加することによって計算されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="6702d-128">たとえば、最初のページ (ページ インデックスが 0) の一度にレコード 10 のページング、ときに、開始行インデックスは 0 \* 10 + 1、または 1 です (ページ インデックスは 1) 2 番目のページで、開始行はインデックスが 1 \* 10 + 1。、または 11。</span><span class="sxs-lookup"><span data-stu-id="6702d-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="6702d-129">**最大行数は**ページごとに表示するレコードの最大数。</span><span class="sxs-lookup"><span data-stu-id="6702d-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="6702d-130">この変数は、最後のページのページ サイズよりも返されるレコードの数が少なく場合があるため最大行数と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="6702d-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="6702d-131">たとえば、1 ページあたり 10 81 製品レコード間のページング、ときに 9 番目と最後のページは 1 つのレコードがあります。</span><span class="sxs-lookup"><span data-stu-id="6702d-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="6702d-132">ページで、ただしが現れない行の最大数の値よりも多くのレコードです。</span><span class="sxs-lookup"><span data-stu-id="6702d-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="6702d-133">**合計レコード数**を介してページングされるレコードの合計数。</span><span class="sxs-lookup"><span data-stu-id="6702d-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="6702d-134">この変数は t の特定のページを取得するレコードを決定する必要があるときに、ページング インターフェイスは定められています。</span><span class="sxs-lookup"><span data-stu-id="6702d-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="6702d-135">たとえば、を介してページングされる 81 の製品がある場合は、ページング インターフェイスとページング UI に 9 つのページ番号を表示する認識します。</span><span class="sxs-lookup"><span data-stu-id="6702d-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="6702d-136">既定のページングと行の開始インデックスは、行の最大数は、ページ サイズでは単に ページのインデックスとページのサイズと、1 つの製品として計算されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="6702d-137">既定のページングを取得、すべてのレコードからので簡単なタスクの開始行のインデックス行に移動し、それによってデータ、行ごとに、インデックスの任意のページを表示するときに、データベースが呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="6702d-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="6702d-138">さらに、レコードの総数はので、すぐに使用できる s DataTable (または、どのオブジェクトがデータベースの結果を保持するために使用されている) のレコードの数だけです。</span><span class="sxs-lookup"><span data-stu-id="6702d-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="6702d-139">開始行のインデックスと行の最大数の変数を指定するには、カスタム ページングの実装ではその後の行の開始インデックス位置と、レコード数の最大行数は最大の開始レコードの正確なサブセットを返すこと必要がありますのみです。</span><span class="sxs-lookup"><span data-stu-id="6702d-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="6702d-140">カスタム ページングには、2 つの課題が用意されています。</span><span class="sxs-lookup"><span data-stu-id="6702d-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="6702d-141">効率的に行のインデックスを指定した開始行のインデックスにあるレコードを返すお開始できるようにを介してページングされるデータ全体の行ごとに関連付けることができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="6702d-142">を通じてページングされるレコードの合計数を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="6702d-143">次の 2 つの手順でこれら 2 つの課題に対処するために必要な SQL スクリプトについて確認します。</span><span class="sxs-lookup"><span data-stu-id="6702d-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="6702d-144">SQL スクリプトだけでなくも必要になります、DAL と BLL でメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="6702d-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="6702d-145">手順 2: を介してページングされるレコードの合計数を返す</span><span class="sxs-lookup"><span data-stu-id="6702d-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="6702d-146">表示されているページのレコードの正確なサブセットを取得する方法を説明する前に、最初からページングされるレコードの合計数を返す方法を見て s を使用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="6702d-147">この情報が正しくページングのユーザー インターフェイスを構成するために必要です。</span><span class="sxs-lookup"><span data-stu-id="6702d-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="6702d-148">使用して、特定の SQL クエリによって返されるレコードの合計数を取得できます、 [ `COUNT`集計関数](https://msdn.microsoft.com/library/ms175997.aspx)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="6702d-149">たとえば、内のレコードの合計数を決定するため、`Products`テーブル、次のクエリを使用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="6702d-150">この情報を返す、DAL にメソッドを追加 s を使用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="6702d-151">具体的には、DAL メソッドを作成`TotalNumberOfProducts()`を実行する、`SELECT`上に示したステートメントです。</span><span class="sxs-lookup"><span data-stu-id="6702d-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="6702d-152">開いて開始、`Northwind.xsd`に型指定されたデータセット ファイル、`App_Code/DAL`フォルダーです。</span><span class="sxs-lookup"><span data-stu-id="6702d-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="6702d-153">次を右クリックし、`ProductsTableAdapter`デザイナーでクエリの追加を選択します。</span><span class="sxs-lookup"><span data-stu-id="6702d-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="6702d-154">おとして前のチュートリアルで見てきましたこれにより、DAL に新しいメソッドを追加する、呼び出されると、特定の SQL ステートメントまたはストアド プロシージャを実行します。</span><span class="sxs-lookup"><span data-stu-id="6702d-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="6702d-155">同様に、TableAdapter には、前のチュートリアルでのメソッドが、このいずれかのアドホック SQL ステートメントを使用してを選択します。</span><span class="sxs-lookup"><span data-stu-id="6702d-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![アドホック SQL ステートメントを使用します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="6702d-157">**図 1**: アドホック SQL ステートメントを使用</span><span class="sxs-lookup"><span data-stu-id="6702d-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="6702d-158">次の画面を作成するクエリの種類を指定できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="6702d-159">このクエリは内のレコードの合計数に 1 つのスカラー値に返すので、`Products`テーブルを選択して、`SELECT`単一の値のオプションが返されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![単一の値を返す SELECT ステートメントを使用するクエリを構成します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="6702d-161">**図 2**: 単一の値を返す SELECT ステートメントを使用するクエリを構成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="6702d-162">使用するクエリの種類を示す後に、、次に、クエリを指定お必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-162">After indicating the type of query to use, we must next specify the query.</span></span>


![製品のクエリから SELECT COUNT(\*) を使用します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="6702d-164">**図 3**: SELECT COUNT を使用して (\*) FROM 製品クエリ</span><span class="sxs-lookup"><span data-stu-id="6702d-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="6702d-165">最後に、メソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="6702d-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="6702d-166">ここに挙げた、let s としてを使用して`TotalNumberOfProducts`です。</span><span class="sxs-lookup"><span data-stu-id="6702d-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![DAL メソッド TotalNumberOfProducts を名前します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="6702d-168">**図 4**: DAL メソッド TotalNumberOfProducts の名前</span><span class="sxs-lookup"><span data-stu-id="6702d-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="6702d-169">[完了] をクリックすると、ウィザードが追加されます、 `TotalNumberOfProducts` DAL にメソッドです。</span><span class="sxs-lookup"><span data-stu-id="6702d-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="6702d-170">スカラー返す DAL で返し、null 許容型は、SQL クエリの結果は場合に`NULL`です。</span><span class="sxs-lookup"><span data-stu-id="6702d-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="6702d-171">当社`COUNT`、ただし、常に返されます以外`NULL`値; に関係なく、DAL メソッドが null 許容の整数を返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="6702d-172">DAL メソッドだけでなく、BLL 内のメソッドも必要です。</span><span class="sxs-lookup"><span data-stu-id="6702d-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="6702d-173">開く、`ProductsBLL`クラス ファイルを追加、 `TotalNumberOfProducts` DAL s 呼び出すだけメソッド`TotalNumberOfProducts`メソッド。</span><span class="sxs-lookup"><span data-stu-id="6702d-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="6702d-174">DAL s`TotalNumberOfProducts`メソッドが null 許容の整数を返します。 ただし、おを作成しました、`ProductsBLL`クラス s`TotalNumberOfProducts`メソッドことが標準の整数を返すようにします。</span><span class="sxs-lookup"><span data-stu-id="6702d-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="6702d-175">したがってが必要、`ProductsBLL`クラス s`TotalNumberOfProducts`メソッドは、DAL s によって返される null 許容の整数の値の部分を返す`TotalNumberOfProducts`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="6702d-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="6702d-176">呼び出し`GetValueOrDefault()`nullable 整数がある場合です。 存在する場合に null 許容の整数の値を返します`null`、ただし、既定の整数値は 0 を返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="6702d-177">手順 3: レコードの正確なサブセットを返す</span><span class="sxs-lookup"><span data-stu-id="6702d-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="6702d-178">DAL と行の開始インデックスを受け入れる BLL でメソッドを作成するが、次のタスクと変数の最大行数の前に説明した適切なレコードを返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="6702d-179">その前に、let s 最初を見て、必要な SQL スクリプト。</span><span class="sxs-lookup"><span data-stu-id="6702d-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="6702d-180">私たちが直面する課題は、行の開始インデックス位置 (およびレコードの最大レコード数に達するまで) の開始には、これらのレコードを返すことができますようにを介してページングされる全体の結果の行ごとにインデックスを効率的に割り当てるには時間ができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="6702d-181">行のインデックスとして機能するデータベース テーブルの列は既に場合でもこれは、チャレンジではありません。</span><span class="sxs-lookup"><span data-stu-id="6702d-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="6702d-182">一見おと考えることも、`Products`表 s`ProductID`フィールドが十分に機能を最初の製品が`ProductID`1、2、2 番目のようにします。</span><span class="sxs-lookup"><span data-stu-id="6702d-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="6702d-183">ただし、商品を削除すると、シーケンスは、このアプローチのため取り消されましたギャップが残されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="6702d-184">これには 2 つ一般的な方法は、データを複数のページを効率的に行のインデックスを関連付けるために使用できるように取得するレコードの正確なサブセットがあります。</span><span class="sxs-lookup"><span data-stu-id="6702d-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="6702d-185">**SQL Server 2005 の s を使用して`ROW_NUMBER()`キーワード**を初めて使用する SQL Server 2005、`ROW_NUMBER()`キーワードは、一部の順序に基づいて返される各レコードを順位付けを関連付けます。</span><span class="sxs-lookup"><span data-stu-id="6702d-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="6702d-186">この順位付けは、各行の行のインデックスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="6702d-187">**テーブル変数を使用して、 `SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT`ステートメント](https://msdn.microsoft.com/library/ms188774.aspx)合計レコードの数です終了する前に、クエリを処理する必要がありますを指定するために使用する。[テーブル変数](http://www.sqlteam.com/item.asp?ItemID=9454)akin を表形式のデータを保持できるローカルの T-SQL 変数[一時テーブル](http://www.sqlteam.com/item.asp?ItemID=2029)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="6702d-188">このアプローチは均等に Microsoft SQL Server 2005 および SQL Server 2000 の両方 (一方、`ROW_NUMBER()`アプローチは、SQL Server 2005 でのみ機能)。</span><span class="sxs-lookup"><span data-stu-id="6702d-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="6702d-189">持つテーブル変数を作成するという考え方です、`IDENTITY`列とデータを介してページングされるテーブルの主キーの列です。</span><span class="sxs-lookup"><span data-stu-id="6702d-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="6702d-190">これにより、連続する行のインデックスを関連付け、テーブル変数にデータを介してページングされるテーブルの内容をダンプする次に、(を使用して、`IDENTITY`列)、テーブル内の各レコード。</span><span class="sxs-lookup"><span data-stu-id="6702d-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="6702d-191">テーブル変数の読み込みが完了した後、`SELECT`のステートメントに、テーブル変数で、特定のレコードをプルする基になるテーブルと結合を実行できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="6702d-192">`SET ROWCOUNT`インテリジェントなテーブル変数にダンプする必要があるレコードの数を制限するステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="6702d-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="6702d-193">このアプローチの効率性が要求されているページ数に基づくとして、`SET ROWCOUNT`値には、開始行のインデックスと行の最大数の値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="6702d-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="6702d-194">データのいくつかのページなど、最初のページの番号付きの低をページングするとき、この方法は非常に効率的です。</span><span class="sxs-lookup"><span data-stu-id="6702d-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="6702d-195">ただし、末尾付近のページを取得するときに、既定値のページングのようなパフォーマンスが発生します。</span><span class="sxs-lookup"><span data-stu-id="6702d-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="6702d-196">このチュートリアルでは、カスタム ページングを使用して実装する、`ROW_NUMBER()`キーワード。</span><span class="sxs-lookup"><span data-stu-id="6702d-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="6702d-197">テーブル変数を使用する方法について、`SET ROWCOUNT`手法を参照してください[A 詳細を効率的に大きな結果セットからページング](http://www.4guysfromrolla.com/webtech/042606-1.shtml)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="6702d-198">`ROW_NUMBER()`キーワードでは、次の構文を使用して、特定の順序付け経由で返された各レコードにランクが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="6702d-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="6702d-199">`ROW_NUMBER()` 指定された順序に関しては、各レコードのランクを指定する数値を返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="6702d-200">たとえば、製品ごとの多い順にランクを表示する、最小限のコストを使用できます、次のクエリ。</span><span class="sxs-lookup"><span data-stu-id="6702d-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="6702d-201">図 5 は、このクエリは、Visual Studio で [クエリ] ウィンドウから実行したときに、秒の結果。</span><span class="sxs-lookup"><span data-stu-id="6702d-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="6702d-202">行ごとの価格ランクと共に、価格、製品を並べ替えることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="6702d-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![価格のランクが含まれる各返されるレコード](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="6702d-204">**図 5**:、価格のランクがの含まれる各返されるレコード</span><span class="sxs-lookup"><span data-stu-id="6702d-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="6702d-205">`ROW_NUMBER()` 多くの新しい順位付け関数の 1 つは SQL Server 2005 で使用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="6702d-206">詳細については`ROW_NUMBER()`、他の順位付け関数と共に読み取り[Microsoft SQL Server 2005 で順位付けされた結果を返す](http://www.4guysfromrolla.com/webtech/010406-1.shtml)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="6702d-207">指定した結果を順位付けと`ORDER BY`内の列、`OVER`句 (`UnitPrice`、上記の例では)、SQL Server は、結果を並べ替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="6702d-208">これは、結果されている順に並べ替え、列にクラスター化インデックスがある場合は、クイック操作または、カバリングがあるかどうか、インデックスでもかまいません高額それ以外の場合。</span><span class="sxs-lookup"><span data-stu-id="6702d-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="6702d-209">十分な大きさのクエリのパフォーマンスを向上させるには、これによって、結果は並べ 列の非クラスター化インデックスを追加することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="6702d-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="6702d-210">参照してください[SQL Server 2005 でのパフォーマンスと順位付け関数](http://www.sql-server-performance.com/ak_ranking_functions.asp)パフォーマンスに関する考慮事項の詳細を把握します。</span><span class="sxs-lookup"><span data-stu-id="6702d-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="6702d-211">によって返されるランク付け情報`ROW_NUMBER()`で直接使用することはできません、`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="6702d-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="6702d-212">返すただし、派生テーブルを使用できます、`ROW_NUMBER()`で表示することができますし、結果、`WHERE`句。</span><span class="sxs-lookup"><span data-stu-id="6702d-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="6702d-213">たとえば、次のクエリ テーブルを使用して、派生と共に、ProductName および UnitPrice 列を返す、`ROW_NUMBER()`結果、および、使用、`WHERE`のみこれらの製品価格ランクを返すには句が 11 ~ 20。</span><span class="sxs-lookup"><span data-stu-id="6702d-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="6702d-214">少しさらに、この概念を拡張するには、目的の行の開始インデックスと行の最大数の値を指定されたデータの特定のページを取得するには、このアプローチを利用できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="6702d-215">紹介するように後でこのチュートリアルでは、 *`StartRowIndex`* によって提供される、ObjectDataSource のインデックスは 0 から始まる一方、 `ROW_NUMBER()` SQL Server 2005 によって返される値は 1 から始まるインデックスします。</span><span class="sxs-lookup"><span data-stu-id="6702d-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="6702d-216">そのため、`WHERE`句は、これらのレコードを返します場所`PriceRank`がより厳密に大きい*`StartRowIndex`* 以下と等しい*`StartRowIndex`*  + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="6702d-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="6702d-217">これまで方法を説明してきた`ROW_NUMBER()`できます、開始行のインデックスと行の最大数の値を指定されたデータの特定のページを取得するために使用、今すぐいただくために DAL BLL 内のメソッドとしてこのロジックを実装します。</span><span class="sxs-lookup"><span data-stu-id="6702d-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="6702d-218">順序を決める必要がありますこのクエリを作成するときに、結果が順位付けです。%s の名前をアルファベット順で製品を並べ替えることができます。</span><span class="sxs-lookup"><span data-stu-id="6702d-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="6702d-219">つまり、このチュートリアルではカスタム ページングの実装はできませんを並べ替えることもできますよりも、カスタム ページ分けしたレポートを作成できません。</span><span class="sxs-lookup"><span data-stu-id="6702d-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="6702d-220">チュートリアルでは、[次へ]、ただし、会いしましょうこのような機能の提供方法です。</span><span class="sxs-lookup"><span data-stu-id="6702d-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="6702d-221">前のセクションでは、アドホック SQL ステートメントとして DAL メソッドを作成しました。</span><span class="sxs-lookup"><span data-stu-id="6702d-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="6702d-222">同様に、TableAdapter ウィザードではありません t によって使用される Visual Studio で T-SQL パーサー残念ながら、`OVER`で使用される構文、`ROW_NUMBER()`関数。</span><span class="sxs-lookup"><span data-stu-id="6702d-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="6702d-223">そのため、ストアド プロシージャとしてこの DAL メソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="6702d-224">[表示] メニュー (またはヒット Ctrl + Alt + S) からサーバー エクスプ ローラーを選択し、展開、`NORTHWND.MDF`ノード。</span><span class="sxs-lookup"><span data-stu-id="6702d-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="6702d-225">新しいストアド プロシージャを追加、ストアド プロシージャ ノードを右クリックし、新しいストアド プロシージャの追加を選択 (図 6 を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="6702d-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![ページングとは、製品の新しいストアド プロシージャを追加します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="6702d-227">**図 6**: ページングとは、製品の新しいストアド プロシージャを追加</span><span class="sxs-lookup"><span data-stu-id="6702d-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="6702d-228">このストアド プロシージャは、2 つの整数入力パラメーターを受け入れる必要があります`@startRowIndex`と`@maximumRows`を使用して、`ROW_NUMBER()`関数が並べ、`ProductName`フィールドに、指定したを超える行だけを返す`@startRowIndex`と未満または等しい`@startRowIndex`  +  `@maximumRow` s。</span><span class="sxs-lookup"><span data-stu-id="6702d-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="6702d-229">新しいストアド プロシージャに、次のスクリプトを入力し、データベースにストアド プロシージャを追加する [保存] アイコンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="6702d-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="6702d-230">ストアド プロシージャを作成すると、すぐをテストしてみましょう。右クリックし、`GetProductsPaged`ストアド プロシージャが、サーバー エクスプ ローラーでの名前および Execute オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="6702d-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="6702d-231">Visual Studio は、の入力を求め、入力パラメーター`@startRowIndex`と`@maximumRow`s (図 7 を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="6702d-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="6702d-232">別の値を再試行し、結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="6702d-232">Try different values and examine the results.</span></span>


![値を入力して、@startRowIndexと@maximumRowsパラメーター](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="6702d-234"><strong>図 7</strong>: の値を入力して、@startRowIndexと@maximumRowsパラメーター</span><span class="sxs-lookup"><span data-stu-id="6702d-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="6702d-235">後のパラメーターの値を入力してこれらの選択、結果を出力ウィンドウが表示されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="6702d-236">図 8 の両方を 10 に渡すときに結果を示しています、`@startRowIndex`と`@maximumRows`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="6702d-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="6702d-237">[![返される、レコードに表示されている 2 番目のデータ ページ](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="6702d-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="6702d-238">**図 8**:、レコードに表示されている 2 番目のページ データが返されます ([フルサイズのイメージを表示するをクリックして](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="6702d-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>


<span data-ttu-id="6702d-239">これで作成されるストアド プロシージャ、おを作成する準備ができたら、`ProductsTableAdapter`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="6702d-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="6702d-240">開く、`Northwind.xsd`で右クリックして、型指定されたデータセット、`ProductsTableAdapter`クエリの追加オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="6702d-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="6702d-241">アドホック SQL ステートメントを使用してクエリを作成するには、代わりに、既存のストアド プロシージャを使用してそれを作成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![既存のストアド プロシージャを使用して、DAL メソッドを作成します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="6702d-243">**図 9**: 既存のストアド プロシージャを使用して、DAL メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="6702d-244">次に、呼び出すストアド プロシージャを選択するよう求められます。</span><span class="sxs-lookup"><span data-stu-id="6702d-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="6702d-245">選択、`GetProductsPaged`ドロップダウン リストからストアド プロシージャです。</span><span class="sxs-lookup"><span data-stu-id="6702d-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![選択、GetProductsPaged ドロップダウン リストからストアド プロシージャ](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="6702d-247">**図 10**: GetProductsPaged 選択ドロップダウン リストからストアド プロシージャ</span><span class="sxs-lookup"><span data-stu-id="6702d-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="6702d-248">次の画面で、要求したデータの種類は、ストアド プロシージャによって返される: 表形式のデータ、1 つの値または値はありません。</span><span class="sxs-lookup"><span data-stu-id="6702d-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="6702d-249">以降、`GetProductsPaged`ストアド プロシージャの複数のレコードが返される、表形式のデータが返されることを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="6702d-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![ストアド プロシージャが表形式のデータを返すことを示します](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="6702d-251">**図 11**: ストアド プロシージャが表形式のデータを返すことを示します</span><span class="sxs-lookup"><span data-stu-id="6702d-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="6702d-252">最後に、作成するメソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="6702d-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="6702d-253">同様に、前のチュートリアルでは、DataTable、両方の塗りつぶしを使用してメソッドを作成してください DataTable を返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="6702d-254">最初のメソッドの名前を付けます`FillPaged`、2 番目`GetProductsPaged`です。</span><span class="sxs-lookup"><span data-stu-id="6702d-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![名前のメソッド FillPaged と GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="6702d-256">**図 12**: 名前メソッド FillPaged と GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="6702d-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="6702d-257">さらに製品の特定のページを返す DAL メソッドを作成するも必要があります、BLL にこのような機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="6702d-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="6702d-258">DAL メソッドと同様に BLL の GetProductsPaged メソッドは、開始行のインデックスと行の最大数を指定するための 2 つの整数入力を受け入れる必要があり、指定した範囲内でそれらのレコードだけを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="6702d-259">だけでの呼び出しを DAL の GetProductsPaged メソッドに次のように ProductsBLL クラスでこのような BLL メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="6702d-260">任意の名前を使用することができます BLL のメソッドの入力パラメーターを使用する選択が、間もなく、見ていきます`startRowIndex`と`maximumRows`us 余分なから保存の作業をこのメソッドを使用して、ObjectDataSource を構成するときにします。</span><span class="sxs-lookup"><span data-stu-id="6702d-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="6702d-261">手順 4: カスタム ページングを使用して、ObjectDataSource を構成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="6702d-262">完全なレコードの特定のサブセットにアクセスするための BLL と DAL メソッドでは、カスタム ページングを使用して、基になるレコードからそのページ GridView を作成する準備ができたら制御します。</span><span class="sxs-lookup"><span data-stu-id="6702d-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="6702d-263">開いて開始、 `EfficientPaging.aspx`  ページで、`PagingAndSorting`フォルダー、GridView、ページを追加、および新しい ObjectDataSource コントロールを使用するように構成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="6702d-264">過去のチュートリアルでは、多くの場合がありましたを使用するように構成 ObjectDataSource、`ProductsBLL`クラスの`GetProducts`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="6702d-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="6702d-265">このとき、ただし、使用する、`GetProductsPaged`メソッド代わりに、以降、`GetProducts`メソッドを返します。*すべて*データベース内の製品の一方`GetProductsPaged`レコードの特定のサブセットだけを返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![ObjectDataSource ProductsBLL クラスの GetProductsPaged メソッドを使用して構成します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="6702d-267">**図 13**: ProductsBLL クラスの GetProductsPaged メソッドを使用して、ObjectDataSource を構成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="6702d-268">お再読み取り専用の GridView を作成するには、以降、insert、UPDATE、メソッドのドロップダウン リストを設定して (なし) にタブを削除します。</span><span class="sxs-lookup"><span data-stu-id="6702d-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="6702d-269">次に、ObjectDataSource ウィザードの指示に従って us のソースで、`GetProductsPaged`メソッド s`startRowIndex`と`maximumRows`パラメーターの値を入力します。</span><span class="sxs-lookup"><span data-stu-id="6702d-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="6702d-270">これらの入力パラメーターは実際に設定されます GridView によって自動的に、するだけでのままにして、ソースを None におよび完了 をクリックします。</span><span class="sxs-lookup"><span data-stu-id="6702d-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![[なし] として入力パラメーターのソースのままにしてください。](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="6702d-272">**図 14**: None として入力パラメーターのソースのままにして</span><span class="sxs-lookup"><span data-stu-id="6702d-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="6702d-273">ObjectDataSource ウィザードの完了後は、GridView はの各製品のデータ フィールドのも、BoundField または CheckBoxField に含まれます。</span><span class="sxs-lookup"><span data-stu-id="6702d-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="6702d-274">自由に適宜 GridView の外観をカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="6702d-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="6702d-275">I のみを表示することを選択したら、 `ProductName`、 `CategoryName`、 `SupplierName`、 `QuantityPerUnit`、および`UnitPrice`BoundFields です。</span><span class="sxs-lookup"><span data-stu-id="6702d-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="6702d-276">また、構成のスマート タグでページングを有効にする チェック ボックスをチェックしてページングをサポートする GridView。</span><span class="sxs-lookup"><span data-stu-id="6702d-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="6702d-277">これらの変更後、GridView と ObjectDataSource 宣言型マークアップを次のようになります。</span><span class="sxs-lookup"><span data-stu-id="6702d-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="6702d-278">ブラウザー ページにアクセスする場合は、GridView がない where 発見可能にします。</span><span class="sxs-lookup"><span data-stu-id="6702d-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![GridView は表示されません。](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="6702d-280">**図 15**: GridView は表示されません</span><span class="sxs-lookup"><span data-stu-id="6702d-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="6702d-281">GridView は、ObjectDataSource は両方の値として 0 を現在使用されているので、不足している、 `GetProductsPaged` `startRowIndex`と`maximumRows`パラメーターを入力します。</span><span class="sxs-lookup"><span data-stu-id="6702d-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="6702d-282">そのため、レコードを返すことが結果の SQL クエリがありませんされ、したがって GridView は表示されません。</span><span class="sxs-lookup"><span data-stu-id="6702d-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="6702d-283">この問題を解決するには、カスタム ページングを使用して、ObjectDataSource を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="6702d-284">これは、次の手順で実行できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="6702d-285">**集合 ObjectDataSource s`EnablePaging`プロパティを`true`** に渡す必要があります、ObjectDataSource にこれを示します、 `SelectMethod` 2 つのパラメーター: 行の開始インデックスを指定する 1 つ ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))、および行の最大数を指定する 1 つ ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="6702d-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="6702d-286">**ObjectDataSource s を設定`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに応じて**、`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに渡される入力パラメーターの名前を示す、`SelectMethod`用カスタム ページングします。</span><span class="sxs-lookup"><span data-stu-id="6702d-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="6702d-287">これらのパラメーター名は、既定では、`startIndexRow`と`maximumRows`、これは、理由を作成するとき、`GetProductsPaged`メソッド、BLL では入力パラメーターのこれらの値を使用しました。</span><span class="sxs-lookup"><span data-stu-id="6702d-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="6702d-288">BLL s のさまざまなパラメーター名を使用する場合`GetProductsPaged`などのメソッド`startIndex`と`maxRows`にする必要がありますの例は、ObjectDataSource s を設定、`StartRowIndexParameterName`と`MaximumRowsParameterName`プロパティに応じて (などの startIndex`StartRowIndexParameterName`およびの maxRows `MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="6702d-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="6702d-289">**集合 ObjectDataSource s [ `SelectCountMethod`プロパティ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)を合計数のレコードされているページを返すメソッドの名前に (`TotalNumberOfProducts`)** ことに注意してください、`ProductsBLL`クラスの`TotalNumberOfProducts`メソッドを実行する DAL メソッドを使用してページングされるレコードの合計数を返します、`SELECT COUNT(*) FROM Products`クエリ。</span><span class="sxs-lookup"><span data-stu-id="6702d-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="6702d-290">この情報には、正しくページング インターフェイスを表示するために、ObjectDataSource が必要です。</span><span class="sxs-lookup"><span data-stu-id="6702d-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="6702d-291">**削除、`startRowIndex`と`maximumRows` `<asp:Parameter>` ObjectDataSource s 宣言型マークアップから要素**ウィザード、ObjectDataSource を構成するには、Visual Studio に自動的に追加 2`<asp:Parameter>`要素`GetProductsPaged`のメソッドの入力パラメーターです。</span><span class="sxs-lookup"><span data-stu-id="6702d-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="6702d-292">設定して`EnablePaging`に`true`、これらのパラメーターが自動的に渡されます;、ObjectDataSource を渡そうとして表示される場合も宣言の構文では、 *4*パラメーターを`GetProductsPaged`メソッド2 つのパラメーターと、`TotalNumberOfProducts`メソッドです。</span><span class="sxs-lookup"><span data-stu-id="6702d-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="6702d-293">これらを削除するを忘れた場合`<asp:Parameter>`などのエラー メッセージが表示されます、ブラウザーからページを訪問すると、要素: *ObjectDataSource 'ObjectDataSource1' は、非ジェネリック メソッドの 'TotalNumberOfProducts' を持つを特定できませんでしたパラメーター: startRowIndex、maximumRows*です。</span><span class="sxs-lookup"><span data-stu-id="6702d-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="6702d-294">これらの変更を加えたら、ObjectDataSource s の宣言構文は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="6702d-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="6702d-295">なお、`EnablePaging`と`SelectCountMethod`プロパティが設定されてと`<asp:Parameter>`要素が削除されました。</span><span class="sxs-lookup"><span data-stu-id="6702d-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="6702d-296">図 16 は、これらの変更が加えられた後に、[プロパティ] ウィンドウのスクリーン ショットを示します。</span><span class="sxs-lookup"><span data-stu-id="6702d-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![カスタム ページングを使用するのには、ObjectDataSource コントロールを構成します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="6702d-298">**図 16**: カスタム ページングを使用するのには、ObjectDataSource コントロールを構成します。</span><span class="sxs-lookup"><span data-stu-id="6702d-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="6702d-299">これらの変更を行った後は、ブラウザーからこのページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="6702d-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="6702d-300">この一覧を表示すると、10 個の製品が表示されますアルファベット順です。</span><span class="sxs-lookup"><span data-stu-id="6702d-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="6702d-301">すぐをデータを 1 ページずつ処理します。</span><span class="sxs-lookup"><span data-stu-id="6702d-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="6702d-302">既定のページングとカスタム ページングのエンド ユーザーの観点から visual の違いはありませんが、カスタム ページングをより効率的にページ間大量のデータと、特定のページに表示される必要があるレコードのみを取得します。</span><span class="sxs-lookup"><span data-stu-id="6702d-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="6702d-303">[![データ、Ordered、製品名では、ページを使用してのカスタム ページング](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="6702d-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="6702d-304">**図 17**: データは、製品名、Ordered はページを使用してのカスタム ページング ([フルサイズのイメージを表示するをクリックして](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="6702d-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="6702d-305">ページ数、ObjectDataSource s によって返される値が、カスタム ページングと`SelectCountMethod`GridView のビュー ステートに格納されています。</span><span class="sxs-lookup"><span data-stu-id="6702d-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="6702d-306">その他の GridView 変数、 `PageIndex`、 `EditIndex`、 `SelectedIndex`、`DataKeys`コレクション、およびなに格納されている*状態コントロール*、GridView 秒の値に関係なくこれが永続化される`EnableViewState`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="6702d-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="6702d-307">以降、`PageCount`値が永続化される最後のページに移動するリンクを含むページング インターフェイスを使用する場合は、ビュー ステートを使用して、ポストバック間での GridView のビュー ステートを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="6702d-308">(ページ、ページング インターフェイスは直接のリンクを最後に含まれていない場合、し、ビュー ステートを無効にすることがあります。)</span><span class="sxs-lookup"><span data-stu-id="6702d-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="6702d-309">最後のページのリンクをクリックするとポストバックを発生させるし、GridView を更新するように指示その`PageIndex`プロパティです。</span><span class="sxs-lookup"><span data-stu-id="6702d-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="6702d-310">GridView を割り当てます、最後のページ リンクをクリックすると場合、その`PageIndex`プロパティのいずれかの値より小さい、`PageCount`プロパティです。</span><span class="sxs-lookup"><span data-stu-id="6702d-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="6702d-311">無効にすると、ビュー ステートに、`PageCount`ポストバック間で値が失われると、`PageIndex`最大の整数値を代わりに割り当てられてです。</span><span class="sxs-lookup"><span data-stu-id="6702d-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="6702d-312">GridView が乗算することによって開始行のインデックスを決定しようとした次に、`PageSize`と`PageCount`プロパティです。</span><span class="sxs-lookup"><span data-stu-id="6702d-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="6702d-313">これは、結果、`OverflowException`製品が許可されている整数型の最大サイズを超えているためです。</span><span class="sxs-lookup"><span data-stu-id="6702d-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="6702d-314">カスタム ページングの実装と並べ替え</span><span class="sxs-lookup"><span data-stu-id="6702d-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="6702d-315">を介して、データをページングする順序を指定する静的に作成するときに、現在のカスタム ページングの実装が必要です、`GetProductsPaged`ストアド プロシージャです。</span><span class="sxs-lookup"><span data-stu-id="6702d-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="6702d-316">ただし、場合がありますメモ GridView s のスマート タグにページングを有効にするオプションだけでなく、並べ替えを有効にするチェックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="6702d-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="6702d-317">残念ながら、現在カスタム ページング実装を GridView に並べ替えのサポートを追加しても、データの表示されているページ上のレコードには並べ替えのみです。</span><span class="sxs-lookup"><span data-stu-id="6702d-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="6702d-318">たとえばもページングをサポートしの降順に並べ替え、製品名によって、データの最初のページを表示するときに並べ替え GridView を構成する場合は、1 ページ目で、製品の順序を逆は。</span><span class="sxs-lookup"><span data-stu-id="6702d-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="6702d-319">71 他の製品の後にあるマーガリン、アルファベット以外を無視する逆のアルファベット順に並べ替えるときに、最初の製品としてマーガリンを示しますこのような図 18 に示す最初のページのレコードだけが、並べ替え中と見なされます。</span><span class="sxs-lookup"><span data-stu-id="6702d-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="6702d-320">[![並べ替えのみ、データ、現在のページに表示](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="6702d-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="6702d-321">**図 18**: のみ、データ ページに表示される、現在の並べ替え ([フルサイズのイメージを表示するをクリックして](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="6702d-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>


<span data-ttu-id="6702d-322">並べ替えにのみ適用されますデータの現在のページ、BLL s からデータが取得された後に、並べ替えが行われているため`GetProductsPaged`メソッド、およびこのメソッドは、特定のページのレコードのみを返します。</span><span class="sxs-lookup"><span data-stu-id="6702d-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="6702d-323">正しく並べ替えを実装する必要がありますに、並べ替え式を渡す、`GetProductsPaged`メソッドのデータは、データの特定のページを返す前に適切に順位付けされることができるようにします。</span><span class="sxs-lookup"><span data-stu-id="6702d-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="6702d-324">これを実現する、次のチュートリアルでこれについて扱います。</span><span class="sxs-lookup"><span data-stu-id="6702d-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="6702d-325">カスタム ページングと削除を実装します。</span><span class="sxs-lookup"><span data-stu-id="6702d-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="6702d-326">考えることが、最後のページから最後のレコードを削除するときにカスタムのページング手法を使用してデータを含むはページングされた GridView の削除機能を有効にする GridView が表示されなくなります適切にデクリメントではなく GridView の`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="6702d-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="6702d-327">このバグを再現するには、だけ先ほど作成したチュートリアルの削除を有効にします。</span><span class="sxs-lookup"><span data-stu-id="6702d-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="6702d-328">81 製品、一度に 10 個の製品をページングおために 1 つの製品を表示する必要があります (ページ 9)、最後のページに移動します。</span><span class="sxs-lookup"><span data-stu-id="6702d-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="6702d-329">この製品を削除します。</span><span class="sxs-lookup"><span data-stu-id="6702d-329">Delete this product.</span></span>

<span data-ttu-id="6702d-330">削除すると、最後の製品、GridView*必要があります*8 番目のページに自動的に移動し、このような機能が既定のページングと発生します。</span><span class="sxs-lookup"><span data-stu-id="6702d-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="6702d-331">カスタム ページングは、ただし、最後のページの最終製品を削除した後 GridView 単に表示されなくなります画面から完全。</span><span class="sxs-lookup"><span data-stu-id="6702d-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="6702d-332">正確な理由*理由*ビットは扱いませんが、このチュートリアルは行われるこれを参照してください[カスタム ページング GridView から最後のページには、最後のレコードを削除する](http://scottonwriting.net/sowblog/posts/7326.aspx)詳細については、低レベルのソースについてこの問題。</span><span class="sxs-lookup"><span data-stu-id="6702d-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="6702d-333">要約すると、[削除] ボタンがクリックされたときに、GridView によって実行されるステップの次のシーケンスがあるため s:</span><span class="sxs-lookup"><span data-stu-id="6702d-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="6702d-334">レコードを削除します。</span><span class="sxs-lookup"><span data-stu-id="6702d-334">Delete the record</span></span>
2. <span data-ttu-id="6702d-335">指定した表示する適切なレコードを取得`PageIndex`と `PageSize`</span><span class="sxs-lookup"><span data-stu-id="6702d-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="6702d-336">確認、 `PageIndex` GridView s を減分は、自動的に場合、データ ソース内のデータのページの数を超えない`PageIndex`プロパティ</span><span class="sxs-lookup"><span data-stu-id="6702d-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="6702d-337">手順 2. で取得されたレコードを使用した GridView に、適切なページのデータをバインドします。</span><span class="sxs-lookup"><span data-stu-id="6702d-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="6702d-338">問題に起因して、ファクトにその手順 2、`PageIndex`が表示するレコードを取得するときに使用、`PageIndex`の最後のページが唯一のレコードが削除されただけです。</span><span class="sxs-lookup"><span data-stu-id="6702d-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="6702d-339">そのため、手順 2. で*ありません*データの最終ページには不要になったすべてのレコードが含まれているために、レコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="6702d-340">次に、手順 3. で GridView ことを認識するその`PageIndex`プロパティは、データ ソース内のページの合計数より大きい (以降お ve 削除最後のページの最後のレコード) およびデクリメントしたがってその`PageIndex`プロパティです。</span><span class="sxs-lookup"><span data-stu-id="6702d-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="6702d-341">手順 4. で GridView がそれ自体を; 手順 2 で取得されたデータにバインドしようただし、ステップ 2 でレコードが返されなかった、したがって結果として得られる空 GridView にします。</span><span class="sxs-lookup"><span data-stu-id="6702d-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="6702d-342">この問題のない t サーフェスため既定のページングと手順 2. で*すべて*レコードは、データ ソースから取得されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="6702d-343">これを修正するのには、2 つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="6702d-343">To fix this we have two options.</span></span> <span data-ttu-id="6702d-344">GridView s のイベント ハンドラーを作成する 1 つは、`RowDeleted`イベント ハンドラーが削除されるだけで、ページに表示されていたレコードの数を決定します。</span><span class="sxs-lookup"><span data-stu-id="6702d-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="6702d-345">かどうか 1 つのレコードが削除されるだけで、レコードが最後の 1 つをされている必要があり、GridView s をデクリメントする必要があります`PageIndex`です。</span><span class="sxs-lookup"><span data-stu-id="6702d-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="6702d-346">もちろん、のみ更新する、`PageIndex`ことを確認して判断できます、削除操作が実際に成功した場合、`e.Exception`プロパティは`null`します。</span><span class="sxs-lookup"><span data-stu-id="6702d-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="6702d-347">このアプローチは更新するので、`PageIndex`手順 1. の後に、手順 2 の前にします。</span><span class="sxs-lookup"><span data-stu-id="6702d-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="6702d-348">したがって、手順 2. でレコードの適切なセットが返されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="6702d-349">これを実現するには、次のようにコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="6702d-349">To accomplish this, use code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="6702d-350">別の回避策は、ObjectDataSource s のイベント ハンドラーを作成する`RowDeleted`イベントを設定して、`AffectedRows`プロパティを 1 の値にします。</span><span class="sxs-lookup"><span data-stu-id="6702d-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="6702d-351">GridView の更新手順 1. で (ただし、手順 2. でデータを再取得する前に) レコードを削除すると、その`PageIndex`プロパティの場合は、操作の影響を受けた 1 つまたは複数の行。</span><span class="sxs-lookup"><span data-stu-id="6702d-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="6702d-352">ただし、 `AffectedRows` ObjectDataSource によってプロパティが設定されていない、したがって、この手順を省略します。</span><span class="sxs-lookup"><span data-stu-id="6702d-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="6702d-353">この手順を実行する方法の 1 つが手動で設定するには、`AffectedRows`プロパティの場合は、削除操作が正常に完了します。</span><span class="sxs-lookup"><span data-stu-id="6702d-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="6702d-354">これは、次のようにコードを使用して実行できます。</span><span class="sxs-lookup"><span data-stu-id="6702d-354">This can be accomplished using code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="6702d-355">分離コード クラスでこれらのイベント ハンドラーの両方のコードが見つかりません、`EfficientPaging.aspx`例です。</span><span class="sxs-lookup"><span data-stu-id="6702d-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="6702d-356">既定およびカスタム ページングのパフォーマンスを比較します。</span><span class="sxs-lookup"><span data-stu-id="6702d-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="6702d-357">カスタム ページングは、既定のページングを返しますがのみ、必要なレコードを取得するため*すべて*表示されている各ページのレコードのカスタム ページングが既定のページングよりも効率的であるは明白です。</span><span class="sxs-lookup"><span data-stu-id="6702d-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="6702d-358">しかし、カスタム ページングは、どのくらい効率的ですか?</span><span class="sxs-lookup"><span data-stu-id="6702d-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="6702d-359">どのようなパフォーマンスの向上は、カスタム ページングを既定のページングを移動して見なすことができますか。</span><span class="sxs-lookup"><span data-stu-id="6702d-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="6702d-360">残念ながら、s がない 1 つのサイズが収まるすべてがここで回答します。</span><span class="sxs-lookup"><span data-stu-id="6702d-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="6702d-361">パフォーマンス向上は、さまざまな要因によって異なります、web サーバーとデータベース サーバーの間でデータベース サーバーとの通信チャネルの 2 つのレコードを介してページングされると、負荷の数をされている最も顕著配置されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="6702d-362">わずか 1 ダースのレコードを含む小さなテーブルは、パフォーマンスの差がごくわずかであり可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="6702d-363">大きなテーブルの場合は、数千 ~ 数十万行のただし、パフォーマンスの違いは深刻です。</span><span class="sxs-lookup"><span data-stu-id="6702d-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="6702d-364">、私のアーティクル[SQL Server 2005 での ASP.NET 2.0 では、カスタム ページング](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)、これら 2 つのページング手法を持つデータベース テーブルをページングするときの間のパフォーマンスの違いを示すために実行したいくつかのパフォーマンス テストが含まれていますレコードが 50,000 個です。</span><span class="sxs-lookup"><span data-stu-id="6702d-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="6702d-365">これらのテストで SQL Server レベルでクエリを実行する時間の両方について詳しく説明 (を使用して[SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) と ASP.NET ページを使用して、 [ASP.NET のトレース機能](https://msdn.microsoft.com/library/y13fw6we.aspx)します。</span><span class="sxs-lookup"><span data-stu-id="6702d-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="6702d-366">注意してくださいことこれらのテスト 1 つのアクティブなユーザーでは、開発ボックス上で実行されたしたがって科学されない一般的な web サイトのロード パターンを模倣されません。</span><span class="sxs-lookup"><span data-stu-id="6702d-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="6702d-367">関係なく、結果は、十分に大量のデータを使用する場合、既定およびカスタム ページングの実行時間の相対的な違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="6702d-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="6702d-368">**Avg.期間 (秒)**</span><span class="sxs-lookup"><span data-stu-id="6702d-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="6702d-369">**読み取り**</span><span class="sxs-lookup"><span data-stu-id="6702d-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="6702d-370">**既定の SQL Profiler のページング**</span><span class="sxs-lookup"><span data-stu-id="6702d-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="6702d-371">1.411</span><span class="sxs-lookup"><span data-stu-id="6702d-371">1.411</span></span> | <span data-ttu-id="6702d-372">383</span><span class="sxs-lookup"><span data-stu-id="6702d-372">383</span></span> |
| <span data-ttu-id="6702d-373">**カスタム ページング SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="6702d-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="6702d-374">0.002</span><span class="sxs-lookup"><span data-stu-id="6702d-374">0.002</span></span> | <span data-ttu-id="6702d-375">29</span><span class="sxs-lookup"><span data-stu-id="6702d-375">29</span></span> |
| <span data-ttu-id="6702d-376">**ページングの既定の ASP.NET トレース**</span><span class="sxs-lookup"><span data-stu-id="6702d-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="6702d-377">2.379</span><span class="sxs-lookup"><span data-stu-id="6702d-377">2.379</span></span> | <span data-ttu-id="6702d-378">*該当なし*</span><span class="sxs-lookup"><span data-stu-id="6702d-378">*N/A*</span></span> |
| <span data-ttu-id="6702d-379">**カスタム ページング ASP.NET のトレース**</span><span class="sxs-lookup"><span data-stu-id="6702d-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="6702d-380">0.029</span><span class="sxs-lookup"><span data-stu-id="6702d-380">0.029</span></span> | <span data-ttu-id="6702d-381">*該当なし*</span><span class="sxs-lookup"><span data-stu-id="6702d-381">*N/A*</span></span> |


<span data-ttu-id="6702d-382">わかるように、データの特定のページを取得する平均読み取り以下 354 を必要し、短時間で完了しました。</span><span class="sxs-lookup"><span data-stu-id="6702d-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="6702d-383">ASP.NET ページで、カスタム ページができた 1/100 に近いにレンダーされる<sup>th</sup>時間かかったの既定のページングを使用する場合。</span><span class="sxs-lookup"><span data-stu-id="6702d-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="6702d-384">参照してください[私の記事](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)コードと、データベースと共にこれらの結果の詳細については、ご使用の環境でこれらのテストを再現するダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="6702d-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="6702d-385">まとめ</span><span class="sxs-lookup"><span data-stu-id="6702d-385">Summary</span></span>

<span data-ttu-id="6702d-386">既定のページングは、データ Web コントロールのスマート タグにだけチェック ページングを有効にする チェック ボックスを実装する簡単ですが、このようなわかりやすくするための欠点はパフォーマンス。</span><span class="sxs-lookup"><span data-stu-id="6702d-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="6702d-387">ユーザーがデータの任意のページを要求したときに既定のページングと*すべて*それらのごく一部だけが表示される場合でも、レコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="6702d-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="6702d-388">このパフォーマンスのオーバーヘッドを対抗、ObjectDataSource には、代替ページング オプション カスタム ページングが用意されています。</span><span class="sxs-lookup"><span data-stu-id="6702d-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="6702d-389">カスタム ページングを向上させる既定の秒のパフォーマンスの問題を表示する必要があるレコードのみを取得することによってページング中に、s がカスタム ページングを実装するさらに複雑です。</span><span class="sxs-lookup"><span data-stu-id="6702d-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="6702d-390">最初に、正しく (かつ効率的に) にアクセス要求レコードの特定のサブセット、クエリを書き込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="6702d-391">これには、さまざまな方法です。このチュートリアルで確認して、1 つが新しい SQL Server 2005 の s を使用するには`ROW_NUMBER()`ランク付けする関数の結果、し、返すだけで結果が順位付けが指定された範囲内であります。</span><span class="sxs-lookup"><span data-stu-id="6702d-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="6702d-392">さらに、を介してページングされるレコードの合計数を決定するための手段を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="6702d-393">これらの DAL と BLL メソッドを作成するには後もことを確認し合計レコードの数をポケットベル通知を受け取りますが、BLL に、開始行のインデックスと行の最大数の値を渡すことが正しくできますされるように、ObjectDataSource を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6702d-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="6702d-394">カスタム ページングを実装するいくつかの手順は必要し、及びませんなどの単純な既定のページングは、カスタム ページングが必要十分に大量のデータをページングするとき。</span><span class="sxs-lookup"><span data-stu-id="6702d-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="6702d-395">結果の調査し、表示された、カスタム ページング役立つかについて、ASP.NET ページのレンダリング時間を秒数が 1 つ以上大幅データベース サーバーの負荷を軽減することができます。</span><span class="sxs-lookup"><span data-stu-id="6702d-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="6702d-396">満足プログラミング!</span><span class="sxs-lookup"><span data-stu-id="6702d-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="6702d-397">作成者について</span><span class="sxs-lookup"><span data-stu-id="6702d-397">About the Author</span></span>

<span data-ttu-id="6702d-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)、7 つ受け取りますブックとの創設者の作成者[4GuysFromRolla.com](http://www.4guysfromrolla.com)、1998 年からマイクロソフトの Web テクノロジで取り組んできました。</span><span class="sxs-lookup"><span data-stu-id="6702d-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="6702d-399">Scott は、コンサルタント、トレーナー、ライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="6702d-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="6702d-400">最新の著書[ *Sam 学べる自分で ASP.NET 2.0 が 24 時間以内に*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="6702d-401">彼に到達できる[ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)彼のブログを使用して含まれているのか[ http://ScottOnWriting.NET](http://ScottOnWriting.NET)です。</span><span class="sxs-lookup"><span data-stu-id="6702d-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="6702d-402">[前へ](paging-and-sorting-report-data-cs.md)
> [次へ](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="6702d-402">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
