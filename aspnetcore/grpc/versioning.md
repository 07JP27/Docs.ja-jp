---
title: GRPC サービスのバージョン管理
author: jamesnk
description: GRPC サービスのバージョンを確認する方法について説明します。
monikerRange: '>= aspnetcore-3.0'
ms.author: jamesnk
ms.date: 01/09/2020
uid: grpc/versioning
ms.openlocfilehash: 61dd5dfca4064af3ae58ac288a1ee636450ff56b
ms.sourcegitcommit: 79850db9e79b1705b89f466c6f2c961ff15485de
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/07/2020
ms.locfileid: "75694194"
---
# <a name="versioning-grpc-services"></a>GRPC サービスのバージョン管理

[James のニュートン-キング](https://twitter.com/jamesnk)別

アプリに追加された新機能では、クライアントに提供される gRPC サービスを必要とすることがあります。これは、予期しない、または中断する場合があります。 GRPC サービスが変更した場合:

* 変更がクライアントに与える影響について考慮する必要があります。
* 変更をサポートするためのバージョン管理戦略を実装する必要があります。

## <a name="backwards-compatibility"></a>下位互換性

GRPC プロトコルは、時間の経過と共に変化するサービスをサポートするように設計されています。 通常、gRPC のサービスとメソッドへの追加は非互換性です。 非互換性とは、既存のクライアントが動作し続けることを意味します。 GRPC サービスの変更または削除は重大な変更です。 重大な変更とは、既存のクライアントが失敗することを意味します。

サービスに重大な変更を加えることには、次のような利点があります。

- 既存のクライアントは引き続き実行されます。
- 重大な変更をクライアントに通知し、それらを更新する作業を回避します。
- ドキュメント化して管理する必要があるのは、1つのバージョンのサービスだけです。

このコンテンツでは **、gRPC プロトコルと .net バイナリ互換性レベルで**変更が中断されているかどうかを中心に説明します。 変更を行うときは、古いクライアントが論理的に動作を続行できるかどうかを検討してください。 たとえば、要求メッセージに新しいフィールドを追加すると、次のようになります。

* は、プロトコルの互換性に影響する変更ではありません。
* 新しいフィールドが設定されていない場合、サーバー上でエラー状態を返すと、古いクライアントの重大な変更になります。

### <a name="non-breaking-changes"></a>非破壊的変更

これらの変更は、gRPC プロトコルレベルと .NET バイナリレベルでは非互換性があります。

- **新しいサービスの追加**
- **サービスに新しいメソッドを追加する**
- **要求メッセージへのフィールドの追加**: 要求メッセージに追加されたフィールドは、設定されていない場合、サーバーの[既定値](https://developers.google.com/protocol-buffers/docs/proto3#default)で逆シリアル化されます。 中断されないようにするには、古いクライアントによって設定されていないサービスを成功させる必要があります。
- **応答メッセージにフィールドを追加**すると、応答メッセージに追加されたフィールドは、クライアント上のメッセージの[unknown fields](https://developers.google.com/protocol-buffers/docs/proto3#unknowns)コレクションに逆シリアル化されます。
- **列挙型の列挙型への値の追加**は、数値としてシリアル化されます。 新しい列挙値は、列挙型名を指定せずに、クライアント側で列挙値に逆シリアル化されます。 古くなっていないクライアントは、値を受け取って除外するときに、正しく動作する必要があります。

### <a name="binary-breaking-changes"></a>バイナリの互換性に影響する変更点

次の変更は gRPC プロトコルレベルでは中断されませんが *、最新のプロトコルコントラクト*またはクライアント .net アセンブリにアップグレードする場合は、クライアントを更新する必要があります。 GRPC ライブラリを NuGet に発行する予定の場合、バイナリの互換性が重要です。

- 削除されたフィールドからフィールド値を**削除**すると、メッセージの[不明なフィールド](https://developers.google.com/protocol-buffers/docs/proto3#unknowns)に逆シリアル化されます。 これは gRPC プロトコルの互換性に影響する変更ではありませんが、最新のコントラクトにアップグレードする場合は、クライアントを更新する必要があります。 削除したフィールド番号は、今後誤って再利用されないことが重要です。 この問題が発生しないようにする1つの方法は、Protobuf の[`reserved`](https://developers.google.com/protocol-buffers/docs/proto3#reserved)キーワードを使用して、削除されたフィールドの番号と名前をメッセージで指定することです。
- **フィールド名の**名前の変更は、生成されたコードでのみ使用されます。 フィールド番号は、ネットワーク上のフィールドを識別するために使用されます。 最新のコントラクトにアップグレードする場合は、クライアントを更新する必要があります。
- **メッセージ名の**変更はネットワーク上で送信されないので、これは grpc プロトコルの互換性に影響する変更ではありませんが、最新のコントラクトにアップグレードする場合は、クライアントを更新する必要があります。
- **Csharp_namespace**変更 `csharp_namespace` を変更すると、生成された .net 型の名前空間が変更されます。 これは gRPC プロトコルの互換性に影響する変更ではありませんが、最新のコントラクトにアップグレードする場合は、クライアントを更新する必要があります。

### <a name="breaking-changes"></a>互換性に影響する変更

これらは、プロトコルとバイナリの互換性に影響します。

- **フィールドのデータ型の変更**-フィールドのデータ型を互換性のない[型](https://developers.google.com/protocol-buffers/docs/proto3#updating)に変更すると、メッセージの逆シリアル化時にエラーが発生します。 新しいデータ型に互換性がある場合でも、最新のコントラクトにアップグレードすると、新しい型をサポートするようにクライアントを更新する必要があります。
- **フィールド番号の変更**-フィールド番号は、ネットワーク上のフィールドを識別するために使用されます。
- **Package、service、または method** -grpc の名前を変更するには、パッケージ名、サービス名、およびメソッド名を使用して URL を作成します。 クライアントは、サーバーから未*実装*の状態を取得します。
- **サービスまたはメソッドの削除**-クライアントは、削除されたメソッドを呼び出すときに、サーバーから未*実装*の状態を取得します。

## <a name="version-number-services"></a>バージョン番号サービス

サービスは、古いクライアントとの下位互換性を維持する必要があります。 最終的にアプリに変更を加える場合は、重大な変更が必要になることがあります。 古いクライアントを中断し、サービスと共に強制的に更新することは、優れたユーザーエクスペリエンスではありません。 互換性に影響する変更を加える際には、サービスの複数のバージョンを公開する方法があります。

gRPC では、省略可能な[`package`](https://developers.google.com/protocol-buffers/docs/proto3#packages)指定子がサポートされており、.net 名前空間と同様に機能します。 実際、`option csharp_namespace` が*proto*ファイルで設定されていない場合、生成された .net 型の .net 名前空間として `package` が使用されます。 パッケージを使用して、サービスとそのメッセージのバージョン番号を指定できます。

[!code-protobuf[](versioning/sample/greet.v1.proto?highlight=3)]

パッケージ名をサービス名と組み合わせて、サービスアドレスを識別します。 サービスアドレスを使用すると、複数のバージョンのサービスをサイドバイサイドでホストすることができます。

* `greet.v1.Greeter`
* `greet.v2.Greeter`

バージョン管理されたサービスの実装は*Startup.cs*に登録されます。

```csharp
app.UseEndpoints(endpoints =>
{
    // Implements greet.v1.Greeter
    endpoints.MapGrpcService<GreeterServiceV1>();

    // Implements greet.v2.Greeter
    endpoints.MapGrpcService<GreeterServiceV2>();
});
```

パッケージ名にバージョン番号を含めると、 *v1*バージョンを呼び出す古いクライアントを引き続きサポートしながら、互換性に影響する変更を含む*v2*バージョンのサービスを発行することができます。 クライアントが*v2*サービスを使用するように更新したら、古いバージョンを削除することができます。 サービスの複数のバージョンを発行する予定の場合:

- 適切な場合は、重大な変更を避けてください。
- 互換性に影響する変更を行っていない限り、バージョン番号を更新しないでください。
- 互換性に影響する変更を加える場合は、バージョン番号を更新してください。

サービスの複数のバージョンを公開すると、サービスが複製されます。 重複を減らすには、サービス実装から、古い実装と新しい実装で再利用できる集中管理された場所にビジネスロジックを移行することを検討してください。

[!code-csharp[](versioning/sample/GreeterServiceV1.cs?highlight=10,19)]

異なるパッケージ名を使用して生成されたサービスとメッセージは、 **.net の種類**によって異なります。 ビジネスロジックを集中管理された場所に移動するには、メッセージを共通の種類にマッピングする必要があります。
