---
title: ASP.NET Core 2.2 から3.0 プレビューへの移行
author: tdykstra
description: ASP.NET Core 2.2 プロジェクトを ASP.NET Core 3.0 に移行する方法について説明します。
ms.author: tdykstra
ms.custom: mvc
ms.date: 08/05/2019
uid: migration/22-to-30
ms.openlocfilehash: 6312feb05cc917dd28e40b01f51a5fbf31c59e37
ms.sourcegitcommit: 2eb605f4f20ac4dd9de6c3b3e3453e108a357a21
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/06/2019
ms.locfileid: "68819887"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2.2 から3.0 への移行

[Scott Addie](https://github.com/scottaddie)と[Rick Anderson](https://twitter.com/RickAndMSFT)

この記事では、既存の ASP.NET Core 2.2 プロジェクトを ASP.NET Core 3.0 に更新する方法について説明します。

## <a name="prerequisites"></a>必須コンポーネント

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>プロジェクトファイルを更新する

* [ターゲットフレームワークモニカー (TFM)](/dotnet/standard/frameworks)を次の`netcoreapp3.0`ように設定します。

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* [AspNetCore また](xref:fundamentals/metapackage)は[AspNetCore](xref:fundamentals/metapackage-app)メタパッケージのすべてのを削除します。`<PackageReference>`

* [AspNetCore パッケージ](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/)のを削除し`<PackageReference>`ます。

* `<PackageReference>` `3.0.0-preview5-19227-01`パッケージの残り`Microsoft.AspNetCore.*`の要素の属性を現在のプレビューに更新します(`Version`たとえば、)。

  パッケージの3.0 バージョンがない場合、パッケージは3.0 で非推奨とされている可能性があります。 これらのパッケージの多くは、 `Microsoft.AspNetCore.App`の一部であり、個別に参照することはできません。 3\.0 で生成されなくなったパッケージの暫定的な一覧については、「 [3.0 での共有フレームワークアセンブリのパッケージ生成の停止 (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756)」を参照してください。 *共有フレームワーク*は、コンピューターにインストールされ 、によっ`Microsoft.AspNetCore.App`て参照されるアセンブリ (.dll ファイル) のセットです。 詳しくは、[共有フレームワーク](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)に関するページをご覧ください。

* 注目すべきいくつかのコンポーネントのアセンブリ`Microsoft.AspNetCore.App`は、3.0 から削除されました。 AspNetCore `<PackageReference>`から削除するアセンブリに一覧表示されているパッケージの api を使用している場合は、要素を追加します。 [3.0 (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755)。

  削除されるコンポーネントの例を次に示します。

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  で`Microsoft.AspNetCore.App`出荷されたアセンブリの一覧は完了しておらず、3.0 RTM より前に変更されます。

  次のコードがあるとします。

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  前`ReadAsAsync`のコードで呼び出されたメソッドは、 `Microsoft.AspNet.WebApi.Client`に含まれています。 3\.0 でコンパイルの問題を解決するには、 [WebApi](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet パッケージをインストールします。

* [Json.NET サポート](#jsonnet-support)を追加します。

* プロジェクトは、既定では ASP.NET Core 3.0 以降のインプロセス[ホスティングモデル](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model)に設定されます。 必要に応じて、 `<AspNetCoreHostingModel>`プロジェクトファイルのプロパティの値が`InProcess`の場合は、そのプロパティを削除することもできます。

## <a name="jsonnet-support"></a>Json.NET のサポート

[ASP.NET Core 共有フレームワークを改善](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)する作業の一環として、ASP.NET Core 共有フレームワークから[Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)が削除されています。

ASP.NET Core 3.0 プロジェクトで Json.NET を使用するには、次のようにします。

* パッケージへの参照を[AspNetCore](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)に追加します。
* を`Startup.ConfigureServices`呼び出す`AddNewtonsoftJson`ように更新します。

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson`は、新しい MVC サービスの登録方法と互換性があります。

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Json.NET の設定は、の呼び出し`AddNewtonsoftJson`で設定できます。

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC サービスの登録

ASP.NET Core 3.0 では、内`Startup.ConfigureServices`に MVC シナリオを登録するための新しいオプションが追加されています。

の`IServiceCollection` MVC シナリオに関連する3つの新しい最上位レベルの拡張メソッドを使用できます。 テンプレートでは、ではなく`UseMvc`、これらの新しいメソッドを使用します。 ただし、 `AddMvc`は、以前のリリースと同じように動作します。

次の例では、コントローラーと API 関連の機能のサポートを追加しますが、ビューやページはサポートしません。 API テンプレートでは、次のコードを使用します。

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

次の例では、コントローラー、API 関連の機能、およびビューのサポートを追加しますが、ページはサポートしません。 Web アプリケーション (MVC) テンプレートでは、次のコードを使用します。

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

次の例では、Razor Pages と最小コントローラーサポートのサポートが追加されています。 Web アプリケーションテンプレートでは、次のコードを使用します。

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

新しいメソッドを組み合わせることもできます。 次の例は ASP.NET Core 2.2 で`AddMvc`を呼び出すことと同じです。 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>ルーティングのスタートアップコードを更新する

アプリがまたは`UseMvc` `UseSignalR`を呼び出す場合は、可能であれば、[エンドポイントルーティング](xref:fundamentals/routing)にアプリを移行します。 以前のバージョンの MVC とのエンドポイントルーティングの互換性を向上させるために、ASP.NET Core 2.2 で導入された URL 生成の一部の変更を元に戻しました。 2\.2 でエンドポイントルーティングを使用するときに問題が発生した場合は、次の例外が発生して ASP.NET Core 3.0 が改善されることを期待しています。

* アプリがを実装`IRouter`している`Route`か、を継承している場合は、この時点で移行を回避することができます。 [IRouter ベースの実装をエンドポイントルーティングに移行する計画](https://github.com/aspnet/AspNetCore/issues/4221)に関するフィードバックを提供します。

* アプリが MVC 内で`RouteData.Routers`直接アクセスする場合は、現時点で移行を回避することができます。 [RouteData. ルーターを使用するための移行ガイダンス](https://github.com/aspnet/AspNetCore/issues/9148)に関するフィードバックを提供します。

エンドポイントルーティングでは、と同じルートパターン構文とルートパターン`IRouter`作成機能がサポートされています。 エンドポイントルーティング`IRouteContraint`は、をサポートします。 エンドポイントルーティング`[Route]`で`[HttpGet]`は、、、およびその他の MVC ルーティング属性がサポートされます。

ほとんどのアプリケーションでは`Startup` 、変更が必要になるだけです。

### <a name="migrate-startupconfigure"></a>スタートアップを移行します。構成

一般的なアドバイス:

* を`UseRouting`追加します。 
* アプリがを呼び`UseStaticFiles`出す場合`UseStaticFiles`は、の**前に** `UseRouting`配置します。
* アプリ`AuthorizePage`がや `UseCors` `UseAuthorization` `UseAuthentication` `UseRouting`などの認証/承認機能を使用している場合は、(CORS ミドルウェアが使用されている場合は) の後にとの呼び出しを配置します。 `[Authorize]`
* また`UseMvc`は`UseSignalR`をに`UseEndpoints`置き換えます。
* アプリで[cors](xref:security/cors)シナリオ`[EnableCors]`(など) を使用する場合は、cors `UseCors`を使用する他のすべてのミドルウェアの前に、への`UseAuthorization`呼び出しを配置します (たとえば、、、および`UseMvc`の前`UseAuthentication`に配置`UseCors`します)。

一般的な ASP.NET Core 2.2 アプリの`Startup.Configure`の例を次に示します。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

前`Startup.Configure`のコードを更新した後:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>セキュリティミドルウェアのガイダンス

承認と CORS のサポートは、[ミドルウェア](xref:fundamentals/middleware/index)アプローチに関連して統合されています。 これにより、これらのシナリオで同じミドルウェアと機能を使用できるようになります。 このリリースでは、更新された承認ミドルウェアが提供されており、CORS ミドルウェアが拡張され、MVC コントローラーで使用される属性を理解できるようになりました。

#### <a name="cors"></a>CORS

以前は、CORS を構成するのは簡単ではありませんでした。 ミドルウェアは一部のユースケースで使用するために提供されていましたが、MVC フィルターは他のユースケースでミドルウェア**なし**で使用することを意図していました。 ASP.NET Core 3.0 では、CORS を必要とするすべてのアプリで、エンドポイントルーティングと共に CORS ミドルウェアを使用することをお勧めします。 `UseCors`既定のポリシー `[EnableCors]`を使用して指定できます`[DisableCors]` 。また、属性を使用して、必要に応じて既定のポリシーを上書きすることもできます。 

次に例を示します。

* CORS は、 `default`名前付きポリシーが設定されたすべてのエンドポイントに対して有効になります。
* クラス`MyController`は、 `[DisableCors]`属性を使用して CORS を無効にします。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>承認

以前のバージョンの ASP.NET Core では、 `[Authorize]`属性を介して承認のサポートが提供されていました。 承認ミドルウェアを使用できませんでした。 ASP.NET Core 3.0 では、承認ミドルウェアが必要です。 ASP.NET Core 承認ミドルウェア (`UseAuthorization`) は、の`UseAuthentication`直後に配置することをお勧めします。 承認ミドルウェアは、既定のポリシーを使用して構成することもできます。これは上書きできます。

ASP.NET Core 3.0 `UseAuthorization`以降では、はで`Startup.Configure`呼び出され、次`HomeController`のユーザーにはサインインユーザーが必要です。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

アプリが MVC でグローバル`AuthorizeFilter`フィルターとしてを使用している場合は、 `UseAuthorization`ミドルウェアにポリシーを提供するようにコードをリファクタリングすることをお勧めします。

次の例では、が呼び出されたとき`UseAuthorization`にすべての`HomeController`要求に適用されるカスタムポリシーと、ユーザーがアプリにサインインしなくてもアクセスできるようにします。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

ミドルウェアによる承認は、フレームワークが承認に関する特定の知識を持っていなくても機能します。 たとえば、[正常性チェック](xref:host-and-deploy/health-checks)には承認に関する特定の情報はありませんが、正常性チェックには、ミドルウェアによって適用可能な承認ポリシーが設定されている可能性があります。

次の例では`UseAuthorization` 、は既定のポリシーを使用せず`/healthz`に承認を処理しますが、正常性`admin`チェックのエンドポイントではユーザーがロールに含まれている必要があります。 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

一部のシナリオでは、保護が実装されています。 `UseEndpoint`ミドルウェアが不足しているために承認ポリシーまたは CORS ポリシーがスキップされた場合、ミドルウェアは例外をスローします。 構成の誤りに関する追加のフィードバックを提供するアナライザーのサポートが進行中です。

### <a name="migrate-signalr"></a>SignalR の移行

SignalR hub のマッピングは、の内部`UseEndpoints`で行われるようになりました。 

各ハブをに`MapHub`マップします。 以前のバージョンと同様に、各ハブが明示的に一覧表示されています。

次の例では、 `ChatHub` SignalR hub のサポートが追加されています。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>MVC コントローラーの移行

コントローラーのマッピングは、の内部`UseEndpoints`で行われるようになりました。 

アプリ`MapControllers`が属性ルーティングを使用する場合は、を追加します。 ルーティングには ASP.NET Core 3.0 以降の多くのフレームワークのサポートが含まれているため、属性ルーティングコントローラーの追加はオプトインされています。 

次の部分を探します。

* `MapRoute`で`MapControllerRoute`
* `MapAreaRoute`で`MapAreaControllerRoute`

現在、ルーティングには MVC 以外のサポートが含まれているので、これらの方法を明確に示すために用語が変更されています。 など`MapControllerRoute`の従来の`MapDefaultControllerRoute`ルート/ `MapAreaControllerRoute` は、追加された順序で適用されます。/ まず、特定のルート (区分のルートなど) を配置します。

次に例を示します。

* `MapControllers`属性ルーティングコントローラーのサポートを追加します。
* `MapAreaControllerRoute`領域内にコントローラーの従来のルートを追加します。
* `MapControllerRoute`コントローラーの従来のルートを追加します。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>移行 Razor Pages

マッピング Razor Pages は、の内部`UseEndpoints`で行われるようになりました。

アプリ`MapRazorPages`が Razor Pages を使用する場合は、を追加します。 エンドポイントルーティングには多くのフレームワークがサポートされているため、Razor Pages の追加はオプトインになりました。

次の例では`MapRazorPages` 、に Razor Pages のサポートが追加されています。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>エンドポイントルーティングなしで MVC を使用する

`UseMvc`または ASP.NET Core 3.0 `UseMvcWithDefaultRoute`で MVC を使用するには、内`Startup.ConfigureServices`に明示的なオプトインが必要です。 これは、MVC が初期化中に承認と CORS ミドルウェアに依存できるかどうかを確認する必要があるためです。 アプリケーションがサポートされていない構成を使用しようとした場合に警告するアナライザーが用意されています。

アプリでレガシ`IRouter`サポートが必要な場合`EnableEndpointRouting`は、で`Startup.ConfigureServices`次のいずれかの方法を使用しないようにします。

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>正常性チェックの移行

正常性チェックは、エンドポイントルーティングを使用した*ルーターウェア*として使用できます。

エンド`MapHealthChecks`ポイントルーティングで正常性チェックを使用するには、を追加します。 メソッド`MapHealthChecks`は、のような`UseHealthChecks`引数を受け取ります。 `MapHealthChecks` Over`UseHealthChecks`を使用する利点は、承認を適用し、照合ポリシーをより詳細に制御できるようにすることです。 

次の例では`MapHealthChecks` 、正常性チェックの`/healthz`エンドポイントに対してが呼び出されます。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder が WebHostBuilder を置き換える

ASP.NET Core 3.0 テンプレートでは、[汎用ホスト](xref:fundamentals/host/generic-host)を使用します。 以前のバージョンの[Web ホスト](xref:fundamentals/host/web-host)が使用されていました。 次のコードは、ASP.NET Core 3.0 テンプレートに`Program`よって生成されたクラスを示しています。

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

次のコードは、ASP.NET Core 2.2 テンプレートで生成`Program`されたクラスを示しています。

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>は3.0 に残り、は前のコード`webBuilder`サンプルで見たの型です。 <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>今後のリリースで非推奨となり、に`HostBuilder`置き換えられます。

から`WebHostBuilder` へ`HostBuilder`の最も重要な変更は、[依存関係の挿入 (DI)](xref:fundamentals/dependency-injection)です。 を使用`HostBuilder`する場合、 <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment>と`Startup`の<xref:Microsoft.Extensions.Configuration.IConfiguration>コンストラクターのみを挿入できます。 `HostBuilder` DI 制約:

* DI コンテナーを1回だけビルドできるようにします。
* シングルトンの複数のインスタンスを解決するなど、結果として得られるオブジェクトの有効期間の問題を回避します。

## <a name="update-signalr-code"></a>SignalR コードの更新

`System.Text.Json`は、クライアントとサーバーの両方で使用される既定のハブプロトコルになりました。

で`Startup.ConfigureServices`、を`AddJsonProtocol`呼び出して、シリアライザーオプションを設定します。

**Server**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**クライアント:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft. Json に切り替える

で`Newtonsoft.Json` `Newtonsoft.Json`サポートされていないの機能を使用している場合は、次のように切り替えることができます。 `System.Text.Json`

1. [AspNetCore. SignalR の json](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson)パッケージをインストールしてください。
1. クライアントで、 `AddNewtonsoftJsonProtocol`メソッド呼び出しを`HubConnectionBuilder`インスタンスにチェーンします。

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. サーバーで、 `AddNewtonsoftJsonProtocol`メソッド呼び出し`AddSignalR`をの`Startup.ConfigureServices`メソッド呼び出しにチェーンします。

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>ランタイムコンパイルをオプトインする

3\.0 では、ランタイムコンパイルはオプトインシナリオです。 ランタイムコンパイルを有効にする https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation には、「」を参照してください。
