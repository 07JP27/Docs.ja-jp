---
title: "フィルター"
author: ardalis
description: "*フィルター*のしくみと、ASP.NET Core MVC での使用方法について説明します。"
manager: wpickett
ms.author: tdykstra
ms.date: 12/12/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/filters
ms.openlocfilehash: 2ba3c226cc57f8a3fb26b4119ae9e575eff522f9
ms.sourcegitcommit: f2a11a89037471a77ad68a67533754b7bb8303e2
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/01/2018
---
# <a name="filters"></a><span data-ttu-id="2c43a-103">フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-103">Filters</span></span>

<span data-ttu-id="2c43a-104">作成者: [Tom Dykstra](https://github.com/tdykstra/)、[Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="2c43a-104">By [Tom Dykstra](https://github.com/tdykstra/) and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="2c43a-105">ASP.NET Core MVC で*フィルター*を使用すると、要求処理パイプラインの特定のステージの前または後にコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-105">*Filters* in ASP.NET Core MVC allow you to run code before or after certain stages in the request processing pipeline.</span></span>

 <span data-ttu-id="2c43a-106">組み込みフィルターは、承認 (承認されていないユーザーのリソースへのアクセスを防止する)、すべての要求が HTTPS を使用していることの保証、および応答のキャッシュ (要求パイプラインをショート サーキットしてキャッシュされた応答を返す) などのタスクを処理します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-106">Built-in filters handle tasks such as authorization (preventing access to resources a user isn't authorized for), ensuring that all requests use HTTPS, and response caching (short-circuiting the request pipeline to return a cached response).</span></span> 

<span data-ttu-id="2c43a-107">カスタム フィルターを作成してアプリケーションの横断的な問題を処理することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-107">You can create custom filters to handle cross-cutting concerns for your application.</span></span> <span data-ttu-id="2c43a-108">アクション間でのコードの重複を避けたい場合には、フィルターが解決策になります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-108">Anytime you want to avoid duplicating code across actions, filters are the solution.</span></span> <span data-ttu-id="2c43a-109">たとえば、エラー処理コードを例外フィルターに統合することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-109">For example, you can consolidate error handling code in a exception filter.</span></span>

<span data-ttu-id="2c43a-110">[GitHub のサンプルを表示またはダウンロードする](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample)。</span><span class="sxs-lookup"><span data-stu-id="2c43a-110">[View or download sample from GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).</span></span>

## <a name="how-do-filters-work"></a><span data-ttu-id="2c43a-111">フィルターのしくみ</span><span class="sxs-lookup"><span data-stu-id="2c43a-111">How do filters work?</span></span>

<span data-ttu-id="2c43a-112">*MVC のアクション呼び出しパイプライン*内で実行されるフィルターは、*フィルター パイプライン*と呼ばれることがあります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-112">Filters run within the *MVC action invocation pipeline*, sometimes referred to as the *filter pipeline*.</span></span>  <span data-ttu-id="2c43a-113">フィルター パイプラインは、MVC が実行するアクションを選択した後に実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-113">The filter pipeline runs after MVC selects the action to execute.</span></span>

![要求は、他のミドルウェア、ルーティング ミドルウェア、アクション選択、および MVC のアクション呼び出しパイプラインを通じて処理されます。](filters/_static/filter-pipeline-1.png)

### <a name="filter-types"></a><span data-ttu-id="2c43a-116">フィルターの種類</span><span class="sxs-lookup"><span data-stu-id="2c43a-116">Filter types</span></span>

<span data-ttu-id="2c43a-117">フィルターの種類はそれぞれ、フィルター パイプラインの異なるステージで実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-117">Each filter type is executed at a different stage in the filter pipeline.</span></span>

* <span data-ttu-id="2c43a-118">[承認フィルター](#authorization-filters)は、最初に実行され、現在のユーザーが現在の要求に対して承認されているかどうかを判断するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-118">[Authorization filters](#authorization-filters) run first and are used to determine whether the current user is authorized for the current request.</span></span> <span data-ttu-id="2c43a-119">要求が承認されていない場合は、パイプラインをショートサーキットできます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-119">They can short-circuit the pipeline if a request is unauthorized.</span></span> 

* <span data-ttu-id="2c43a-120">[リソース フィルター](#resource-filters)は、承認後、最初に要求を処理します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-120">[Resource filters](#resource-filters) are the first to handle a request after authorization.</span></span>  <span data-ttu-id="2c43a-121">このフィルターは、残りのフィルター パイプラインの完了前と完了後にコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-121">They can run code before the rest of the filter pipeline, and after the rest of the pipeline has completed.</span></span> <span data-ttu-id="2c43a-122">キャッシュを実装するか、そうでない場合はパフォーマンス上の理由からフィルター パイプラインをショートサーキットする場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="2c43a-122">They're useful to implement caching or otherwise short-circuit the filter pipeline for performance reasons.</span></span> <span data-ttu-id="2c43a-123">このフィルターはモデル バインドの前に実行されるため、モデル バインドに影響を与える必要があるすべてのものに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-123">Since they run before model binding, they're useful for anything that needs to influence model binding.</span></span>

* <span data-ttu-id="2c43a-124">[アクション フィルター](#action-filters)は、個々のアクション メソッドが呼び出される直前と直後にコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-124">[Action filters](#action-filters) can run code immediately before and after an individual action method is called.</span></span> <span data-ttu-id="2c43a-125">アクションに渡される引数とアクションから返される結果を操作するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-125">They can be used to manipulate the arguments passed into an action and the result returned from the action.</span></span>

* <span data-ttu-id="2c43a-126">[例外フィルター](#exception-filters)は、応答本文に何かが書き込まれる前に発生する未処理の例外にグローバル ポリシーを適用するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-126">[Exception filters](#exception-filters) are used to apply global policies to unhandled exceptions that occur before anything has been written to the response body.</span></span>

* <span data-ttu-id="2c43a-127">[結果フィルター](#result-filters)は、個々のアクション結果の実行の直前と直後にコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-127">[Result filters](#result-filters) can run code immediately before and after the execution of individual action results.</span></span> <span data-ttu-id="2c43a-128">このフィルターは、アクション メソッドが正常に実行された場合にのみ実行され、ビューまたはフォーマッタの実行を囲む必要があるロジックに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-128">They run only when the action method has executed successfully and are useful for logic that must surround view or formatter execution.</span></span>

<span data-ttu-id="2c43a-129">これらのフィルターの種類がフィルター パイプラインでどのように連携しているかを、次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-129">The following diagram shows how these filter types interact in the filter pipeline.</span></span>

![要求は、承認フィルター、リソース フィルター、モデル バインド、アクション フィルター、アクションの実行とアクション結果の変換、例外フィルター、結果フィルター、結果の実行を介して処理されます。](filters/_static/filter-pipeline-2.png)

## <a name="implementation"></a><span data-ttu-id="2c43a-132">実装</span><span class="sxs-lookup"><span data-stu-id="2c43a-132">Implementation</span></span>

<span data-ttu-id="2c43a-133">フィルターは、異なるインターフェイス定義を介して、同期と非同期の実装をサポートします。</span><span class="sxs-lookup"><span data-stu-id="2c43a-133">Filters support both synchronous and asynchronous implementations through different interface definitions.</span></span> <span data-ttu-id="2c43a-134">実行する必要があるタスクの種類に応じて、同期または非同期のバリアントを選択します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-134">Choose either the sync or async variant depending on the kind of task you need to perform.</span></span> 

<span data-ttu-id="2c43a-135">パイプライン ステージの前後でコードを実行できる同期フィルターは、On*Stage*Executing メソッドと On*Stage*Executed メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-135">Synchronous filters that can run code both before and after their pipeline stage define On*Stage*Executing and On*Stage*Executed methods.</span></span> <span data-ttu-id="2c43a-136">たとえば、`OnActionExecuting` はアクション メソッドが呼び出される前に呼び出され、`OnActionExecuted` はアクション メソッドが返された後に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-136">For example, `OnActionExecuting` is called before the action method is called, and `OnActionExecuted` is called after the action method returns.</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?highlight=6,8,13)]

<span data-ttu-id="2c43a-137">非同期フィルターは、1 つの On*Stage*ExecutionAsync メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-137">Asynchronous filters define a single On*Stage*ExecutionAsync method.</span></span> <span data-ttu-id="2c43a-138">このメソッドは、フィルターのパイプライン ステージを実行する *FilterType*ExecutionDelegate デリゲートを取得します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-138">This method takes a *FilterType*ExecutionDelegate delegate which executes the filter's pipeline stage.</span></span> <span data-ttu-id="2c43a-139">たとえば、`ActionExecutionDelegate` はアクション メソッドを呼び出すので、その呼び出しの前後でコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-139">For example, `ActionExecutionDelegate` calls the action method, and you can execute code before and after you call it.</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleAsyncActionFilter.cs?highlight=6,8-10,13)]

<span data-ttu-id="2c43a-140">1 つのクラスで複数のフィルター ステージに対してインターフェイスを実装することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-140">You can implement interfaces for multiple filter stages in a single class.</span></span> <span data-ttu-id="2c43a-141">たとえば、[ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) 抽象クラスは、`IActionFilter` と `IResultFilter` の両方と、それらの非同期バージョンを実装します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-141">For example, the [ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) abstract class implements both `IActionFilter` and `IResultFilter`, as well as their async equivalents.</span></span>

> [!NOTE]
> <span data-ttu-id="2c43a-142">フィルター インターフェイスの同期と非同期バージョンの両方ではなく、**いずれか**を実装します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-142">Implement **either** the synchronous or the async version of a filter interface, not both.</span></span> <span data-ttu-id="2c43a-143">フレームワークは、最初にフィルターが非同期インターフェイスを実装しているかどうかをチェックして、している場合はそれを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-143">The framework checks first to see if the filter implements the async interface, and if so, it calls that.</span></span> <span data-ttu-id="2c43a-144">していない場合は、同期インターフェイスのメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-144">If not, it calls the synchronous interface's method(s).</span></span> <span data-ttu-id="2c43a-145">1 つのクラスに両方のインターフェイスを実装すると、非同期のメソッドのみが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-145">If you were to implement both interfaces on one class, only the async method would be called.</span></span> <span data-ttu-id="2c43a-146">[ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) などの抽象クラスを使用する場合は、同期メソッドのみを上書きするか、フィルターの種類ごとに非同期メソッドを上書きします。</span><span class="sxs-lookup"><span data-stu-id="2c43a-146">When using abstract classes like [ActionFilterAttribute](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute) you would override only the synchronous methods or the async method for each filter type.</span></span>

### <a name="ifilterfactory"></a><span data-ttu-id="2c43a-147">IFilterFactory</span><span class="sxs-lookup"><span data-stu-id="2c43a-147">IFilterFactory</span></span>

<span data-ttu-id="2c43a-148">`IFilterFactory` は、`IFilter` を実装します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-148">`IFilterFactory` implements `IFilter`.</span></span> <span data-ttu-id="2c43a-149">そのため、`IFilterFactory` インスタンスはフィルター パイプライン内の任意の場所で `IFilter` インスタンスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-149">Therefore, an `IFilterFactory` instance can be used as an `IFilter` instance anywhere in the filter pipeline.</span></span> <span data-ttu-id="2c43a-150">フレームワークは、フィルターを呼び出す準備をする際に、それを `IFilterFactory` にキャストしようとします。</span><span class="sxs-lookup"><span data-stu-id="2c43a-150">When the framework prepares to invoke the filter, it attempts to cast it to an `IFilterFactory`.</span></span> <span data-ttu-id="2c43a-151">そのキャストが成功した場合、呼び出される `IFilter` インスタンスを作成するために `CreateInstance` メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-151">If that cast succeeds, the `CreateInstance` method is called to create the `IFilter` instance that will be invoked.</span></span> <span data-ttu-id="2c43a-152">これにより、アプリケーションの起動時に正確なフィルター パイプラインを明示的に設定する必要がないため、非常に柔軟なデザインが可能になります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-152">This provides a very flexible design, since the precise filter pipeline doesn't need to be set explicitly when the application starts.</span></span>

<span data-ttu-id="2c43a-153">フィルターを作成するための別の方法として、独自の属性の実装で `IFilterFactory` を実装できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-153">You can implement `IFilterFactory` on your own attribute implementations as another approach to creating filters:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/AddHeaderWithFactoryAttribute.cs?name=snippet_IFilterFactory&highlight=1,4,5,6,7)]

### <a name="built-in-filter-attributes"></a><span data-ttu-id="2c43a-154">組み込みのフィルター属性</span><span class="sxs-lookup"><span data-stu-id="2c43a-154">Built-in filter attributes</span></span>

<span data-ttu-id="2c43a-155">フレームワークには、サブクラスを作成したりカスタマイズしたりできる組み込みの属性ベースのフィルターが含まれます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-155">The framework includes built-in attribute-based filters that you can subclass and customize.</span></span> <span data-ttu-id="2c43a-156">たとえば、次の結果フィルターは、応答にヘッダーを追加します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-156">For example, the following Result filter adds a header to the response.</span></span>

<a name="add-header-attribute"></a>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/AddHeaderAttribute.cs?highlight=5,16)]

<span data-ttu-id="2c43a-157">属性は、上記の例のように、フィルターが引数を受け取れるようにします。</span><span class="sxs-lookup"><span data-stu-id="2c43a-157">Attributes allow filters to accept arguments, as shown in the example above.</span></span> <span data-ttu-id="2c43a-158">この属性をコントローラーまたはアクション メソッドに追加し、HTTP ヘッダーの名前と値を指定します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-158">You would add this attribute to a controller or action method and specify the name and value of the HTTP header:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1)]

<span data-ttu-id="2c43a-159">`Index` アクションの結果を次に示します。応答ヘッダーが右下に表示されています。</span><span class="sxs-lookup"><span data-stu-id="2c43a-159">The result of the `Index` action is shown below - the response headers are displayed on the bottom right.</span></span>

![("Author Steve Smith @ardalis" が含まれている) 応答ヘッダーを表示している Microsoft Edge の開発者ツール](filters/_static/add-header.png)

<span data-ttu-id="2c43a-161">フィルター インターフェイスのいくつかには対応する属性があり、カスタムの実装に基底クラスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-161">Several of the filter interfaces have corresponding attributes that can be used as base classes for custom implementations.</span></span>

<span data-ttu-id="2c43a-162">フィルター属性:</span><span class="sxs-lookup"><span data-stu-id="2c43a-162">Filter attributes:</span></span>

* `ActionFilterAttribute`
* `ExceptionFilterAttribute`
* `ResultFilterAttribute`
* `FormatFilterAttribute`
* `ServiceFilterAttribute`
* `TypeFilterAttribute`

<span data-ttu-id="2c43a-163">`TypeFilterAttribute` と `ServiceFilterAttribute` については、[この記事で後ほど](#dependency-injection)説明します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-163">`TypeFilterAttribute` and `ServiceFilterAttribute` are explained [later in this article](#dependency-injection).</span></span>

## <a name="filter-scopes-and-order-of-execution"></a><span data-ttu-id="2c43a-164">フィルターのスコープと実行の順序</span><span class="sxs-lookup"><span data-stu-id="2c43a-164">Filter scopes and order of execution</span></span>

<span data-ttu-id="2c43a-165">フィルターは、3 つの*スコープ*のいずれかでパイプラインに追加することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-165">A filter can be added to the pipeline at one of three *scopes*.</span></span> <span data-ttu-id="2c43a-166">属性を使用して、特定のアクション メソッドまたはコントローラー クラスにフィルターを追加できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-166">You can add a filter to a particular action method or to a controller class by using an attribute.</span></span> <span data-ttu-id="2c43a-167">または、フィルターを (すべてのコント ローラーとアクション用に) グローバルに登録することができます。これには、フィルターを `Startup` クラス内の `ConfigureServices` メソッドの `MvcOptions.Filters` コレクションに追加します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-167">Or you can register a filter globally (for all controllers and actions) by adding it to the `MvcOptions.Filters` collection in the `ConfigureServices` method in the `Startup` class:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=5-8)]

### <a name="default-order-of-execution"></a><span data-ttu-id="2c43a-168">実行の既定の順序</span><span class="sxs-lookup"><span data-stu-id="2c43a-168">Default order of execution</span></span>

<span data-ttu-id="2c43a-169">パイプラインの特定のステージに対して複数のフィルターがある場合に、スコープがフィルターの実行の既定の順序を決定します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-169">When there are multiple filters for a particular stage of the pipeline, scope determines the default order of filter execution.</span></span>  <span data-ttu-id="2c43a-170">グローバル フィルターがクラス フィルターを囲み、クラス フィルターがメソッド フィルターを囲みます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-170">Global filters surround class filters, which in turn surround method filters.</span></span> <span data-ttu-id="2c43a-171">これは、[入れ子人形](https://wikipedia.org/wiki/Matryoshka_doll)のように、スコープが前のスコープを囲むたびに大きくなることから、"マトリョーシカ人形" 入れ子と呼ばれることがあります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-171">This is sometimes referred to as "Russian doll" nesting, as each increase in scope is wrapped around the previous scope, like a [nesting doll](https://wikipedia.org/wiki/Matryoshka_doll).</span></span> <span data-ttu-id="2c43a-172">通常は、明示的に順序を決定しなくても、目的の上書き動作が得られます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-172">You generally get the desired overriding behavior without having to explicitly determine ordering.</span></span>

<span data-ttu-id="2c43a-173">この入れ子の結果として、フィルターの *after* コードが *before* コードと逆の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-173">As a result of this nesting, the *after* code of filters runs in the reverse order of the *before* code.</span></span> <span data-ttu-id="2c43a-174">シーケンスは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-174">The sequence looks like this:</span></span>

* <span data-ttu-id="2c43a-175">グローバルに適用されるフィルターの *before* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-175">The *before* code of filters applied globally</span></span>
  * <span data-ttu-id="2c43a-176">コントローラーに適用されるフィルターの *before* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-176">The *before* code of filters applied to controllers</span></span>
    * <span data-ttu-id="2c43a-177">アクション メソッドに適用されるフィルターの *before* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-177">The *before* code of filters applied to action methods</span></span>
    * <span data-ttu-id="2c43a-178">アクション メソッドに適用されるフィルターの *after* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-178">The *after* code of filters applied to action methods</span></span>
  * <span data-ttu-id="2c43a-179">コントローラーに適用されるフィルターの *after* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-179">The *after* code of filters applied to controllers</span></span>
* <span data-ttu-id="2c43a-180">グローバルに適用されるフィルターの *after* コード</span><span class="sxs-lookup"><span data-stu-id="2c43a-180">The *after* code of filters applied globally</span></span>
  
<span data-ttu-id="2c43a-181">同期アクション フィルターに対して呼び出されるフィルター メソッドの順序を示す例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-181">Here's an example that illustrates the order in which filter methods are called for synchronous Action filters.</span></span>

| <span data-ttu-id="2c43a-182">シーケンス</span><span class="sxs-lookup"><span data-stu-id="2c43a-182">Sequence</span></span> | <span data-ttu-id="2c43a-183">フィルターのスコープ</span><span class="sxs-lookup"><span data-stu-id="2c43a-183">Filter scope</span></span> | <span data-ttu-id="2c43a-184">フィルター メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-184">Filter method</span></span> |
|:--------:|:------------:|:-------------:|
| <span data-ttu-id="2c43a-185">1</span><span class="sxs-lookup"><span data-stu-id="2c43a-185">1</span></span> | <span data-ttu-id="2c43a-186">Global</span><span class="sxs-lookup"><span data-stu-id="2c43a-186">Global</span></span> | `OnActionExecuting` |
| <span data-ttu-id="2c43a-187">2</span><span class="sxs-lookup"><span data-stu-id="2c43a-187">2</span></span> | <span data-ttu-id="2c43a-188">コントローラー</span><span class="sxs-lookup"><span data-stu-id="2c43a-188">Controller</span></span> | `OnActionExecuting` |
| <span data-ttu-id="2c43a-189">3</span><span class="sxs-lookup"><span data-stu-id="2c43a-189">3</span></span> | <span data-ttu-id="2c43a-190">メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-190">Method</span></span> | `OnActionExecuting` |
| <span data-ttu-id="2c43a-191">4</span><span class="sxs-lookup"><span data-stu-id="2c43a-191">4</span></span> | <span data-ttu-id="2c43a-192">メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-192">Method</span></span> | `OnActionExecuted` |
| <span data-ttu-id="2c43a-193">5</span><span class="sxs-lookup"><span data-stu-id="2c43a-193">5</span></span> | <span data-ttu-id="2c43a-194">コントローラー</span><span class="sxs-lookup"><span data-stu-id="2c43a-194">Controller</span></span> | `OnActionExecuted` |
| <span data-ttu-id="2c43a-195">6</span><span class="sxs-lookup"><span data-stu-id="2c43a-195">6</span></span> | <span data-ttu-id="2c43a-196">Global</span><span class="sxs-lookup"><span data-stu-id="2c43a-196">Global</span></span> | `OnActionExecuted` |

<span data-ttu-id="2c43a-197">このシーケンスは、メソッド フィルターが、コントローラー フィルター内で入れ子になっていて、コントローラー フィルターがグローバル フィルター内で入れ子になっていることを示しています。</span><span class="sxs-lookup"><span data-stu-id="2c43a-197">This sequence shows that the method filter is nested within the controller filter, and the controller filter is nested within the global filter.</span></span> <span data-ttu-id="2c43a-198">別の言い方をすると、非同期フィルターの On*Stage*ExecutionAsync メソッド内にいる場合、コードがスタックにある間に、厳密なスコープを持つすべてのフィルターが実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-198">To put it another way, if you're inside an async filter's On*Stage*ExecutionAsync method, all of the filters with a tighter scope run while your code is on the stack.</span></span>

> [!NOTE]
> <span data-ttu-id="2c43a-199">`Controller` 基底クラスから継承するすべてのコントローラーには、`OnActionExecuting` メソッドと `OnActionExecuted` メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-199">Every controller that inherits from the `Controller` base class includes `OnActionExecuting` and `OnActionExecuted` methods.</span></span> <span data-ttu-id="2c43a-200">これらのメソッドは、特定のアクションに対して実行されるフィルターをラップします。`OnActionExecuting` はどのフィルターよりも前に呼び出され、`OnActionExecuted` はすべてのフィルターの後に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-200">These methods wrap the filters that run for a given action:  `OnActionExecuting` is called before any of the filters, and `OnActionExecuted` is called after all of the filters.</span></span>

### <a name="overriding-the-default-order"></a><span data-ttu-id="2c43a-201">既定の順序の上書き</span><span class="sxs-lookup"><span data-stu-id="2c43a-201">Overriding the default order</span></span>

<span data-ttu-id="2c43a-202">`IOrderedFilter` を実装することで、実行の既定の順序を上書きできます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-202">You can override the default sequence of execution by implementing `IOrderedFilter`.</span></span> <span data-ttu-id="2c43a-203">このインターフェイスは、実行の順序を決定するために、スコープよりも優先される `Order` プロパティを公開します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-203">This interface exposes an `Order` property that takes precedence over scope to determine the order of execution.</span></span> <span data-ttu-id="2c43a-204">`Order` 値が低いフィルターがその *before* コードを、その `Order` の高い値よりも前に実行させます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-204">A filter with a lower `Order` value will have its *before* code executed before that of a filter with a higher value of `Order`.</span></span> <span data-ttu-id="2c43a-205">`Order` 値が低いフィルターがその *after* コードを、その高い `Order` の値よりも後に実行させます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-205">A filter with a lower `Order` value will have its *after* code executed after that of a filter with a higher `Order` value.</span></span> <span data-ttu-id="2c43a-206">`Order` プロパティは、コンストラクター パラメーターを使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-206">You can set the `Order` property by using a constructor parameter:</span></span>

```csharp
[MyFilter(Name = "Controller Level Attribute", Order=1)]
```

<span data-ttu-id="2c43a-207">上記の例で示されているのと同じ 3 つのアクション フィルターがあるが、コントローラーとグローバル フィルターの `Order` プロパティがそれぞれ 1 と 2 に設定されている場合、実行の順序が逆になります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-207">If you have the same 3 Action filters shown in the preceding example but set the `Order` property of the controller and global filters to 1 and 2 respectively, the order of execution would be reversed.</span></span>

| <span data-ttu-id="2c43a-208">シーケンス</span><span class="sxs-lookup"><span data-stu-id="2c43a-208">Sequence</span></span> | <span data-ttu-id="2c43a-209">フィルターのスコープ</span><span class="sxs-lookup"><span data-stu-id="2c43a-209">Filter scope</span></span> | <span data-ttu-id="2c43a-210">`Order` プロパティ</span><span class="sxs-lookup"><span data-stu-id="2c43a-210">`Order` property</span></span> | <span data-ttu-id="2c43a-211">フィルター メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-211">Filter method</span></span> |
|:--------:|:------------:|:-----------------:|:-------------:|
| <span data-ttu-id="2c43a-212">1</span><span class="sxs-lookup"><span data-stu-id="2c43a-212">1</span></span> | <span data-ttu-id="2c43a-213">メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-213">Method</span></span> | <span data-ttu-id="2c43a-214">0</span><span class="sxs-lookup"><span data-stu-id="2c43a-214">0</span></span> | `OnActionExecuting` |
| <span data-ttu-id="2c43a-215">2</span><span class="sxs-lookup"><span data-stu-id="2c43a-215">2</span></span> | <span data-ttu-id="2c43a-216">コントローラー</span><span class="sxs-lookup"><span data-stu-id="2c43a-216">Controller</span></span> | <span data-ttu-id="2c43a-217">1</span><span class="sxs-lookup"><span data-stu-id="2c43a-217">1</span></span>  | `OnActionExecuting` |
| <span data-ttu-id="2c43a-218">3</span><span class="sxs-lookup"><span data-stu-id="2c43a-218">3</span></span> | <span data-ttu-id="2c43a-219">Global</span><span class="sxs-lookup"><span data-stu-id="2c43a-219">Global</span></span> | <span data-ttu-id="2c43a-220">2</span><span class="sxs-lookup"><span data-stu-id="2c43a-220">2</span></span>  | `OnActionExecuting` |
| <span data-ttu-id="2c43a-221">4</span><span class="sxs-lookup"><span data-stu-id="2c43a-221">4</span></span> | <span data-ttu-id="2c43a-222">Global</span><span class="sxs-lookup"><span data-stu-id="2c43a-222">Global</span></span> | <span data-ttu-id="2c43a-223">2</span><span class="sxs-lookup"><span data-stu-id="2c43a-223">2</span></span>  | `OnActionExecuted` |
| <span data-ttu-id="2c43a-224">5</span><span class="sxs-lookup"><span data-stu-id="2c43a-224">5</span></span> | <span data-ttu-id="2c43a-225">コントローラー</span><span class="sxs-lookup"><span data-stu-id="2c43a-225">Controller</span></span> | <span data-ttu-id="2c43a-226">1</span><span class="sxs-lookup"><span data-stu-id="2c43a-226">1</span></span>  | `OnActionExecuted` |
| <span data-ttu-id="2c43a-227">6</span><span class="sxs-lookup"><span data-stu-id="2c43a-227">6</span></span> | <span data-ttu-id="2c43a-228">メソッド</span><span class="sxs-lookup"><span data-stu-id="2c43a-228">Method</span></span> | <span data-ttu-id="2c43a-229">0</span><span class="sxs-lookup"><span data-stu-id="2c43a-229">0</span></span>  | `OnActionExecuted` |

<span data-ttu-id="2c43a-230">フィルターの実行順序を決定するときに、`Order` プロパティはスコープより優先されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-230">The `Order` property trumps scope when determining the order in which filters will run.</span></span> <span data-ttu-id="2c43a-231">最初に順序でフィルターが並べ替えられ、次に同じ順位の優先度を決めるためにスコープが使用されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-231">Filters are sorted first by order, then scope is used to break ties.</span></span> <span data-ttu-id="2c43a-232">すべての組み込みフィルターは `IOrderedFilter` を実装し、既定の `Order` 値を 0 に設定するため、`Order` を 0 以外の値に設定しない限り、スコープによって順序が決定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-232">All of the built-in filters implement `IOrderedFilter` and set the default `Order` value to 0, so scope determines order unless you set `Order` to a non-zero value.</span></span>

## <a name="cancellation-and-short-circuiting"></a><span data-ttu-id="2c43a-233">キャンセルとショート サーキット</span><span class="sxs-lookup"><span data-stu-id="2c43a-233">Cancellation and short circuiting</span></span>

<span data-ttu-id="2c43a-234">フィルター メソッドに提供される `context` パラメーターで `Result` プロパティを設定することで、フィルター パイプラインを任意の時点でショート サーキットできます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-234">You can short-circuit the filter pipeline at any point by setting the `Result` property on the `context` parameter provided to the filter method.</span></span> <span data-ttu-id="2c43a-235">たとえば、次のリソース フィルターは、パイプラインの残りの部分が実行されるのを防止します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-235">For instance, the following Resource filter prevents the rest of the pipeline from executing.</span></span>

<a name="short-circuiting-resource-filter"></a>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/ShortCircuitingResourceFilterAttribute.cs?highlight=12,13,14,15)]

<span data-ttu-id="2c43a-236">次のコードでは、`ShortCircuitingResourceFilter` と `AddHeader` の両方のフィルターが `SomeResource` アクション メソッドをターゲットにしています。</span><span class="sxs-lookup"><span data-stu-id="2c43a-236">In the following code, both the `ShortCircuitingResourceFilter` and the `AddHeader` filter target the `SomeResource` action method.</span></span> <span data-ttu-id="2c43a-237">ただし、`ShortCircuitingResourceFilter` が最初に実行され (これがリソース フィルターで、`AddHeader` がアクション フィルターであるため)、パイプラインの残りの部分がショートカットされるため、`AddHeader` フィルターが `SomeResource` アクションに対して実行されることはありません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-237">However, because the `ShortCircuitingResourceFilter` runs first (because it's a Resource Filter and `AddHeader` is an Action Filter) and short-circuits the rest of the pipeline, the `AddHeader` filter never runs for the `SomeResource` action.</span></span> <span data-ttu-id="2c43a-238">(たとえば、フィルターの種類、または `Order` プロパティの明示的な使用により) `ShortCircuitingResourceFilter` が最初に実行された場合は、両方のフィルターがアクション メソッド レベルで適用されると、この動作が同じになります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-238">This behavior would be the same if both filters were applied at the action method level, provided the `ShortCircuitingResourceFilter` ran first (because of its filter type, or explicit use of `Order` property, for instance).</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1,9)]

## <a name="dependency-injection"></a><span data-ttu-id="2c43a-239">依存関係の挿入</span><span class="sxs-lookup"><span data-stu-id="2c43a-239">Dependency injection</span></span>

<span data-ttu-id="2c43a-240">フィルターは種類ごとまたはインスタンスごとに追加できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-240">Filters can be added by type or by instance.</span></span> <span data-ttu-id="2c43a-241">インスタンスを追加する場合、そのインスタンスがすべての要求に対して使用されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-241">If you add an instance, that instance will be used for every request.</span></span> <span data-ttu-id="2c43a-242">種類を追加すると、種類でアクティブ化されます。つまり、要求ごとにインスタンスが作成され、[依存関係の挿入](../../fundamentals/dependency-injection.md) (DI) によってコンストラクターの依存関係が設定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-242">If you add a type, it will be type-activated, meaning an instance will be created for each request and any constructor dependencies will be populated by [dependency injection](../../fundamentals/dependency-injection.md) (DI).</span></span> <span data-ttu-id="2c43a-243">種類ごとにフィルターを追加するのは、`filters.Add(new TypeFilterAttribute(typeof(MyFilter)))` に相当します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-243">Adding a filter by type is equivalent to `filters.Add(new TypeFilterAttribute(typeof(MyFilter)))`.</span></span>

<span data-ttu-id="2c43a-244">属性として実装され、コントローラー クラスまたはアクション メソッドに直接追加されるフィルターは、[依存関係の挿入](../../fundamentals/dependency-injection.md) (DI) によって提供されるコンストラクターの依存関係を持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-244">Filters that are implemented as attributes and added directly to controller classes or action methods cannot have constructor dependencies provided by [dependency injection](../../fundamentals/dependency-injection.md) (DI).</span></span> <span data-ttu-id="2c43a-245">これは、属性には、適用される場所で提供される独自のコンストラクター パラメーターが必要だからです。</span><span class="sxs-lookup"><span data-stu-id="2c43a-245">This is because attributes must have their constructor parameters supplied where they're applied.</span></span> <span data-ttu-id="2c43a-246">これは、属性のしくみの制限です。</span><span class="sxs-lookup"><span data-stu-id="2c43a-246">This is a limitation of how attributes work.</span></span>

<span data-ttu-id="2c43a-247">フィルターに DI からアクセスする必要のある依存関係がある場合、サポートされているいくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-247">If your filters have dependencies that you need to access from DI, there are several supported approaches.</span></span> <span data-ttu-id="2c43a-248">次のいずれかを使用して、クラスまたはアクション メソッドにフィルターを適用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-248">You can apply your filter to a class or action method using one of the following:</span></span>

* `ServiceFilterAttribute`
* `TypeFilterAttribute`
* <span data-ttu-id="2c43a-249">属性に実装された `IFilterFactory`</span><span class="sxs-lookup"><span data-stu-id="2c43a-249">`IFilterFactory` implemented on your attribute</span></span>

> [!NOTE]
> <span data-ttu-id="2c43a-250">DI から取得できる依存関係の 1 つに、ロガーがあります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-250">One dependency you might want to get from DI is a logger.</span></span> <span data-ttu-id="2c43a-251">ただし、必要な[組み込みフレームワークのログ機能](xref:fundamentals/logging/index)は既に提供されている場合があるため、ログ目的のためだけにフィルターを作成して使用することは避けてください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-251">However, avoid creating and using filters purely for logging purposes, since the [built-in framework logging features](xref:fundamentals/logging/index) may already provide what you need.</span></span> <span data-ttu-id="2c43a-252">フィルターにログ記録を追加する場合は、MVC アクションやその他のフレームワーク イベントではなく、ビジネス ドメインの懸案事項や、フィルターに固有の動作を重視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-252">If you're going to add logging to your filters, it should focus on business domain concerns or behavior specific to your filter, rather than MVC actions or other framework events.</span></span>

### <a name="servicefilterattribute"></a><span data-ttu-id="2c43a-253">ServiceFilterAttribute</span><span class="sxs-lookup"><span data-stu-id="2c43a-253">ServiceFilterAttribute</span></span>

<span data-ttu-id="2c43a-254">`ServiceFilter` は DI からフィルターのインスタンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-254">A `ServiceFilter` retrieves an instance of the filter from DI.</span></span> <span data-ttu-id="2c43a-255">`ConfigureServices` でコンテナーにフィルターを追加し、`ServiceFilter` 属性でそれを参照します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-255">You add the filter to the container in `ConfigureServices`, and reference it in a `ServiceFilter` attribute</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=11)]

[!code-csharp[Main](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_ServiceFilter&highlight=1)]

<span data-ttu-id="2c43a-256">フィルターの種類を登録せずに `ServiceFilter` を使用すると、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-256">Using `ServiceFilter` without registering the filter type results in an exception:</span></span>

```
System.InvalidOperationException: No service for type
'FiltersSample.Filters.AddHeaderFilterWithDI' has been registered.
```

<span data-ttu-id="2c43a-257">`ServiceFilterAttribute` は `IFilterFactory` を実装します。これは、`IFilter` インスタンスを作成するために 1 つのメソッドを公開します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-257">`ServiceFilterAttribute` implements `IFilterFactory`, which exposes a single method for creating an `IFilter` instance.</span></span> <span data-ttu-id="2c43a-258">`ServiceFilterAttribute` の場合、`IFilterFactory` インターフェイスの `CreateInstance` メソッドが実装され、サービス コンテナー (DI) から指定した種類を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-258">In the case of `ServiceFilterAttribute`, the `IFilterFactory` interface's `CreateInstance` method is implemented to load the specified type from the services container (DI).</span></span>

### <a name="typefilterattribute"></a><span data-ttu-id="2c43a-259">TypeFilterAttribute</span><span class="sxs-lookup"><span data-stu-id="2c43a-259">TypeFilterAttribute</span></span>

<span data-ttu-id="2c43a-260">`TypeFilterAttribute` は`ServiceFilterAttribute` とよく似ています (`IFilterFactory` も実装します) が、その型は DI コンテナーから直接解決されません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-260">`TypeFilterAttribute` is very similar to `ServiceFilterAttribute` (and also implements `IFilterFactory`), but its type isn't resolved directly from the DI container.</span></span> <span data-ttu-id="2c43a-261">代わりに、`Microsoft.Extensions.DependencyInjection.ObjectFactory` を使って型をインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-261">Instead, it instantiates the type by using `Microsoft.Extensions.DependencyInjection.ObjectFactory`.</span></span>

<span data-ttu-id="2c43a-262">この違いにより、`TypeFilterAttribute` を使用して参照される型は、最初にコンテナーに登録する必要はありません (ただし、コンテナーによって満たされる依存関係があります)。</span><span class="sxs-lookup"><span data-stu-id="2c43a-262">Because of this difference, types that are referenced using the `TypeFilterAttribute` don't need to be registered with the container first (but they will still have their dependencies fulfilled by the container).</span></span> <span data-ttu-id="2c43a-263">また、`TypeFilterAttribute` は必要に応じて、対象の型のコンストラクター引数を受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-263">Also, `TypeFilterAttribute` can optionally accept constructor arguments for the type in question.</span></span> <span data-ttu-id="2c43a-264">次の例は、`TypeFilterAttribute` を使用して、型に引数を渡す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2c43a-264">The following example demonstrates how to pass arguments to a type using `TypeFilterAttribute`:</span></span>

[!code-csharp[Main](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_TypeFilter&highlight=1,2)]

<span data-ttu-id="2c43a-265">引数を必要としないが、DI によって満たされる必要があるコンストラクターの依存関係があるフィルターがある場合、`[TypeFilter(typeof(FilterType))]` の代わりに、独自に名前を付けた属性をクラスとメソッドで使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-265">If you have a filter that doesn't require any arguments, but which has constructor dependencies that need to be filled by DI, you can use your own named attribute on classes and methods instead of `[TypeFilter(typeof(FilterType))]`).</span></span> <span data-ttu-id="2c43a-266">次のフィルターは、これを実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="2c43a-266">The following filter shows how this can be implemented:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilterAttribute.cs?name=snippet_TypeFilterAttribute&highlight=1,3,7)]

<span data-ttu-id="2c43a-267">このフィルターは、`[TypeFilter]` または `[ServiceFilter]` を使用する代わりに、`[SampleActionFilter]` 構文を使用して、クラスまたはメソッドに適用することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-267">This filter can be applied to classes or methods using the `[SampleActionFilter]` syntax, instead of having to use `[TypeFilter]` or `[ServiceFilter]`.</span></span>

## <a name="authorization-filters"></a><span data-ttu-id="2c43a-268">承認フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-268">Authorization filters</span></span>

<span data-ttu-id="2c43a-269">*承認フィルター*は、アクション メソッドへのアクセスを制御し、フィルター パイプライン内で実行される最初のフィルターです。</span><span class="sxs-lookup"><span data-stu-id="2c43a-269">*Authorization filters* control access to action methods and are the first filters to be executed within the filter pipeline.</span></span> <span data-ttu-id="2c43a-270">before メソッドと after メソッドをサポートする他の多くのフィルターとは異なり、このフィルターには before メソッドしかありません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-270">They have only a before method, unlike most filters that support before and after methods.</span></span> <span data-ttu-id="2c43a-271">独自の承認フレームワークを記述している場合は、カスタムの承認フィルターを記述するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-271">You should only write a custom authorization filter if you are writing your own authorization framework.</span></span> <span data-ttu-id="2c43a-272">カスタム フィルターを記述するよりも、独自の承認ポリシーを構成するか、カスタム承認ポリシーを記述することを選びます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-272">Prefer configuring your authorization policies or writing a custom authorization policy over writing a custom filter.</span></span> <span data-ttu-id="2c43a-273">組み込みフィルターの実装は、認証システムを呼び出すことしかしません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-273">The built-in filter implementation is just responsible for calling the authorization system.</span></span>

<span data-ttu-id="2c43a-274">例外を処理するものがないため (例外フィルターは例外を処理しません)、承認フィルター内で例外をスローしないでください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-274">Note that you shouldn't throw exceptions within authorization filters, since nothing will handle the exception (exception filters won't handle them).</span></span> <span data-ttu-id="2c43a-275">代わりに、チャレンジを発行するか、別の方法を探します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-275">Instead, issue a challenge or find another way.</span></span>

<span data-ttu-id="2c43a-276">承認の詳細については、[こちら](../../security/authorization/index.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-276">Learn more about [Authorization](../../security/authorization/index.md).</span></span>

## <a name="resource-filters"></a><span data-ttu-id="2c43a-277">リソース フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-277">Resource filters</span></span>

<span data-ttu-id="2c43a-278">*リソース フィルター*は、`IResourceFilter` または `IAsyncResourceFilter` のいずれかのインターフェイスを実装します。これらの実行は、フィルター パイプラインの大部分をラップします </span><span class="sxs-lookup"><span data-stu-id="2c43a-278">*Resource filters* implement either the `IResourceFilter` or `IAsyncResourceFilter` interface, and their execution wraps most of the filter pipeline.</span></span> <span data-ttu-id="2c43a-279">(これより前に実行されるのは、[承認フィルター](#authorization-filters)だけです)。リソース フィルターは、要求が行っている作業の大部分をショートサーキットする必要がある場合に、特に便利です。</span><span class="sxs-lookup"><span data-stu-id="2c43a-279">(Only [Authorization filters](#authorization-filters) run before them.) Resource filters are especially useful if you need to short-circuit most of the work a request is doing.</span></span> <span data-ttu-id="2c43a-280">たとえば、フィルターをキャッシュすることで、応答が既にキャッシュ内にある場合に、パイプラインの残りの部分を回避することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-280">For example, a caching filter can avoid the rest of the pipeline if the response is already in the cache.</span></span>

<span data-ttu-id="2c43a-281">前に示した[リソース フィルターのショート サーキット](#short-circuiting-resource-filter)は、リソース フィルターの一例です。</span><span class="sxs-lookup"><span data-stu-id="2c43a-281">The [short circuiting resource filter](#short-circuiting-resource-filter) shown earlier is one example of a resource filter.</span></span> <span data-ttu-id="2c43a-282">別の例は [DisableFormValueModelBindingAttribute](https://github.com/aspnet/Entropy/blob/rel/1.1.1/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs) で、これはモデル バインドがフォーム データにアクセスすることを防止します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-282">Another example is [DisableFormValueModelBindingAttribute](https://github.com/aspnet/Entropy/blob/rel/1.1.1/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs), which prevents model binding from accessing the form data.</span></span> <span data-ttu-id="2c43a-283">これは、大きなファイルのアップロードを受信することがわかっていて、フォームがメモリに読み込まれないようにしたい場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-283">It's useful for cases where you know that you're going to receive large file uploads and want to prevent the form from being read into memory.</span></span>

## <a name="action-filters"></a><span data-ttu-id="2c43a-284">アクション フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-284">Action filters</span></span>

<span data-ttu-id="2c43a-285">*アクション フィルター*は、`IActionFilter` または `IAsyncActionFilter` のいずれかのインターフェイスを実装します。これらの実行はアクション メソッドの実行を囲みます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-285">*Action filters* implement either the `IActionFilter` or `IAsyncActionFilter` interface, and their execution surrounds the execution of action methods.</span></span>

<span data-ttu-id="2c43a-286">サンプルのアクション フィルターを次に示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-286">Here's a sample action filter:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?name=snippet_ActionFilter)]

<span data-ttu-id="2c43a-287">[ActionExecutingContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutingcontext) が次のプロパティを提供します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-287">The [ActionExecutingContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutingcontext) provides the following properties:</span></span>

* <span data-ttu-id="2c43a-288">`ActionArguments`: アクションへの入力を操作できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-288">`ActionArguments` - lets you manipulate the inputs to the action.</span></span>
* <span data-ttu-id="2c43a-289">`Controller`: コントローラー インスタンスを操作できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-289">`Controller` - lets you manipulate the controller instance.</span></span> 
* <span data-ttu-id="2c43a-290">`Result`: これを設定することで、アクション メソッドと後続のアクション フィルターの実行をショートサーキットします。</span><span class="sxs-lookup"><span data-stu-id="2c43a-290">`Result` - setting this short-circuits execution of the action method and subsequent action filters.</span></span> <span data-ttu-id="2c43a-291">例外をスローすることで、アクション メソッドと後続のアクション フィルターの実行も防止できますが、成功の結果ではなく、エラーとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-291">Throwing an exception also prevents execution of the action method and subsequent filters, but is treated as a failure instead of a successful result.</span></span>

<span data-ttu-id="2c43a-292">[ActionExecutedContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutedcontext) は、`Controller` と `Result` に加え、次のプロパティを提供します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-292">The [ActionExecutedContext](https://docs.microsoft.com/aspnet/core/api/microsoft.aspnetcore.mvc.filters.actionexecutedcontext) provides `Controller` and `Result` plus the following properties:</span></span>

* <span data-ttu-id="2c43a-293">`Canceled`: 別のフィルターによってアクションの実行がショートサーキットされた場合は、true になります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-293">`Canceled` - will be true if the action execution was short-circuited by another filter.</span></span>
* <span data-ttu-id="2c43a-294">`Exception`: アクションまたは後続のアクション フィルターが例外をスローした場合は、null 以外になります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-294">`Exception` - will be non-null if the action or a subsequent action filter threw an exception.</span></span> <span data-ttu-id="2c43a-295">このプロパティを null に設定すると、例外を効果的に '処理' でき、`Result` がアクション メソッドから通常に返されたかのように実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-295">Setting this property to null effectively 'handles' an exception, and `Result` will be executed as if it were returned from the action method normally.</span></span>

<span data-ttu-id="2c43a-296">`IAsyncActionFilter` の場合、`ActionExecutionDelegate` への呼び出しによって後続のすべてのアクション フィルターとアクション メソッドが実行され、`ActionExecutedContext` が返されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-296">For an `IAsyncActionFilter`, a call to the `ActionExecutionDelegate` executes any subsequent action filters and the action method, returning an `ActionExecutedContext`.</span></span> <span data-ttu-id="2c43a-297">ショートサーキットするには、`ActionExecutingContext.Result` をいくつかの結果インスタンスに割り当てます。`ActionExecutionDelegate` は呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-297">To short-circuit, assign `ActionExecutingContext.Result` to some result instance and don't call the `ActionExecutionDelegate`.</span></span>

<span data-ttu-id="2c43a-298">フレームワークは、サブクラス化できる抽象 `ActionFilterAttribute` を提供します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-298">The framework provides an abstract `ActionFilterAttribute` that you can subclass.</span></span> 

<span data-ttu-id="2c43a-299">アクション フィルターを使用して、自動的にモデルの状態を検証し、状態が無効な場合に、エラーを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-299">You can use an action filter to automatically validate model state and return any errors if the state is invalid:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/ValidateModelAttribute.cs)]

<span data-ttu-id="2c43a-300">`OnActionExecuted` メソッドは、アクション メソッドの後に実行され、`ActionExecutedContext.Result` プロパティを通じてアクションの結果を確認および操作することができます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-300">The `OnActionExecuted` method runs after the action method and can see and manipulate the results of the action through the `ActionExecutedContext.Result` property.</span></span> <span data-ttu-id="2c43a-301">別のフィルターによってアクションの実行がショートサーキットされた場合、`ActionExecutedContext.Canceled` は true に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-301">`ActionExecutedContext.Canceled` will be set to true if the action execution was short-circuited by another filter.</span></span> <span data-ttu-id="2c43a-302">アクションまたは後続のアクション フィルターが例外をスローした場合、`ActionExecutedContext.Exception` は null 以外の値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-302">`ActionExecutedContext.Exception` will be set to a non-null value if the action or a subsequent action filter threw an exception.</span></span> <span data-ttu-id="2c43a-303">`ActionExecutedContext.Exception` を null に設定すると、例外を効果的に '処理' でき、`ActionExectedContext.Result` がアクション メソッドから通常に返されたかのように実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-303">Setting `ActionExecutedContext.Exception` to null effectively 'handles' an exception, and `ActionExectedContext.Result` will then be executed as if it were returned from the action method normally.</span></span>

## <a name="exception-filters"></a><span data-ttu-id="2c43a-304">例外フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-304">Exception filters</span></span>

<span data-ttu-id="2c43a-305">*例外フィルター*は、`IExceptionFilter` または `IAsyncExceptionFilter` のいずれかのインターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-305">*Exception filters* implement either the `IExceptionFilter` or `IAsyncExceptionFilter` interface.</span></span> <span data-ttu-id="2c43a-306">これを使用して、アプリの共通のエラー処理ポリシーを実装できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-306">They can be used to implement common error handling policies for an app.</span></span> 

<span data-ttu-id="2c43a-307">次の例外フィルターのサンプルでは、カスタムの開発エラー ビューを使用して、アプリケーションの開発中に発生する例外に関する詳細を表示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-307">The following sample exception filter uses a custom developer error view to display details about exceptions that occur when the application is in development:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/CustomExceptionFilterAttribute.cs?name=snippet_ExceptionFilter&highlight=1,14)]

<span data-ttu-id="2c43a-308">例外フィルターは、2 つのイベント (before と after 用) を持つのではなく、`OnException` (または `OnExceptionAsync`) だけを実装します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-308">Exception filters don't have two events (for before and after) - they only implement `OnException` (or `OnExceptionAsync`).</span></span> 

<span data-ttu-id="2c43a-309">例外フィルターは、コントローラーの作成、[モデル バインド](../models/model-binding.md)、アクション フィルター、またはアクション メソッドで発生する未処理の例外を処理します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-309">Exception filters handle unhandled exceptions that occur in controller creation, [model binding](../models/model-binding.md), action filters, or action methods.</span></span> <span data-ttu-id="2c43a-310">リソース フィルター、結果フィルター、または MVC 結果の実行で発生した例外はキャッチしません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-310">They won't catch exceptions that occur in Resource filters, Result filters, or MVC Result execution.</span></span>

<span data-ttu-id="2c43a-311">例外を処理するには、`ExceptionContext.ExceptionHandled` プロパティを true に設定するか、応答を記述します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-311">To handle an exception, set the `ExceptionContext.ExceptionHandled` property to true or write a response.</span></span> <span data-ttu-id="2c43a-312">これにより、例外の伝達を停止します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-312">This stops propagation of the exception.</span></span> <span data-ttu-id="2c43a-313">例外フィルターでは、例外を "成功" に変えられないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-313">Note that an Exception filter can't turn an exception into a "success".</span></span> <span data-ttu-id="2c43a-314">これができるのは、アクション フィルターだけです。</span><span class="sxs-lookup"><span data-stu-id="2c43a-314">Only an Action filter can do that.</span></span>

> [!NOTE]
> <span data-ttu-id="2c43a-315">ASP.NET 1.1 では、`ExceptionHandled` を true に設定し、**さらに**応答を記述すると、応答が送信されません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-315">In ASP.NET 1.1, the response isn't sent if you set `ExceptionHandled` to true **and** write a response.</span></span> <span data-ttu-id="2c43a-316">そのシナリオでは、ASP.NET Core 1.0 は応答を送信し、ASP.NET Core 1.1.2 は 1.0 の動作に戻ります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-316">In that scenario, ASP.NET Core 1.0 does send the response, and ASP.NET Core 1.1.2 will return to the 1.0 behavior.</span></span> <span data-ttu-id="2c43a-317">詳細については、GitHub リポジトリで「[issue #5594](https://github.com/aspnet/Mvc/issues/5594)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-317">For more information, see [issue #5594](https://github.com/aspnet/Mvc/issues/5594) in the GitHub repository.</span></span> 

<span data-ttu-id="2c43a-318">例外フィルターは、MVC アクション内で発生する例外をトラップするのには適していますが、エラー処理ミドルウェアほどの柔軟性はありません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-318">Exception filters are good for trapping exceptions that occur within MVC actions, but they're not as flexible as error handling middleware.</span></span> <span data-ttu-id="2c43a-319">一般的なケースにはミドルウェアを選択し、MVC アクションで選択されたのとは*異なる*方法でエラー処理を行う必要がある場合にのみフィルターを使用します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-319">Prefer middleware for the general case, and use filters only where you need to do error handling *differently* based on which MVC action was chosen.</span></span> <span data-ttu-id="2c43a-320">たとえば、ご利用のアプリには、API エンドポイントとビュー/HTML の両方に対するアクション メソッドがある場合があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-320">For example, your app might have action methods for both API endpoints and for views/HTML.</span></span> <span data-ttu-id="2c43a-321">API エンドポイントは、JSON としてのエラー情報を返す可能性がある一方で、ビュー ベースのアクションがエラー ページを HTML として返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-321">The API endpoints could return error information as JSON, while the view-based actions could return an error page as HTML.</span></span>

<span data-ttu-id="2c43a-322">フレームワークは、サブクラス化できる抽象 `ExceptionFilterAttribute` を提供します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-322">The framework provides an abstract `ExceptionFilterAttribute` that you can subclass.</span></span> 

## <a name="result-filters"></a><span data-ttu-id="2c43a-323">結果フィルター</span><span class="sxs-lookup"><span data-stu-id="2c43a-323">Result filters</span></span>

<span data-ttu-id="2c43a-324">*結果フィルター*は、`IResultFilter` または `IAsyncResultFilter` のいずれかのインターフェイスを実装します。これらの実行はアクション結果の実行を囲みます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-324">*Result filters* implement either the `IResultFilter` or `IAsyncResultFilter` interface, and their execution surrounds the execution of action results.</span></span> 

<span data-ttu-id="2c43a-325">HTTP ヘッダーを追加する結果フィルターの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-325">Here's an example of a Result filter that adds an HTTP header.</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/LoggingAddHeaderFilter.cs?name=snippet_ResultFilter)]

<span data-ttu-id="2c43a-326">実行されている結果の種類は、対象のアクションに依存します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-326">The kind of result being executed depends on the action in question.</span></span> <span data-ttu-id="2c43a-327">ビューを返す MVC アクションには、実行されている `ViewResult` の一部として、すべての razor 処理が含まれます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-327">An MVC action returning a view would include all razor processing as part of the `ViewResult` being executed.</span></span> <span data-ttu-id="2c43a-328">API メソッドは、結果の実行の一部としていくつかのシリアル化を実行できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-328">An API method might perform some serialization as part of the execution of the result.</span></span> <span data-ttu-id="2c43a-329">アクション結果に関する詳細は、[こちら](actions.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-329">Learn more about [action results](actions.md)</span></span>

<span data-ttu-id="2c43a-330">結果フィルターは、アクションまたはアクション フィルターがアクションの結果を生成するときに、成功した結果に対してのみ実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-330">Result filters are only executed for successful results - when the action or action filters produce an action result.</span></span> <span data-ttu-id="2c43a-331">例外フィルターが例外を処理するときには、結果フィルターは実行されません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-331">Result filters are not executed when exception filters handle an exception.</span></span>

<span data-ttu-id="2c43a-332">`OnResultExecuting` メソッドは、`ResultExecutingContext.Cancel` を true に設定することで、アクションの結果と後続の結果フィルターの実行をショートサーキットできます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-332">The `OnResultExecuting` method can short-circuit execution of the action result and subsequent result filters by setting `ResultExecutingContext.Cancel` to true.</span></span> <span data-ttu-id="2c43a-333">ショートサーキットする場合は、通常、空の応答が生成されないように応答オブジェクトに記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-333">You should generally write to the response object when short-circuiting to avoid generating an empty response.</span></span> <span data-ttu-id="2c43a-334">例外をスローすることで、アクションの結果と後続のフィルターの実行も防止できますが、成功の結果ではなく、エラーとして扱われます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-334">Throwing an exception will also prevent execution of the action result and subsequent filters, but will be treated as a failure instead of a successful result.</span></span>

<span data-ttu-id="2c43a-335">`OnResultExecuted` メソッドを実行するときに、応答がクライアントに送信され、(例外がスローされない限り) それ以上変更できない可能性があます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-335">When the `OnResultExecuted` method runs, the response has likely been sent to the client and cannot be changed further (unless an exception was thrown).</span></span> <span data-ttu-id="2c43a-336">別のフィルターによってアクションの結果の実行がショートサーキットされた場合、`ResultExecutedContext.Canceled` は true に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-336">`ResultExecutedContext.Canceled` will be set to true if the action result execution was short-circuited by another filter.</span></span>

<span data-ttu-id="2c43a-337">アクションの結果または後続の結果フィルターが例外をスローした場合、`ResultExecutedContext.Exception` は null 以外の値に設定されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-337">`ResultExecutedContext.Exception` will be set to a non-null value if the action result or a subsequent result filter threw an exception.</span></span> <span data-ttu-id="2c43a-338">`Exception` を null に設定すると、例外を効果的に '処理' でき、パイプラインの後方で MVC によって例外が再スローされることを防げます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-338">Setting `Exception` to null effectively 'handles' an exception and prevents the exception from being rethrown by MVC later in the pipeline.</span></span> <span data-ttu-id="2c43a-339">結果フィルター内の例外を処理しているときに、応答にどのデータも書き込めない場合があります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-339">When you're handling an exception in a result filter, you might not be able to write any data to the response.</span></span> <span data-ttu-id="2c43a-340">アクションの結果がその実行の途中でスローして、クライアントに対してはヘッダーが既にフラッシュされている場合、エラー コードを送信するための信頼性の高いメカニズムはありません。</span><span class="sxs-lookup"><span data-stu-id="2c43a-340">If the action result throws partway through its execution, and the headers have already been flushed to the client, there's no reliable mechanism to send a failure code.</span></span>

<span data-ttu-id="2c43a-341">`IAsyncResultFilter` の場合、`ResultExecutionDelegate` での `await next()` への呼び出しは、後続のすべての結果フィルターとアクションの結果を実行します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-341">For an `IAsyncResultFilter` a call to `await next()` on the `ResultExecutionDelegate` executes any subsequent result filters and the action result.</span></span> <span data-ttu-id="2c43a-342">ショートサーキットするには、`ResultExecutingContext.Cancel` を true に設定します。`ResultExectionDelegate` は呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="2c43a-342">To short-circuit, set `ResultExecutingContext.Cancel` to true and don't call the `ResultExectionDelegate`.</span></span>

<span data-ttu-id="2c43a-343">フレームワークは、サブクラス化できる抽象 `ResultFilterAttribute` を提供します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-343">The framework provides an abstract `ResultFilterAttribute` that you can subclass.</span></span> <span data-ttu-id="2c43a-344">前に示した [AddHeaderAttribute](#add-header-attribute) クラスは、結果フィルター属性の一例です。</span><span class="sxs-lookup"><span data-stu-id="2c43a-344">The [AddHeaderAttribute](#add-header-attribute) class shown earlier is an example of a result filter attribute.</span></span>

## <a name="using-middleware-in-the-filter-pipeline"></a><span data-ttu-id="2c43a-345">フィルター パイプラインでのミドルウェアの使用</span><span class="sxs-lookup"><span data-stu-id="2c43a-345">Using middleware in the filter pipeline</span></span>

<span data-ttu-id="2c43a-346">リソース フィルターは、パイプラインの後方で登場するすべての実行を囲む点で、[ミドルウェア](xref:fundamentals/middleware/index)のように機能します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-346">Resource filters work like [middleware](xref:fundamentals/middleware/index) in that they surround the execution of everything that comes later in the pipeline.</span></span> <span data-ttu-id="2c43a-347">ただし、フィルターは MVC の一部である点がミドルウェアとは異なります。つまり、フィルターには MVC コンテキストとコンストラクトへのアクセスがあります。</span><span class="sxs-lookup"><span data-stu-id="2c43a-347">But filters differ from middleware in that they're part of MVC, which means that they have access to MVC context and constructs.</span></span>

<span data-ttu-id="2c43a-348">ASP.NET Core 1.1 では、フィルター パイプラインでミドルウェアを使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-348">In ASP.NET Core 1.1, you can use middleware in the filter pipeline.</span></span> <span data-ttu-id="2c43a-349">MVC ルート データへのアクセスを必要とする、または特定のコントローラーまたはアクションを実行する必要があるミドルウェア コンポーネントがある場合は、ミドルウェアを使用できます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-349">You might want to do that if you have a middleware component that needs access to MVC route data, or one that should run only for certain controllers or actions.</span></span>

<span data-ttu-id="2c43a-350">ミドルウェアをフィルターとして使用するには、フィルター パイプラインに挿入するミドルウェアを指定する `Configure` メソッドを使用して型を作成します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-350">To use middleware as a filter, create a type with a `Configure` method that specifies the middleware that you want to inject into the filter pipeline.</span></span> <span data-ttu-id="2c43a-351">ローカリゼーション ミドルウェアを使用して要求の現在のカルチャを確立する例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="2c43a-351">Here's an example that uses the localization middleware to establish the current culture for a request:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Filters/LocalizationPipeline.cs?name=snippet_MiddlewareFilter&highlight=3,21)]

<span data-ttu-id="2c43a-352">`MiddlewareFilterAttribute` を使用して、選択したコントローラーまたはアクションに対してミドルウェアを実行することも、グローバルにミドルウェアを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-352">You can then use the `MiddlewareFilterAttribute` to run the middleware for a selected controller or action or globally:</span></span>

[!code-csharp[Main](./filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_MiddlewareFilter&highlight=2)]

<span data-ttu-id="2c43a-353">ミドルウェア フィルターは、フィルター パイプラインのリソース フィルターと同じステージ (モデル バインドの前、残りのパイプラインの後) で実行されます。</span><span class="sxs-lookup"><span data-stu-id="2c43a-353">Middleware filters run at the same stage of the filter pipeline as Resource filters, before model binding and after the rest of the pipeline.</span></span>

## <a name="next-actions"></a><span data-ttu-id="2c43a-354">次の操作</span><span class="sxs-lookup"><span data-stu-id="2c43a-354">Next actions</span></span>

<span data-ttu-id="2c43a-355">フィルターを試すには、[ここ](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample)からサンプルをダウンロードして、テストおよび変更を行います。</span><span class="sxs-lookup"><span data-stu-id="2c43a-355">To experiment with filters, [download, test and modify the sample](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).</span></span>
