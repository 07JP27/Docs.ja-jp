---
title: ASP.NET Core のコントローラーのロジックをテストする
author: ardalis
description: Moq と xUnit を使って ASP.NET Core のコントローラーのロジックをテストする方法を説明します。
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/testing
ms.openlocfilehash: 51b7a02c697807c9e3504b70f89370126ee0e781
ms.sourcegitcommit: 5130b3034165f5cf49d829fe7475a84aa33d2693
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/03/2018
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="f929c-103">ASP.NET Core のコントローラーのロジックをテストする</span><span class="sxs-lookup"><span data-stu-id="f929c-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="f929c-104">作成者: [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="f929c-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="f929c-105">ASP.NET MVC アプリのコントローラーは、小さく、ユーザー インターフェイスに関係することだけを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="f929c-106">UI 以外のことも処理する大規模なコントローラーは、テストや保守が困難です。</span><span class="sxs-lookup"><span data-stu-id="f929c-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="f929c-107">GitHub のサンプルを表示またはダウンロードする</span><span class="sxs-lookup"><span data-stu-id="f929c-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="f929c-108">コントローラーのテスト</span><span class="sxs-lookup"><span data-stu-id="f929c-108">Testing controllers</span></span>

<span data-ttu-id="f929c-109">コントローラーは、すべての ASP.NET Core MVC アプリケーションの中心になるものです。</span><span class="sxs-lookup"><span data-stu-id="f929c-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="f929c-110">そのため、アプリが意図するとおりに動作するという信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f929c-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="f929c-111">自動テストを行うと、この信頼が得られ、運用環境に提供する前にエラーを検出できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="f929c-112">コントローラーに必要のない機能を持たせないようにし、テストではコントローラーの機能だけに注目することが重要です。</span><span class="sxs-lookup"><span data-stu-id="f929c-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="f929c-113">コントローラーのロジックは最小限のものにして、ビジネス ロジックやインフラストラクチャに関すること (たとえば、データ アクセス) には目を向けないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="f929c-114">フレームワークではなく、コントローラーのロジックをテストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="f929c-115">有効または無効な入力に基づいて、コントローラーの "*動作*" をテストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="f929c-116">コントローラーが実行するビジネス操作の結果に基づいて、コントローラーの応答をテストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="f929c-117">コントローラーの一般的な機能:</span><span class="sxs-lookup"><span data-stu-id="f929c-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="f929c-118">`ModelState.IsValid` を確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="f929c-119">`ModelState` が無効である場合は、エラー応答を返します。</span><span class="sxs-lookup"><span data-stu-id="f929c-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="f929c-120">ビジネス エンティティを永続化から取得します。</span><span class="sxs-lookup"><span data-stu-id="f929c-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="f929c-121">ビジネス エンティティに対してアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="f929c-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="f929c-122">ビジネス エンティティを永続化に保存します。</span><span class="sxs-lookup"><span data-stu-id="f929c-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="f929c-123">適切な `IActionResult` を返します。</span><span class="sxs-lookup"><span data-stu-id="f929c-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="f929c-124">単体テスト</span><span class="sxs-lookup"><span data-stu-id="f929c-124">Unit testing</span></span>

<span data-ttu-id="f929c-125">[単体テスト](/dotnet/articles/core/testing/unit-testing-with-dotnet-test)では、アプリの一部をインフラストラクチャや依存関係から切り離してテストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-125">[Unit testing](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="f929c-126">コントローラー ロジックの単体テストを行うときは、それが依存しているものやフレームワーク自体の動作ではなく、単一のアクションの内容のみをテストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="f929c-127">コントローラーのアクションの単体テストでは、その動作にだけ注目するようにします。</span><span class="sxs-lookup"><span data-stu-id="f929c-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="f929c-128">コントローラーの単体テストからは、[フィルター](filters.md)、[ルーティング](../../fundamentals/routing.md)、[モデル バインド](../models/model-binding.md)などに関することは除外します。</span><span class="sxs-lookup"><span data-stu-id="f929c-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="f929c-129">1 つの事柄だけに注目してテストすることにより、一般に、単体テストを簡単に作成してすばやく実行できるようになります。</span><span class="sxs-lookup"><span data-stu-id="f929c-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="f929c-130">適切に記述された一連の単体テストは、大きなオーバーヘッドなしに頻繁に実行できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="f929c-131">ただし、単体テストではコンポーネント間の相互作用の問題は検出しません。これは、[統合テスト](xref:mvc/controllers/testing#integration-testing)の目的です。</span><span class="sxs-lookup"><span data-stu-id="f929c-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="f929c-132">カスタム フィルターやルートなどを作成している場合は、それらの単体テストを行う必要がありますが、コントローラーの特定のアクションに対するテストの一部としてではありません。</span><span class="sxs-lookup"><span data-stu-id="f929c-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="f929c-133">これらは、切り離してテストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="f929c-134">[Visual Studio で単体テストを作成して実行します](/visualstudio/test/unit-test-your-code)。</span><span class="sxs-lookup"><span data-stu-id="f929c-134">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="f929c-135">単体テストの方法を説明するための実例として、次のコントローラーを使います。</span><span class="sxs-lookup"><span data-stu-id="f929c-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="f929c-136">このコントローラーは、ブレーンストーミング セッションの一覧を表示し、POST を使って新しいブレーンストーミング セッションを作成できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="f929c-137">このコントローラーは、[明示的な依存関係の原則](http://deviq.com/explicit-dependencies-principle/)に従い、依存関係の挿入を使って `IBrainstormSessionRepository` のインスタンスを提供されるものと想定しています。</span><span class="sxs-lookup"><span data-stu-id="f929c-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="f929c-138">これにより、[Moq](https://www.nuget.org/packages/Moq/) などのモック オブジェクト フレームワークを使ったテストが非常に簡単になります。</span><span class="sxs-lookup"><span data-stu-id="f929c-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="f929c-139">`HTTP GET Index` メソッドにはループや分岐はなく、1 つのメソッドを呼び出すだけです。</span><span class="sxs-lookup"><span data-stu-id="f929c-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="f929c-140">この `Index` メソッドをテストするには、リポジトリの `List` メソッドからの `ViewModel` で、`ViewResult` が返されることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="f929c-141">`HomeController` `HTTP POST Index` メソッド (上記) では、次のことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="f929c-142">`ModelState.IsValid` が `false` の場合、アクション メソッドが無効な要求の `ViewResult` と適切なデータを返すこと</span><span class="sxs-lookup"><span data-stu-id="f929c-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="f929c-143">`ModelState.IsValid` が true の場合、リポジトリで `Add` メソッドが呼び出されて、`RedirectToActionResult` が適切な引数と共に返されること</span><span class="sxs-lookup"><span data-stu-id="f929c-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="f929c-144">以下の最初のテストで示すように、`AddModelError` を使ってエラーを追加することで、無効なモデルの状態をテストできます。</span><span class="sxs-lookup"><span data-stu-id="f929c-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="f929c-145">最初のテストでは、`ModelState` が有効ではないときに、`GET` 要求の場合と同じ `ViewResult` が返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="f929c-146">テストでは無効なモデルを渡そうとしていないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="f929c-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="f929c-147">モデル バインドが動作していないので、いずれにしてもうまくいきません (ただし、[統合テスト](xref:mvc/controllers/testing#integration-testing)では演習のモデル バインドを使います)。</span><span class="sxs-lookup"><span data-stu-id="f929c-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="f929c-148">この場合、モデル バインドはテストされていません。</span><span class="sxs-lookup"><span data-stu-id="f929c-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="f929c-149">これらの単体テストでは、アクション メソッドのコードだけをテストしています。</span><span class="sxs-lookup"><span data-stu-id="f929c-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="f929c-150">2 番目のテストでは、`ModelState` が有効であるときに、新しい `BrainstormSession` が (リポジトリによって) 追加され、メソッドが予期されるプロパティと共に `RedirectToActionResult` を返すことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="f929c-151">呼び出されないモックの呼び出しは通常は無視されますが、Setup の呼び出しの最後で `Verifiable` を呼び出すと、テスト内で検証できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="f929c-152">これは `mockRepo.Verify` の呼び出しで行われ、予期されるメソッドが呼び出されないとテストは失敗します。</span><span class="sxs-lookup"><span data-stu-id="f929c-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="f929c-153">このサンプルで使われている Moq ライブラリにより、検証可能な ("厳密な") モックと検証不可能なモック ("厳密でない" モックまたはスタブとも呼ばれます) を簡単に混在させることができます。</span><span class="sxs-lookup"><span data-stu-id="f929c-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="f929c-154">詳しくは、Moq の「[Customizing Mock Behavior](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior)」(モックの動作のカスタマイズ) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f929c-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="f929c-155">アプリの別のコントローラーでは、特定のブレーンストーミング セッションに関する情報が表示されます。</span><span class="sxs-lookup"><span data-stu-id="f929c-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="f929c-156">無効な ID 値を扱うためのロジックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="f929c-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="f929c-157">コントローラーのアクションには、各 `return` ステートメントに 1 つずつ、3 つのテスト ケースがあります。</span><span class="sxs-lookup"><span data-stu-id="f929c-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="f929c-158">アプリでは、Web API として機能が公開されています (ブレーンストーミング セッションに関連付けられているアイデアの一覧と、新しいアイデアをセッションに追加するためのメソッド)。</span><span class="sxs-lookup"><span data-stu-id="f929c-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="f929c-159">`ForSession` メソッドは、`IdeaDTO` 型の一覧を返します。</span><span class="sxs-lookup"><span data-stu-id="f929c-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="f929c-160">API の呼び出しで直接ビジネス ドメイン エンティティを返さないでください。ビジネス ドメイン エンティティには API クライアントが要求しているもの以外のデータが含まれることが多く、アプリの内部ドメイン モデルと外部に公開される API との間に必要のない結合が生じます。</span><span class="sxs-lookup"><span data-stu-id="f929c-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="f929c-161">ドメイン エンティティと、ネットワーク経由で戻される型の間のマッピングは、手動で (ここで示すように LINQ `Select` を使って)、または [AutoMapper](https://github.com/AutoMapper/AutoMapper) などのライブラリを使って、行うことができます。</span><span class="sxs-lookup"><span data-stu-id="f929c-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="f929c-162">API メソッド `Create` と `ForSession` の単体テストは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f929c-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="f929c-163">前に説明したように、`ModelState` が無効のときのメソッドの動作をテストするには、テストの一部としてコントローラーにモデル エラーを追加します。</span><span class="sxs-lookup"><span data-stu-id="f929c-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="f929c-164">単体テストでは、モデルの検証またはモデル バインドのテストを試さないでください。`ModelState` の特定の値に遭遇したときのアクション メソッドの動作だけをテストしてください。</span><span class="sxs-lookup"><span data-stu-id="f929c-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="f929c-165">2 番目のテストではリポジトリが null を返す必要があるので、モック リポジトリは null を返すように構成されています。</span><span class="sxs-lookup"><span data-stu-id="f929c-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="f929c-166">テスト データベース (メモリ内またはそれ以外の場所) を作成する必要はなく、この結果を返すクエリを作成します。これは、次のように単一のステートメントで実行できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="f929c-167">最後のテストでは、リポジトリの `Update` メソッドが呼び出されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="f929c-168">前に行ったように、`Verifiable` ではモックが呼び出され、モック リポジトリの `Verify` メソッドが呼び出されて、検証可能なメソッドが実行されたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="f929c-169">`Update` メソッドがデータを保存したことを確認するのは、単体テストの役割ではありません。これは、統合テストで実行できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="f929c-170">統合テスト</span><span class="sxs-lookup"><span data-stu-id="f929c-170">Integration testing</span></span>

<span data-ttu-id="f929c-171">[統合テスト](../../testing/integration-testing.md)は、アプリ内の異なるモジュールが正常に連携することを確認するために行われます。</span><span class="sxs-lookup"><span data-stu-id="f929c-171">[Integration tests](../../testing/integration-testing.md) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="f929c-172">一般に、単体テストでテストできるものはすべて、統合テストでもテストできますが、逆は正しくありません。</span><span class="sxs-lookup"><span data-stu-id="f929c-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="f929c-173">ただし、統合テストは単体テストより非常に遅い傾向があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="f929c-174">したがって、可能なものはすべて単体テストで行い、複数のコラボレーターが関係するシナリオには統合テストを使うのが最善の方法です。</span><span class="sxs-lookup"><span data-stu-id="f929c-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="f929c-175">モック オブジェクトは、統合テストでも役に立つことはありますが、ほとんど使われません。</span><span class="sxs-lookup"><span data-stu-id="f929c-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="f929c-176">単体テストでは、モック オブジェクトは、テスト対象のユニットの外部にいるコラボレーターがテストの目的に関してどのように振る舞うかを制御するのに効果的な方法です。</span><span class="sxs-lookup"><span data-stu-id="f929c-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="f929c-177">統合テストでは、実際のコラボレーターを使って、サブシステム全体が正しく連携することを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="f929c-178">アプリケーションの状態</span><span class="sxs-lookup"><span data-stu-id="f929c-178">Application state</span></span>

<span data-ttu-id="f929c-179">統合テストを実行するときの重要な考慮事項の 1 つは、アプリの状態を設定する方法です。</span><span class="sxs-lookup"><span data-stu-id="f929c-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="f929c-180">テストは相互に独立して実行する必要があるので、各テストが既知の状態のアプリで開始する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="f929c-181">アプリがデータベースまたはいかなる永続化も使っていない場合、これは問題にならないことがあります。</span><span class="sxs-lookup"><span data-stu-id="f929c-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="f929c-182">しかし、現実世界のほとんどのアプリは何らかの種類のデータ ストアにその状態が保持するので、データ ストアをリセットしない限り、あるテストによって行われた変更が、別のテストに影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="f929c-183">組み込みの `TestServer` を使うと、統合テスト内の ASP.NET Core アプリのホストが非常に簡単になりますが、使うデータへのアクセスが許可されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="f929c-184">実際のデータベースを使う場合の 1 つの方法は、アプリをテスト データベースに接続することで、テストでアクセスし、各テスト実行の前に既知の状態にリセットすることができます。</span><span class="sxs-lookup"><span data-stu-id="f929c-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="f929c-185">このサンプル アプリケーションでは、Entity Framework Core の InMemoryDatabase サポートを使っているので、テスト プロジェクトから単に接続することはできません。</span><span class="sxs-lookup"><span data-stu-id="f929c-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="f929c-186">代わりに、アプリの `Startup` クラスから `InitializeDatabase` メソッドを公開し、`Development` 環境のときはアプリの起動時にそのメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f929c-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="f929c-187">統合テストでは、環境を `Development` に設定しさえすれば、これを自動的に利用できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="f929c-188">InMemoryDatabase はアプリを再起動するたびにリセットされるので、データベースのリセットについて心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f929c-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="f929c-189">`Startup` クラス:</span><span class="sxs-lookup"><span data-stu-id="f929c-189">The `Startup` class:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="f929c-190">以下の統合テストでは、`GetTestSession` メソッドが頻繁に使われていることがわかります。</span><span class="sxs-lookup"><span data-stu-id="f929c-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="f929c-191">ビューへのアクセス</span><span class="sxs-lookup"><span data-stu-id="f929c-191">Accessing views</span></span>

<span data-ttu-id="f929c-192">各統合テスト クラスでは、ASP.NET Core アプリを実行する `TestServer` が構成されます。</span><span class="sxs-lookup"><span data-stu-id="f929c-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="f929c-193">既定では、`TestServer` は実行しているフォルダー (この場合はテスト プロジェクト フォルダー) で Web アプリをホストします。</span><span class="sxs-lookup"><span data-stu-id="f929c-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="f929c-194">したがって、`ViewResult` を返すコントローラー アクションをテストしようとすると、次のエラーが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="f929c-195">この問題を解決するには、テスト対象プロジェクトのビューを見つけることができるように、サーバーのコンテンツ ルートを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f929c-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="f929c-196">これは、次に示すように、`TestFixture` クラスの `UseContentRoot` を呼び出すことによって行います。</span><span class="sxs-lookup"><span data-stu-id="f929c-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="f929c-197">`TestFixture` クラスは、`TestServer` を構成および作成し、`TestServer` と通信するように `HttpClient` を設定します。</span><span class="sxs-lookup"><span data-stu-id="f929c-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="f929c-198">各統合テストは、`Client` プロパティを使ってテスト サーバーに接続し、要求を行います。</span><span class="sxs-lookup"><span data-stu-id="f929c-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="f929c-199">上の最初のテストでは、`responseString` がビューから実際にレンダリングされた HTML を保持しており、それを調べることによって期待どおりの結果が含まれることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="f929c-200">2 番目のテストは、一意のセッション名でフォーム POST を作成し、アプリに POST して、期待されるリダイレクトが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="f929c-201">API メソッド</span><span class="sxs-lookup"><span data-stu-id="f929c-201">API methods</span></span>

<span data-ttu-id="f929c-202">アプリが Web API を公開している場合、API が期待したとおりに実行することを自動テストで確認するのがよいアイデアです。</span><span class="sxs-lookup"><span data-stu-id="f929c-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="f929c-203">組み込みの `TestServer` を使うと、Web API のテストが容易になります。</span><span class="sxs-lookup"><span data-stu-id="f929c-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="f929c-204">API のメソッドがモデル バインドを使っている場合は、常に `ModelState.IsValid` を確認する必要があり、統合テストはモデルの検証が正しく動作していることを確認するのに適した場所です。</span><span class="sxs-lookup"><span data-stu-id="f929c-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="f929c-205">次の一連のテストでは、上で示した [IdeasController](xref:mvc/controllers/testing#ideas-controller) クラスの `Create` メソッドが対象になっています。</span><span class="sxs-lookup"><span data-stu-id="f929c-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="f929c-206">HTML ビューを返すアクションの統合テストとは異なり、結果を返す Web API メソッドは、通常、上の最後のテストで示されているように、厳密に型指定されたオブジェクトとして逆シリアル化できます。</span><span class="sxs-lookup"><span data-stu-id="f929c-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="f929c-207">この場合、テストでは、結果を `BrainstormSession` インスタンスに逆シリアル化して、アイデアのコレクションにアイデアが正しく追加されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="f929c-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="f929c-208">統合テストの他の例については、この記事の[サンプル プロジェクト](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="f929c-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
