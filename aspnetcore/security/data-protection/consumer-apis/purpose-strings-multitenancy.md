---
title: "ASP.NET Core で目的の文字列"
author: rick-anderson
description: 
keywords: ASP.NET Core,
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 9d18c287-e0e6-4541-b09c-7fed45c902d9
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: b25af7c1f4dd3c63734290e6ac82e2e30a030c61
ms.sourcegitcommit: e3b1726cc04e80dc28464c35259edbd3bc39a438
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/12/2017
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="22a8d-103">目的の階層と ASP.NET Core におけるマルチ テナント機能</span><span class="sxs-lookup"><span data-stu-id="22a8d-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="22a8d-104">IDataProtector も暗黙的に、IDataProtectionProvider であるために、目的に連結することができます。</span><span class="sxs-lookup"><span data-stu-id="22a8d-104">Since an IDataProtector is also implicitly an IDataProtectionProvider, purposes can be chained together.</span></span> <span data-ttu-id="22a8d-105">この意味プロバイダー。CreateProtector (["purpose1"、"purpose2"]) は、プロバイダーと同じです。CreateProtector("purpose1") です。CreateProtector("purpose2") です。</span><span class="sxs-lookup"><span data-stu-id="22a8d-105">In this sense provider.CreateProtector([ "purpose1", "purpose2" ]) is equivalent to provider.CreateProtector("purpose1").CreateProtector("purpose2").</span></span>

<span data-ttu-id="22a8d-106">これにより、データ保護システムを通じていくつか興味深い階層リレーションシップです。</span><span class="sxs-lookup"><span data-stu-id="22a8d-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="22a8d-107">先ほどの例の[Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose)、SecureMessage コンポーネントは、プロバイダーを呼び出すことができます。アップ フロントしたら CreateProtector("Contoso.Messaging.SecureMessage") とキャッシュ プライベートに結果`_myProvide`フィールドです。</span><span class="sxs-lookup"><span data-stu-id="22a8d-107">In the earlier example of [Contoso.Messaging.SecureMessage](purpose-strings.md#data-protection-contoso-purpose), the SecureMessage component can call provider.CreateProtector("Contoso.Messaging.SecureMessage") once upfront and cache the result into a private `_myProvide` field.</span></span> <span data-ttu-id="22a8d-108">呼び出しを使用して、将来の保護機能を作成し、できます`_myProvider.CreateProtector("User: username")`、個々 のメッセージをセキュリティで保護するこれらの保護機能に使用されるとします。</span><span class="sxs-lookup"><span data-stu-id="22a8d-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="22a8d-109">これを反転もできます。</span><span class="sxs-lookup"><span data-stu-id="22a8d-109">This can also be flipped.</span></span> <span data-ttu-id="22a8d-110">独自の認証および状態管理システム (CMS 必然的に) 複数のテナント、および各テナントを構成できますホストの 1 つの論理アプリケーションを検討してください。</span><span class="sxs-lookup"><span data-stu-id="22a8d-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="22a8d-111">包括的なアプリケーションが 1 つのマスター プロバイダーとプロバイダーを呼び出します。CreateProtector (以下"Tenant 1") とプロバイダー。CreateProtector ("Tenant 2") に、データ保護システムの分離された独自スライスを各テナントに付与します。</span><span class="sxs-lookup"><span data-stu-id="22a8d-111">The umbrella application has a single master provider, and it calls provider.CreateProtector("Tenant 1") and provider.CreateProtector("Tenant 2") to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="22a8d-112">テナントは独自のニーズに基づく独自個々 の保護機能を派生し、でしたとどの程度厳密に関係なく、作成はできません衝突の保護機能、他のテナントでシステムで。</span><span class="sxs-lookup"><span data-stu-id="22a8d-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="22a8d-113">視覚的に下として表されます。</span><span class="sxs-lookup"><span data-stu-id="22a8d-113">Graphically this is represented as below.</span></span>

![マルチ テナント機能の目的](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="22a8d-115">包括的なアプリケーションを制御する Api は、個々 のテナントを使用し、テナントが、サーバー上の任意のコードを実行できないことを前提です。</span><span class="sxs-lookup"><span data-stu-id="22a8d-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="22a8d-116">テナントが任意のコードを実行できる、分離の保証を中断するプライベート リフレクションを実行する可能性がありますかマスター_キー生成情報を直接読み取るし、どのようなサブキーを派生する可能性がありますがだけ状況が該当します。</span><span class="sxs-lookup"><span data-stu-id="22a8d-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="22a8d-117">データ保護システムは、既定の既定の構成におけるマルチ テナント機能の並べ替えを実際に使用します。</span><span class="sxs-lookup"><span data-stu-id="22a8d-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="22a8d-118">既定では、マスター_キー生成情報は、ワーカー プロセス アカウントのユーザー プロファイル フォルダー (または IIS アプリケーション プール id のレジストリ、) に格納されます。</span><span class="sxs-lookup"><span data-stu-id="22a8d-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="22a8d-119">実際には、単一のアカウントを使用して、複数のアプリケーションを実行する非常に一般的なマスター_キー生成情報の共有をこれらすべてのアプリケーションが終了するため。</span><span class="sxs-lookup"><span data-stu-id="22a8d-119">But it is actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="22a8d-120">これを解決するには、データ保護システムは、全体的な目的のチェーンの最初の要素としてごとのアプリケーション固有の識別子を自動的に挿入されます。</span><span class="sxs-lookup"><span data-stu-id="22a8d-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="22a8d-121">この暗黙的な目的の機能を[個々 のアプリケーションの分離](../configuration/overview.md#data-protection-configuration-per-app-isolation)上の図と同じで、システム、および保護機能の作成プロセス内で一意のテナントとして各アプリケーションを効果的に扱うことで別のです。</span><span class="sxs-lookup"><span data-stu-id="22a8d-121">This implicit purpose serves to [isolate individual applications](../configuration/overview.md#data-protection-configuration-per-app-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
