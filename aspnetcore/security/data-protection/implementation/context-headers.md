---
title: "コンテキスト ヘッダー"
author: rick-anderson
description: 
keywords: ASP.NET Core,
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: d026a58c-67f4-411e-a410-c35f29c2c517
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: b32a5e2c216137f1191bbee32dbe76f0ef604670
ms.sourcegitcommit: 8f4d4fad1ca27adf9e396f5c205c9875a3963664
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/13/2017
---
# <a name="context-headers"></a>コンテキスト ヘッダー

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>背景と理論的には

データ保護システムでは、「キー」は、認証済み暗号化サービスを提供できるオブジェクトを意味します。 各キーは一意の id (GUID) によって識別され、それが伴うことアルゴリズム情報および entropic マテリアルです。 これは、こと各キーが一意のエントロピを実行がシステムを実施できないことも開発者キー リング内の既存のキーのアルゴリズム情報を変更することにより、キーのリングを手動で変更可能性がありますを考慮する必要があります。 このような場合のセキュリティ要件を実現するために、データ保護システムがの概念[暗号化方式の指定](https://www.microsoft.com/en-us/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption/)、これにより、複数の暗号化アルゴリズムの間で安全に entropic 1 つの値を使用しています。

暗号化方式の指定をサポートするほとんどのシステムでは、ペイロードの内側のアルゴリズムについていくつかの識別情報を含めることによってようにします。 アルゴリズムの OID は、これに適した候補では、通常です。 ただし、発生しましました問題の 1 つは、同じアルゴリズムを指定する複数の方法があること"AES"(CNG) と、マネージ Aes、AesManaged、AesCryptoServiceProvider、AesCng、および (指定した特定のパラメーター) RijndaelManaged クラスは、実際にすべて同じです。操作を実行し正しい OID をこれらすべてのマッピングを維持するために必要があります。 開発者は、カスタム アルゴリズム (または AES の別の実装) を提供する場合は、その OID を連絡する必要があります。 この余分な登録ステップでは、システム構成が特に苦痛を伴う作業します。

戻すステップ実行、おされたに近づいていること、問題、誤った方向から用意しました。 OID は、アルゴリズムを示しますが、実際にこの考慮しないことです。 2 つのアルゴリズムで安全に 1 つの entropic 値を使用する必要がある場合、アルゴリズムが実際には何を理解するうえで必要はありません。 どのような実際に配慮して、どのように動作するです。 任意の適切な対称ブロック暗号アルゴリズムも強力な擬似順列 (PRP): (キー、モード、IV、プレーン テキストの組み合わせ) の入力を修正し、暗号化テキストの出力は確率の過負荷になります他の対称ブロック暗号と異なるアルゴリズムは、同じ入力します。 同様に、任意の適切なキー付きハッシュ関数も強力な擬似関数 (PRF) は、特定の固定入力セットの出力は圧倒的になりますの他のキー付きハッシュ関数とは異なります。

コンテキスト ヘッダーを構築するこの強力な PRPs と PRFs の概念を使用します。 このコンテキスト ヘッダーが本質的には、指定された操作に使用するアルゴリズムを安定した拇印として機能し、データ保護システムに必要な暗号化方式の指定を提供します。 このヘッダーは、再現可能なとの一部として後で使用されて、[サブキーの派生プロセス](subkeyderivation.md#data-protection-implementation-subkey-derivation)です。 基になるアルゴリズムの動作モードに応じて、コンテキスト ヘッダーを構築する 2 つの方法があります。

## <a name="cbc-mode-encryption--hmac-authentication"></a>CBC モードの暗号化 + HMAC 認証

<a name="data-protection-implementation-context-headers-cbc-components"></a>

コンテキスト ヘッダーは、次のコンポーネントで構成されます。

* [16 ビット]値 00 00 で、マーカーは、「CBC 暗号化 + HMAC 認証」を意味します。

* [32 ビット]対称ブロック暗号アルゴリズムのキーの長さ (単位はバイト、ビッグ エンディアン)。

* [32 ビット]ブロックのサイズ (バイト、ビッグ エンディアン) 対称ブロック暗号アルゴリズム。

* [32 ビット]HMAC アルゴリズムのキーの長さ (単位はバイト、ビッグ エンディアン)。 (現在のキー サイズ常にサイズに一致ダイジェスト。)

* [32 ビット]ダイジェストのサイズ (バイト、ビッグ エンディアン) HMAC アルゴリズムです。

* EncCBC (K_E、IV、"")、これは、空の文字列入力を使用する対称ブロック暗号アルゴリズムの出力および IV がすべてゼロ ベクターがします。 K_E の構築は次のとおりです。

* MAC (K_H、"")、これは、空の文字列入力を使用する HMAC アルゴリズムの出力。 K_H の構築は次のとおりです。

理想的にはすべてゼロのベクトル K_E および K_H 渡します可能性があります。 ただし、基になるアルゴリズムがすべてゼロ ベクターのような単純型または反復可能なパターンを使用してを除外する (特に DES、3 des) の操作を実行する前に弱いキーの有無を確認するような状況を回避します。

代わりに、NIST SP800 108 KDF カウンター モードで使用 (を参照してください[NIST SP800 108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)、秒 5.1) 長さ 0 キー、ラベル、およびコンテキストおよび基になる PRF として HMACSHA512 を使用します。 派生お |K_E |+ |K_H |出力のバイトし、結果に分解 K_E と K_H 自体です。 数学的に、これはように表されます。

(K_E | |K_H) = SP800_108_CTR (prf = HMACSHA512、key =""、ラベル =""、コンテキスト ="")

### <a name="example-aes-192-cbc--hmacsha256"></a>例: AES、192-CBC + HMACSHA256

例として、対称ブロック暗号アルゴリズムは、AES 192-CBC し検証アルゴリズムが HMACSHA256 場合を検討してください。 システムには、次の手順を使用して、コンテキスト ヘッダーが生成されます。

まず、(K_E | |K_H) = SP800_108_CTR (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="")、|K_E |= 192 ビットおよび |K_H |指定したアルゴリズムごとの 256 ビットを = です。 これは、ため、K_E に = 5BB6.21DD と K_H = A04A.次の例で 00A9:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

次に、コンピューティング Enc_CBC (K_E、IV、"") CBC 192 AES IV を指定された = 0 * と上と K_E です。

結果: F474B1872B3B53E4721DE19C0841DB6F を =

次に、MAC の計算 (K_H、"") HMACSHA256 K_H 上記として指定されているためです。

結果: D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C を =

これには、以下の内容を含むヘッダーが生成されます。

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

このコンテキスト ヘッダーは、認証済み暗号化アルゴリズムのペア (CBC 192、AES で暗号化 + HMACSHA256 検証) のサムプリントです。 コンポーネントの説明に従って[上](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components)は。

* マーカー (00 00)

* ブロック暗号キーの長さ (00 00 00 18)

* ブロック暗号ブロック サイズ (00 00 00 10)

* HMAC キーの長さ (00 00 00 20)

* HMAC ダイジェストのサイズ (00 00 00 20)

* ブロック暗号 PRP 出力 (F4 74 - DB 6 f) と

* HMAC PRF 出力 (D4 79 - 終了)。

> [!NOTE]
> CBC モードの暗号化 + HMAC 認証コンテキスト ヘッダーは、Windows CNG またはマネージ対称アルゴリズムおよび KeyedHashAlgorithm 型にアルゴリズムの実装を提供するかどうかに関係なく同じ方法を構築します。 これにより、アルゴリズムの実装は Os によって異なる場合でも、同じコンテキスト ヘッダーを確実に生成するためにさまざまなオペレーティング システムで実行されているアプリケーション。 (実際には、KeyedHashAlgorithm しないが適切な HMAC です。 だということ、キー付きハッシュ アルゴリズムの種類です。)

### <a name="example-3des-192-cbc--hmacsha1"></a>例: 3 des 192-CBC + HMACSHA1

まず、(K_E | |K_H) = SP800_108_CTR (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="")、|K_E |= 192 ビットおよび |K_H |指定したアルゴリズムごとの 160 ビットを = です。 これは、ため、K_E に = A219.E2BB と K_H = DC4A.次の例で B464:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

次に、コンピューティング Enc_CBC (K_E、IV、"") CBC 192 3 des IV を指定された = 0 * と上と K_E です。

結果: ABB100F81E53E10E を =

次に、MAC の計算 (K_H、"") HMACSHA1 K_H 上記として指定されているためです。

結果: 76EB189B35CF03461DDF877CD9F4B1B4D63A7555 を =

これにより、認証の拇印である完全コンテキスト ヘッダーが生成されます。 暗号化アルゴリズムの組み合わせ (3 des 192-CBC 暗号化 + HMACSHA1 検証)、次に示します。

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

コンポーネントが次のように分割します。

* マーカー (00 00)

* ブロック暗号キーの長さ (00 00 00 18)

* ブロック暗号ブロック サイズ (00 00 00 08)

* HMAC キーの長さ (00 00 00 14)

* HMAC ダイジェストのサイズ (00 00 00 14)

* PRP 出力 (AB B1 - E1 0 e) ブロック暗号と

* HMAC PRF 出力 (76 EB - 終了)。

## <a name="galoiscounter-mode-encryption--authentication"></a>Galois/カウンター モードの暗号化と認証

コンテキスト ヘッダーは、次のコンポーネントで構成されます。

* [16 ビット]値 00 はマーカー 01「GCM 暗号化 + 認証」を意味します。

* [32 ビット]対称ブロック暗号アルゴリズムのキーの長さ (単位はバイト、ビッグ エンディアン)。

* [32 ビット]Nonce サイズ (バイト単位、ビッグ エンディアン) 中に使用するには、暗号化操作が認証されます。 (当社のシステムでの nonce のサイズに固定これは 96 ビットを = です)。

* [32 ビット]ブロックのサイズ (バイト、ビッグ エンディアン) 対称ブロック暗号アルゴリズム。 (GCM、これが固定ブロック サイズでは 128 ビットを = です)。

* [32 ビット]認証タグ サイズ (バイト単位、ビッグ エンディアン)、認証済み暗号化関数によって生成されます。 (当社のシステムでのタグのサイズに固定これは、128 ビットを = です)。

* [128 ビット]Enc_GCM のタグ (K_E、nonce、"")、これは、空の文字列入力を使用する対称ブロック暗号アルゴリズムの出力および nonce が 96 ビットすべてゼロのベクトルがします。

CBC 暗号化 + HMAC 認証のシナリオと同様に同じメカニズムを使用して K_E が派生します。 ただし、このアプローチで K_H がしないため、本質的にある |K_H |= 0 の場合、アルゴリズムを解除し、フォームの下。

K_E = SP800_108_CTR (prf = HMACSHA512、key =""、ラベル =""、コンテキスト ="")

### <a name="example-aes-256-gcm"></a>例: AES 256 GCM

まず、K_E = SP800_108_CTR (prf = HMACSHA512、キー =""、ラベル =""、コンテキスト ="") ここで、|K_E |= 256 ビットです。

K_E: 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8 を =

Enc_GCM の認証タグを次に、コンピューティング (K_E、nonce、"") GCM 256 AES nonce を指定された = 096 と K_E 上記と同じです。

結果: E7DCCE66DF855A323A6BB7BD7A59BE45 を =

これには、以下の内容を含むヘッダーが生成されます。

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

コンポーネントが次のように分割します。

   * マーカー (00 01)

   * ブロック暗号キーの長さ (00 00 00 20)

   * nonce のサイズ (00 00 00 0 C)

   * ブロック暗号ブロック サイズ (00 00 00 10)

   * 認証タグのサイズ (00 00 00 10) と

   * 実行中のブロック暗号から認証タグ (E7 DC - 終了)。
