---
title: サブキーの派生と ASP.NET Core での認証済みの暗号化
author: rick-anderson
description: ASP.NET Core データ保護の実装の詳細はサブキーを派生し、暗号化の認証について説明します。
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 8c83da40a524896becc07c94c01d5e2b684e4386
ms.sourcegitcommit: 48beecfe749ddac52bc79aa3eb246a2dcdaa1862
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/22/2018
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="dce88-103">サブキーの派生と ASP.NET Core での認証済みの暗号化</span><span class="sxs-lookup"><span data-stu-id="dce88-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="dce88-104">キー リング内のほとんどのキー エントロピの何らかの形式にが含まれます、「CBC モードの暗号化 + HMAC 検証」ことを示すアルゴリズム情報を保持または「GCM 暗号化 + 検証」です。</span><span class="sxs-lookup"><span data-stu-id="dce88-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="dce88-105">このような場合は、埋め込みのエントロピをこのキーのマスター キー生成情報 (または KM) と呼びます、実際の暗号化操作に使用されるキーを派生させるキーの派生関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="dce88-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="dce88-106">キーは抽象クラスで、次に示すように、カスタムの実装が動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="dce88-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="dce88-107">キーは、独自の実装を提供する場合`IAuthenticatedEncryptor`組み込み工場のいずれかを使用してではなくこのセクションで説明するメカニズムが適用されなくなった。</span><span class="sxs-lookup"><span data-stu-id="dce88-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="dce88-108">追加の認証済みデータとサブキーの派生</span><span class="sxs-lookup"><span data-stu-id="dce88-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="dce88-109">`IAuthenticatedEncryptor`インターフェイスが認証済み暗号化操作はすべてのコア インターフェイスとして機能します。</span><span class="sxs-lookup"><span data-stu-id="dce88-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="dce88-110">その`Encrypt`メソッドは 2 つのバッファーを受け取ります。 プレーン テキストと additionalAuthenticatedData (AAD)。</span><span class="sxs-lookup"><span data-stu-id="dce88-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="dce88-111">プレーン テキスト コンテンツ フローへの呼び出しをそのまま`IDataProtector.Protect`AAD は、システムによって生成され、3 つのコンポーネントで構成されていますが、します。</span><span class="sxs-lookup"><span data-stu-id="dce88-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="dce88-112">32 ビット マジック ヘッダー 09 F0 C9 F0、データ保護システムのこのバージョンを識別します。</span><span class="sxs-lookup"><span data-stu-id="dce88-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="dce88-113">128 ビットのキー id です。</span><span class="sxs-lookup"><span data-stu-id="dce88-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="dce88-114">作成する目的のチェーンから形成される可変長の文字列、`IDataProtector`この操作を実行しています。</span><span class="sxs-lookup"><span data-stu-id="dce88-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="dce88-115">AAD は 3 つの要素のタプルに対して一意であるためを KM から KM 自体すべてのページで、暗号化操作を使用する代わりに新しいキーを派生させるために使用できます。</span><span class="sxs-lookup"><span data-stu-id="dce88-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="dce88-116">呼び出すたびに`IAuthenticatedEncryptor.Encrypt`、次のキー派生のプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="dce88-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="dce88-117">(K_E、K_H) = SP800_108_CTR_HMACSHA512 (K_M、AAD を contextHeader | | keyModifier)</span><span class="sxs-lookup"><span data-stu-id="dce88-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="dce88-118">ここでは、NIST SP800 108 KDF カウンター モードにかけています (を参照してください[NIST SP800 108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)、秒 5.1) は次のパラメーター。</span><span class="sxs-lookup"><span data-stu-id="dce88-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="dce88-119">キー派生キー (KDK) K_M を =</span><span class="sxs-lookup"><span data-stu-id="dce88-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="dce88-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="dce88-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="dce88-121">label = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="dce88-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="dce88-122">context = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="dce88-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="dce88-123">コンテキスト ヘッダーが可変長の本質的に拇印をしている派生 K_E と K_H アルゴリズムの役割を果たします。</span><span class="sxs-lookup"><span data-stu-id="dce88-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="dce88-124">キーの修飾子は呼び出しごとにランダムに生成される 128 ビット文字列`Encrypt`KE と KH が一意であるこの特定の認証暗号化操作の場合でも、他のすべての入力、KDF には定数確率の過負荷を確実に機能します。</span><span class="sxs-lookup"><span data-stu-id="dce88-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="dce88-125">CBC モードの暗号化 + HMAC 検証操作では、|K_E |対称ブロック暗号キーの長さと |K_H |HMAC ルーチンのダイジェストのサイズです。</span><span class="sxs-lookup"><span data-stu-id="dce88-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="dce88-126">GCM 暗号化 + 検証操作 |K_H |= 0。</span><span class="sxs-lookup"><span data-stu-id="dce88-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="dce88-127">CBC モードの暗号化 + HMAC 検証</span><span class="sxs-lookup"><span data-stu-id="dce88-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="dce88-128">K_E が上記のメカニズムによって生成されるはランダムな初期化ベクトルを生成し、プレーン テキストを暗号化する対称ブロック暗号アルゴリズムを実行します。</span><span class="sxs-lookup"><span data-stu-id="dce88-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="dce88-129">暗号化テキストと初期化ベクトル K_H MAC を生成するために、キーを使用して初期化 HMAC ルーチンを通じて実行されます。</span><span class="sxs-lookup"><span data-stu-id="dce88-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="dce88-130">このプロセスと戻り値は、次に示す視覚的に表されます。</span><span class="sxs-lookup"><span data-stu-id="dce88-130">This process and the return value is represented graphically below.</span></span>

![CBC モードのプロセスと戻り値](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="dce88-132">*出力: keyModifier を = | |iv | |E_cbc (K_E、iv、データ) | |HMAC (K_H、iv | |E_cbc (K_E、iv、データ))*</span><span class="sxs-lookup"><span data-stu-id="dce88-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="dce88-133">`IDataProtector.Protect`実装は[マジック ヘッダーとキーの id を付加](xref:security/data-protection/implementation/authenticated-encryption-details)を呼び出し元に返す前に出力します。</span><span class="sxs-lookup"><span data-stu-id="dce88-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="dce88-134">ヘッダーのマジックとキーの id は、暗黙的にするための一部[AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)MAC で最後に返されるペイロードの各バイトの 1 つが認証されていること、キーの修飾子が、KDF への入力としてが取り込まれるため</span><span class="sxs-lookup"><span data-stu-id="dce88-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="dce88-135">Galois/カウンター モードの暗号化と検証</span><span class="sxs-lookup"><span data-stu-id="dce88-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="dce88-136">上記のメカニズムを使用して K_E が生成されると、おランダム 96 ビット nonce を生成し、プレーン テキストを暗号化し、128 ビット認証タグを生成する対称ブロック暗号アルゴリズムを実行します。</span><span class="sxs-lookup"><span data-stu-id="dce88-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM モードのプロセスと戻り値](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="dce88-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span><span class="sxs-lookup"><span data-stu-id="dce88-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="dce88-139">GCM ネイティブにサポートされていますが、AAD の概念、おいるまだ給紙 AAD 元の KDF にのみ、AAD パラメーターに GCM に空の文字列を渡すを無効にします。</span><span class="sxs-lookup"><span data-stu-id="dce88-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="dce88-140">この理由は、2 つの面です。</span><span class="sxs-lookup"><span data-stu-id="dce88-140">The reason for this is two-fold.</span></span> <span data-ttu-id="dce88-141">最初に、[機敏性をサポートするために](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers)暗号化キーとして直接 K_M を使用することはありません。</span><span class="sxs-lookup"><span data-stu-id="dce88-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="dce88-142">さらに、GCM には、その入力に非常に厳格な一意性の要件が適用されます。</span><span class="sxs-lookup"><span data-stu-id="dce88-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="dce88-143">GCM 暗号化ルーチンが 2 つのこれまで呼び出されたかより明確である確率を設定 (キー、nonce) 同じ入力データのペアは以内で 2 ^32 です。</span><span class="sxs-lookup"><span data-stu-id="dce88-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="dce88-144">K_E も修正する場合実行できませんでした。 複数の 2 ^ 32 の暗号化操作は、2 への実行前に ^-32 を制限します。</span><span class="sxs-lookup"><span data-stu-id="dce88-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="dce88-145">これは非常に多数の操作と同様にですが、高トラフィックの web サーバーは、これらのキーの通常の有効期間の範囲内で、単なる日以内に 40億要求を通過できます。</span><span class="sxs-lookup"><span data-stu-id="dce88-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="dce88-146">2 の準拠を維持する ^128 ビット キーの修飾子と 96 ビット nonce は、任意指定 K_M の使用可能な操作の数を大幅に拡張を使用してまいります-32 確率制限します。</span><span class="sxs-lookup"><span data-stu-id="dce88-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="dce88-147">CBC と GCM 操作間 KDF コード パスを共有おわかりやすくするためのデザインと AAD は既に、KDF で考慮ためには、GCM ルーチンに転送する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="dce88-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
